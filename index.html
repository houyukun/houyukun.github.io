<html><head><meta charset="utf-8"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css" integrity="sha384-B41nY7vEWuDrE9Mr+J2nBL0Liu+nl/rBXTdpQal730oTHdlrlXHzYMOhDU60cwde" crossorigin="anonymous"><style>.markdown-body hr::after,.markdown-body::after{clear:both}.loopLine,.messageLine0{marker-end:"url(#arrowhead)"}@font-face{font-family:octicons-link;src:url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff')}.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";line-height:1.5;word-wrap:break-word}.markdown-body .pl-c{color:#6a737d}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#005cc5}.markdown-body .pl-e,.markdown-body .pl-en{color:#6f42c1}.markdown-body .pl-s .pl-s1,.markdown-body .pl-smi{color:#24292e}.markdown-body .pl-ent{color:#22863a}.markdown-body .pl-k{color:#d73a49}.markdown-body .pl-pds,.markdown-body .pl-s,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sra,.markdown-body .pl-sr .pl-sre{color:#032f62}.markdown-body .pl-smw,.markdown-body .pl-v{color:#e36209}.markdown-body .pl-bu{color:#b31d28}.markdown-body .pl-ii{color:#fafbfc;background-color:#b31d28}.markdown-body .pl-c2{color:#fafbfc;background-color:#d73a49}.markdown-body .pl-c2::before{content:"^M"}.markdown-body .pl-sr .pl-cce{font-weight:700;color:#22863a}.markdown-body .pl-ml{color:#735c0f}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{font-weight:700;color:#005cc5}.markdown-body .pl-mi{font-style:italic;color:#24292e}.markdown-body .pl-mb{font-weight:700;color:#24292e}.markdown-body .pl-md{color:#b31d28;background-color:#ffeef0}.markdown-body .pl-mi1{color:#22863a;background-color:#f0fff4}.markdown-body .pl-mc{color:#e36209;background-color:#ffebda}.markdown-body .pl-mi2{color:#f6f8fa;background-color:#005cc5}.markdown-body .pl-mdr{font-weight:700;color:#6f42c1}.markdown-body .pl-ba{color:#586069}.markdown-body .pl-sg{color:#959da5}.markdown-body .pl-corl{text-decoration:underline;color:#032f62}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body hr::after,.markdown-body hr::before,.markdown-body::after,.markdown-body::before{display:table;content:""}.markdown-body a{background-color:transparent;-webkit-text-decoration-skip:objects;color:#0366d6;text-decoration:none}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body h1{margin:.67em 0}.markdown-body img{border-style:none}.markdown-body svg:not(:root){overflow:hidden}.markdown-body hr{box-sizing:content-box}.markdown-body input{font:inherit;margin:0;overflow:visible;font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body [type=checkbox]{box-sizing:border-box;padding:0}.markdown-body *{box-sizing:border-box}.markdown-body a:hover{text-decoration:underline}.markdown-body strong{font-weight:600}.markdown-body td,.markdown-body th{padding:0}.markdown-body blockquote{margin:0}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body .task-list-item,ul.table-of-contents{list-style-type:none}.markdown-body dd{margin-left:0}.markdown-body code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace}.markdown-body pre{font:12px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;word-wrap:normal}.markdown-body .pl-0{padding-left:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .pl-3{padding-left:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .anchor{float:left;padding-right:4px;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:0}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-top:0;margin-bottom:16px}.markdown-body hr{overflow:hidden;background:#e1e4e8;height:.25em;padding:0;margin:24px 0;border:0}.markdown-body blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}.markdown-body h1,.markdown-body h2{padding-bottom:.3em;border-bottom:1px solid #eaecef}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h6{color:#6a737d}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 16px;margin-bottom:16px}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{padding:6px 13px;border:1px solid #dfe2e5}.markdown-body table tr{background-color:#fff;border-top:1px solid #c6cbd1}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body img{max-width:100%;box-sizing:content-box;background-color:#fff}.markdown-body code{padding:.2em 0;margin:0;font-size:85%;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code::after,.markdown-body code::before{letter-spacing:-.2em;content:"\00a0"}.markdown-body pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}.markdown-body pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body pre code::after,.markdown-body pre code::before{content:normal}.markdown-body .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}.markdown-body kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-bottom-color:#c6cbd1;border-radius:3px;box-shadow:inset 0 -1px 0 #c6cbd1}.node text,.noteText,div.mermaidTooltip{font-family:'trebuchet ms',verdana,arial}.markdown-body :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}.markdown-body .task-list-item+.task-list-item{margin-top:3px}.markdown-body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.markdown-body hr{border-bottom-color:#eee}.hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-meta,.hljs-strong{font-weight:700}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.mermaid .label{color:#333}.node circle,.node ellipse,.node polygon,.node rect{fill:#ECECFF;stroke:#CCF;stroke-width:1px}.edgePath .path{stroke:#333}.edgeLabel{background-color:#e8e8e8}.cluster rect{fill:#ffffde!important;rx:4!important;stroke:#aa3!important;stroke-width:1px!important}.cluster text{fill:#333}.actor{stroke:#CCF;fill:#ECECFF}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0,.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#CCF;fill:#ECECFF}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";stroke:#CCF}.note{stroke:#aa3;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-size:14px}.section{stroke:none;opacity:.2}.section0{fill:rgba(102,102,255,.49)}.section2{fill:#fff400}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:#d3d3d3;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#8a90dd;stroke:#534fbc}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#bfc7ff;stroke:#534fbc}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:#d3d3d3;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#bfc7ff;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}.node text{font-size:14px}div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-size:12px;background:#ffffde;border:1px solid #aa3;border-radius:2px;pointer-events:none;z-index:100}@font-face{font-family:KaTeX_AMS;src:url(fonts/KaTeX_AMS-Regular.eot);src:url(fonts/KaTeX_AMS-Regular.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_AMS-Regular.woff2) format('woff2'),url(fonts/KaTeX_AMS-Regular.woff) format('woff'),url(fonts/KaTeX_AMS-Regular.ttf) format('truetype');font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Caligraphic;src:url(fonts/KaTeX_Caligraphic-Bold.eot);src:url(fonts/KaTeX_Caligraphic-Bold.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Caligraphic-Bold.woff2) format('woff2'),url(fonts/KaTeX_Caligraphic-Bold.woff) format('woff'),url(fonts/KaTeX_Caligraphic-Bold.ttf) format('truetype');font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Caligraphic;src:url(fonts/KaTeX_Caligraphic-Regular.eot);src:url(fonts/KaTeX_Caligraphic-Regular.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Caligraphic-Regular.woff2) format('woff2'),url(fonts/KaTeX_Caligraphic-Regular.woff) format('woff'),url(fonts/KaTeX_Caligraphic-Regular.ttf) format('truetype');font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Fraktur;src:url(fonts/KaTeX_Fraktur-Bold.eot);src:url(fonts/KaTeX_Fraktur-Bold.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Fraktur-Bold.woff2) format('woff2'),url(fonts/KaTeX_Fraktur-Bold.woff) format('woff'),url(fonts/KaTeX_Fraktur-Bold.ttf) format('truetype');font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Fraktur;src:url(fonts/KaTeX_Fraktur-Regular.eot);src:url(fonts/KaTeX_Fraktur-Regular.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Fraktur-Regular.woff2) format('woff2'),url(fonts/KaTeX_Fraktur-Regular.woff) format('woff'),url(fonts/KaTeX_Fraktur-Regular.ttf) format('truetype');font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Bold.eot);src:url(fonts/KaTeX_Main-Bold.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Main-Bold.woff2) format('woff2'),url(fonts/KaTeX_Main-Bold.woff) format('woff'),url(fonts/KaTeX_Main-Bold.ttf) format('truetype');font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Italic.eot);src:url(fonts/KaTeX_Main-Italic.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Main-Italic.woff2) format('woff2'),url(fonts/KaTeX_Main-Italic.woff) format('woff'),url(fonts/KaTeX_Main-Italic.ttf) format('truetype');font-weight:400;font-style:italic}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Regular.eot);src:url(fonts/KaTeX_Main-Regular.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Main-Regular.woff2) format('woff2'),url(fonts/KaTeX_Main-Regular.woff) format('woff'),url(fonts/KaTeX_Main-Regular.ttf) format('truetype');font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Math;src:url(fonts/KaTeX_Math-Italic.eot);src:url(fonts/KaTeX_Math-Italic.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Math-Italic.woff2) format('woff2'),url(fonts/KaTeX_Math-Italic.woff) format('woff'),url(fonts/KaTeX_Math-Italic.ttf) format('truetype');font-weight:400;font-style:italic}@font-face{font-family:KaTeX_SansSerif;src:url(fonts/KaTeX_SansSerif-Regular.eot);src:url(fonts/KaTeX_SansSerif-Regular.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_SansSerif-Regular.woff2) format('woff2'),url(fonts/KaTeX_SansSerif-Regular.woff) format('woff'),url(fonts/KaTeX_SansSerif-Regular.ttf) format('truetype');font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Script;src:url(fonts/KaTeX_Script-Regular.eot);src:url(fonts/KaTeX_Script-Regular.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Script-Regular.woff2) format('woff2'),url(fonts/KaTeX_Script-Regular.woff) format('woff'),url(fonts/KaTeX_Script-Regular.ttf) format('truetype');font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size1;src:url(fonts/KaTeX_Size1-Regular.eot);src:url(fonts/KaTeX_Size1-Regular.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Size1-Regular.woff2) format('woff2'),url(fonts/KaTeX_Size1-Regular.woff) format('woff'),url(fonts/KaTeX_Size1-Regular.ttf) format('truetype');font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size2;src:url(fonts/KaTeX_Size2-Regular.eot);src:url(fonts/KaTeX_Size2-Regular.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Size2-Regular.woff2) format('woff2'),url(fonts/KaTeX_Size2-Regular.woff) format('woff'),url(fonts/KaTeX_Size2-Regular.ttf) format('truetype');font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size3;src:url(fonts/KaTeX_Size3-Regular.eot);src:url(fonts/KaTeX_Size3-Regular.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Size3-Regular.woff2) format('woff2'),url(fonts/KaTeX_Size3-Regular.woff) format('woff'),url(fonts/KaTeX_Size3-Regular.ttf) format('truetype');font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size4;src:url(fonts/KaTeX_Size4-Regular.eot);src:url(fonts/KaTeX_Size4-Regular.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Size4-Regular.woff2) format('woff2'),url(fonts/KaTeX_Size4-Regular.woff) format('woff'),url(fonts/KaTeX_Size4-Regular.ttf) format('truetype');font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Typewriter;src:url(fonts/KaTeX_Typewriter-Regular.eot);src:url(fonts/KaTeX_Typewriter-Regular.eot#iefix) format('embedded-opentype'),url(fonts/KaTeX_Typewriter-Regular.woff2) format('woff2'),url(fonts/KaTeX_Typewriter-Regular.woff) format('woff'),url(fonts/KaTeX_Typewriter-Regular.ttf) format('truetype');font-weight:400;font-style:normal}.katex-display{display:block;margin:1em 0;text-align:center}.katex .base,.katex .katex-html,.katex .strut{display:inline-block}.katex-display>.katex{display:inline-block;text-align:initial}.katex{font:400 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;white-space:nowrap;text-indent:0;text-rendering:auto}.katex *{-ms-high-contrast-adjust:none!important}.katex .katex-mathml{position:absolute;clip:rect(1px,1px,1px,1px);padding:0;border:0;height:1px;width:1px;overflow:hidden}.katex .base,.katex .vlist,.katex .vlist>span{position:relative}.katex .mathrm{font-style:normal}.katex .mainit,.katex .mathit,.katex .textit{font-style:italic}.katex .mathit{font-family:KaTeX_Math}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .amsrm,.katex .mathbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr{font-family:KaTeX_Script}.katex .mathsf{font-family:KaTeX_SansSerif}.katex .mainit,.katex .mainrm{font-family:KaTeX_Main}.katex .mainrm{font-style:normal}.katex .mord+.mop{margin-left:.16667em}.katex .mord+.mbin{margin-left:.22222em}.katex .mord+.mrel{margin-left:.27778em}.katex .mop+.mop,.katex .mop+.mord,.katex .mord+.minner{margin-left:.16667em}.katex .mop+.mrel{margin-left:.27778em}.katex .mop+.minner{margin-left:.16667em}.katex .mbin+.minner,.katex .mbin+.mop,.katex .mbin+.mopen,.katex .mbin+.mord{margin-left:.22222em}.katex .mrel+.minner,.katex .mrel+.mop,.katex .mrel+.mopen,.katex .mrel+.mord{margin-left:.27778em}.katex .mclose+.mop{margin-left:.16667em}.katex .mclose+.mbin{margin-left:.22222em}.katex .mclose+.mrel{margin-left:.27778em}.katex .mclose+.minner,.katex .minner+.mop,.katex .minner+.mord,.katex .mpunct+.mclose,.katex .mpunct+.minner,.katex .mpunct+.mop,.katex .mpunct+.mopen,.katex .mpunct+.mord,.katex .mpunct+.mpunct,.katex .mpunct+.mrel{margin-left:.16667em}.katex .minner+.mbin{margin-left:.22222em}.katex .minner+.mrel{margin-left:.27778em}.katex .minner+.minner,.katex .minner+.mopen,.katex .minner+.mpunct{margin-left:.16667em}.katex .mbin.mtight,.katex .mclose.mtight,.katex .minner.mtight,.katex .mop.mtight,.katex .mopen.mtight,.katex .mord.mtight,.katex .mpunct.mtight,.katex .mrel.mtight{margin-left:0}.katex .mclose+.mop.mtight,.katex .minner+.mop.mtight,.katex .mop+.mop.mtight,.katex .mop+.mord.mtight,.katex .mord+.mop.mtight{margin-left:.16667em}.katex .vlist-t{display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;vertical-align:bottom}.katex .vlist>span{display:block;height:0}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;vertical-align:bottom;font-size:1px;width:2px}.katex .fontsize-ensurer,.katex .llap>.fix,.katex .mfrac .frac-line,.katex .mspace,.katex .mtable .arraycolsep,.katex .mtable .vertical-separator,.katex .nulldelimiter,.katex .rlap>.fix,.katex .rule,.katex .sizing{display:inline-block}.katex .msupsub{text-align:left}.katex .accent>.vlist-t,.katex .mfrac>span>span,.katex .mtable .col-align-c>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .mfrac .frac-line{width:100%;border-bottom-style:solid}.katex .mspace.negativethinspace{margin-left:-.16667em}.katex .mspace.thinspace{width:.16667em}.katex .mspace.negativemediumspace{margin-left:-.22222em}.katex .mspace.mediumspace{width:.22222em}.katex .mspace.thickspace{width:.27778em}.katex .mspace.sixmuspace{width:.333333em}.katex .mspace.eightmuspace{width:.444444em}.katex .mspace.enspace{width:.5em}.katex .mspace.twelvemuspace{width:.666667em}.katex .mspace.quad{width:1em}.katex .mspace.qquad{width:2em}.katex .llap,.katex .rlap{width:0;position:relative}.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .llap>.inner{right:0}.katex .rlap>.inner{left:0}.katex .katex-logo .a{font-size:.75em;margin-left:-.32em;position:relative;top:-.2em}.katex .katex-logo .t{margin-left:-.23em}.katex .katex-logo .e{margin-left:-.1667em;position:relative;top:.2155em}.katex .katex-logo .x{margin-left:-.125em}.katex .rule{border:0 solid;position:relative}.katex .overline .overline-line,.katex .underline .underline-line{display:inline-block;width:100%;border-bottom-style:solid}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent .accent-body>span{width:0}.katex .accent .accent-body.accent-vec>span{position:relative;left:.326em}.katex .accent .accent-body.accent-hungarian>span{position:relative;left:.25em}.katex .mtable .vertical-separator{margin:0 -.025em;border-right:.05em solid #000}.katex .stretchy,.katex svg{width:100%;display:block}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex .mover,.katex .munder,.katex .x-arrow,div.mermaid{text-align:center}.katex svg{position:absolute}.katex svg path{fill:currentColor}.katex svg line{stroke:currentColor}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .x-arrow-pad{padding:0 .5em}.katex .boxpad{padding:0 .3em}.katex .fbox{box-sizing:border-box;border:.04em solid #000}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap+.mbin,.katex .cancel-lap+.mord,.katex .cancel-lap+.msupsub,.katex .mbin+.cancel-lap,.katex .mord+.cancel-lap{margin-left:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}body{margin:0;padding:0}.markdown-body{min-width:256px;max-width:978px;margin:0 auto;padding:20px;font-size:14px}.markdown-body h1{font-size:2.25em}.markdown-body h2{font-size:1.75em}.markdown-body h3{font-size:1.5em}.markdown-body h4{font-size:1.25em}.markdown-body h5,.markdown-body h6{font-size:1em}div.mermaid svg{height:auto}hr.footnotes-sep{margin:64px 0 32px;height:1px}.footnotes{font-size:90%;padding-left:16px}li.footnote-item>p{margin:8px 0}.danger,.info,.success,.warning{padding:15px;margin-bottom:20px;border:1px solid transparent;border-radius:4px}.danger>p:last-child,.info>p:last-child,.success>p:last-child,.warning>p:last-child{margin-bottom:0}.success{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.info{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.warning{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.danger{color:#a94442;background-color:#f2dede;border-color:#ebccd1}abbr[title]{cursor:help;border-bottom:1px dotted #777}ul.table-of-contents li{margin:4px 0}.markdown-body table{border-spacing:0;border-collapse:collapse;width:auto;display:table;}.markdown-body table td,.markdown-body table th{word-break:break-all}</style></head><article class="markdown-body" id="preview" data-open-title="Hide Preview" data-closed-title="Show Preview" style="padding-bottom: 0px;"><div><h1 data-source-line="3" id="第-1-章-序言"><a class="markdownIt-Anchor" href="#第-1-章-序言"></a>第 1 章 序言</h1>
<pre data-source-line="5"><code class="hljs"><span class="zh-hans">本书已被字节跳动收录为公司级别的，新员工入职培训的通用基础课程，帮助近千名员工更加深入全面的了解他们最亲密的工作伙伴。</span>
</code></pre><p data-source-line="9">对于程序员来说，每天陪女朋友和枕头的时间可能加起来还不如使用 Mac 久，但大多数人对朝夕相处的生产力工具并不了解，并不知道很多重复且复杂的操作，是有办法简化、甚至自动化完成的。</p>
<p data-source-line="11">从我走上工作岗位来，就一直致力于解决各种 Mac 使用过程中常见的痛点，提高程序员的工作效率。在探索的过程中，查找、学习、尝试并比较了大量的方案，最终总结整理出一套相对比较优秀的实践指南，方便读者直接拿来使用，而不用再花费同样的时间，重新走一次我走过的老路。考虑到很多知识和技巧无法用文字简单的描述，本书还录制了几十个屏幕操作，用于更直观的向读者演示。</p>
<p data-source-line="13">经过两年多的准备，我觉得已经等到了成熟的时机，因此抱着忐忑和学习的心态将这几年的所学整理成文字，介绍给广大 Mac 使用者。通过对本书知识的学习，相信每位读者都可以每年轻松省出一个年假，在别人熬夜加班的时候享受空余时间。</p>
<p data-source-line="15">仅靠一本书无法覆盖所有的使用场景，并且由于能力所限，我也不敢保证提供的方案就一定是最佳实践。像 spc13 这样单独的 Vim 配置能拿到 12k+ 的星星，足以证明它在 Vim 领域的研究比我深入得多。但我希望说清楚这些配置做了什么，而不是简单的丢给读者一个脚本。虽然站在应该巨人的肩膀上，但起码要知道巨人是怎么长成的，毕竟我相信：授人以鱼不如授人以渔，只有掌握了一些核心概念，后面才能随心所欲的定制</p>
<p data-source-line="17">本书共分为五章，从系统配置、Mac 工作流、编辑器之神：Vim、Git 从入门到进阶、终极武器 Zsh等方面去打造一个高效的工作流，致力于提高 Mac 工作效率的实用手册。</p>
<p data-source-line="19"><strong>第一章先从 Mac 系统说起</strong>，虽然大部分程序员都使用 Mac 电脑，但这个系统并不是为程序员量身定制的，为了考虑大多数用户，必然做出妥协。因此我们有必要做一些定制，让 Mac 系统对开发者更加友好。</p>
<p data-source-line="21"><strong>第二章会介绍各种神级软件</strong>，比如虽然颜值略低但功能爆表的邮件应用、完全可以替代系统终端的 iTerm2、Mac 上的最强应用（没有之一）Alfred、Chrome 的优秀插件，以及老生常谈的爱国上网最佳实践。</p>
<p data-source-line="23"><strong>第三章会介绍 VSCode 和 Vim 的使用</strong>，包括 Vim 的基本操作，快到超乎你想象的光标移动方式，让写代码变成一种享受的编辑技巧，以及各种 Life-Chaging 系列的插件。最后会介绍 VSCode + Vim 的最佳实践，从此忘掉老旧的 Sublime，抛弃慢到爆炸的 Atom 并且卸载掉 JetBrains 全家桶。</p>
<p data-source-line="25"><strong>第四章重点介绍 git 的进阶使用</strong>，首先会深入浅出的科普 git 的底层原理，让读者能对 git 有正确的认识，彻底摆脱只会 pull/add/commit/push 的小白状态。本章会对几乎所有常用的 git 命令做介绍，包括进阶命令的使用，以及常用参数的解释，结合 log 和 diff 两大工具，充分发挥 git 的版本控制能力。</p>
<p data-source-line="27"><strong>第五章是本书的精华所在</strong>，从实用角度出发，结合我近三年的 shell 经验，向读者展示一个奇妙的 shell 世界，挖掘前人大牛们留下来的宝藏。包含了 shell 模型的科普，系统常用命令的介绍，sed/awk 等进阶命令的使用，以及用大量用 shell 提高研发效率的例子。</p>
<p data-source-line="29">感谢我的前同事、上级，百度资深工程师汪双权老师带领我入门，没有他就没有这本书。感谢小专栏的负责人给予我的建议，让本书条理更加清晰。感谢我博客的所有读者提出的反馈建议，让本书更好。最后还要感谢我的女朋友给我的支持理解和帮助。</p>
<p data-source-line="31">张星宇
2018 年 9 月于北京</p>
<h2 data-source-line="36" id="第-11-章-写在阅读本书前"><a class="markdownIt-Anchor" href="#第-11-章-写在阅读本书前"></a>第 1.1 章 写在阅读本书前</h2>
<h3 data-source-line="37" id="为什么强调效率"><a class="markdownIt-Anchor" href="#为什么强调效率"></a>为什么强调效率</h3>
<p data-source-line="39">写下此书的目的是为了帮助 Mac 的使用者更加高效的使用他们手中的开发工具。在理想化的工作中，程序员的工作就是通过编写代码，让软件能够正常运行。</p>
<p data-source-line="41">但在工作中，我们难免要处理与本职编程工作无关的事务，占用了大量的工作时间。因此提高工作效率，本质上就是一个很简单的算术题：</p>
<pre data-source-line="43"><code class="hljs"><span class="hljs-attr">净节省时间 </span>=<span class="hljs-string"> 每天剩下的时间 * 工作天数 - 一次性学习时间</span></code></pre><p data-source-line="45">很明显净节省时间越多，提高效率就越值得、也越有必要。从公式里可以看出，想要提高净节省时间，有两个方案。</p>
<p data-source-line="47">其一是减少学习时间，尽量少走弯路，这也是写作本书的目的。</p>
<p data-source-line="49">其二是尽早开始学习，越早掌握这些技巧， 节省下来的时间就越多。</p>
<h3 data-source-line="50" id="我的价值观"><a class="markdownIt-Anchor" href="#我的价值观"></a>我的价值观</h3>
<p data-source-line="52">在开始正文的介绍前，我还想推广一下自己的价值观，正是这样的价值观，指导我做出了后面五章中的各种方案选型。</p>
<p data-source-line="54">我坚持认为<strong>没有最好的方案，只有最适合自己的方案</strong>。每个人都有不同的工作方式和需求，因此很难找到一套放之四海而皆准的方案。也许一个人绞尽脑汁想要解决的问题，别人永远也遇不到。因此比具体方案更重要的，是对原理的了解，和一颗好奇并且追求极致的心。</p>
<p data-source-line="56">我相信<strong>简单即是最美，简单即是最有效</strong>。奥卡姆剃刀原理告诉我们：“如非必要，勿增实体”。我见过很多人，系统里装满了应用，桌面乱七八糟，菜单栏显示各种插件，Dock 栏里面打开了各种软件，把 Mac 武装得像一艘航空母舰一样，但实际上得到了什么呢？无非是几个月也不打开一次，沦为收藏品的应用，和一堆乱七八糟的应用和文件，真的要用到的反而半天都找不到。这样的电脑其实就是外强中干的纸老虎，庞大的复杂度会悄悄的消耗掉程序员宝贵的时间，降低工作效率。</p>
<p data-source-line="58">我更愿意<strong>选择正确的方式，而不是最习惯的方式</strong>。习惯的方式并不一定适合自己，它不是懒于学习和改进的挡箭牌。要知道对于个体来说，方案一定有高下之分，而且优秀的方案永远是优秀的，甚至越来越优秀，而习惯是可以培养的。我们不能用战术上的勤奋来掩盖战略上的懒惰。</p>
<h2 data-source-line="59" id="常见误区"><a class="markdownIt-Anchor" href="#常见误区"></a>常见误区</h2>
<p data-source-line="60">写作本书的另一目的是希望通过具体的例子，纠正一些流传甚广的错误和误区。比如一说到键盘党，极客，人们往往有两种极端的误区。</p>
<p data-source-line="62">一种人会觉得键盘党是在装逼炫技，认为这样的操作过于复杂，毫无学习记忆的必要。其实不然， 有些快捷键或者命令行的使用确实学习成本不低，但一旦熟练使用，就<strong>很容易形成肌肉记忆</strong>。但鼠标的点击操作速度是存在上限的，因此我们应该尽可能选择<strong>快速、可自动化</strong>的方式去完成某个操作。</p>
<p data-source-line="64">而另一类人又容易陷入对键盘流的盲目崇拜中，觉得这样很极客，很酷炫，总想着用类似的方式完成所有任务。因此工作中我们也会见到一类同事，对任何操作都想尽办法做优化，花费了大量时间和精力，却没有意识到同类的事情并不很复杂，或者一年也发生不了几次，而程序员的最终目标是产出代码， 一切优化和努力的最终目标都应该是更快的产出代码，而不是酷炫的工作方式。因此，我们凡事都应该计算净收益，如果学习成本高，使用成本低，节省时间又不明显，那么就不值得去做。比较典型的例子就是试图把 Vim 打造成 IDE。</p>
<p data-source-line="66">因此在我看来，真正的极客并不关注完成操作的方式，而是理性计算成本和收益。不断的找到当下的痛点，选择学习成本最低，效率最高的方式去完成。</p>
<h2 data-source-line="67" id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a>准备工作</h2>
<p data-source-line="69">阅读本书不需要太多的知识背景，唯一需要了解的就是 HomeBrew。HomeBrew 是 Mac 系统的包管理工具，类似于 Node 的 npm，或者 iOS 的 Cocoapods，或者 Python 的 pip，亦或者 Ruby 的 gem。</p>
<p data-source-line="71">如果还没有安装 HomeBrew，安装起来也很简单，只要打开终端，输入以下命令即可：</p>
<pre data-source-line="73"><code class="hljs"><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/ruby -e "$(curl -fsSL https:/</span><span class="hljs-regexp">/raw.githubusercontent.com/</span>Homebrew<span class="hljs-regexp">/install/m</span>aster<span class="hljs-regexp">/install)"</span></code></pre><p data-source-line="75">然后通过 brew 命令，就可以安装绝大多数系统依赖的工具和应用了：</p>
<pre data-source-line="77"><code class="hljs"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>wget        <span class="hljs-comment"># 安装 wget 工具</span>
<span class="hljs-keyword">brew </span>cask <span class="hljs-keyword">install </span>wechat <span class="hljs-comment"># 安装微信</span></code></pre><h2 data-source-line="81" id="第-12-章-本书解决什么问题"><a class="markdownIt-Anchor" href="#第-12-章-本书解决什么问题"></a>第 1.2 章 本书解决什么问题</h2>
<p data-source-line="83">我希望通过这本书，介绍一些常见的，Mac 使用过程中容易遇到的痛点，不仅仅告诉读者如何解决，还介绍背后的原理，从而起到举一反三的作用。<strong>因为痛点永远解决不完，只有学会了解决方案和原理，才能根据自己的实际情况量身定制</strong>。</p>
<p data-source-line="85">一方面，Mac 系统虽然适合程序员，但毕竟不是为程序员量身定制的，还是要考虑所有用户的体验。因此作为程序员，我们可以通过配置，让 Mac 用起来更加得心应手，更适合写程序。</p>
<p data-source-line="87">另一方面，这么多年的演化过程中，很多先人前辈已经踩过了大量的坑，整理了很多最佳实践，也提供了大量的第三方工具可供选择。本书希望能把其中优秀的方案介绍给读者。</p>
<p data-source-line="89">我临时回忆了一些 Mac 使用过程中经常遇到的痛点，如果你发现这些问题和场景自己都没有了解，没有很高效的办法解决，本书一定非常值得一读。</p>
<pre data-source-line="91"><code class="hljs">不了解 Mac 上的包管理神器 Homebrew，或者每次换新电脑后都要重新配置一遍环境
HomeBrew 的源托管在官网，每次更新都慢如蜗牛
安装完 HomeBrew 以后，很多库还要手动安装一遍，无法自动同步
不知道（如何）配置 Tab 键切换系统的对话框选项，用空格键确认，每次用鼠标或触摸板点击比较慢
不知道（如何）配置触摸板的轻按点击，每次都重按触摸板很累
不知道（如何）配置三指拖动窗口，每次移动窗口位置都很慢
有些常见的软件，比如 SourceTree，Chrome，iTerm 等需要手动下载安装包
不知道如何在浏览器地址栏或任何其他输入框中，以单词为单位移动光标或删除单词
还在拖拽光标来选择一段内容，如果选中的内容有偏差，还得重新选择
不知道系统的预览程序可以被拓展，从而更快更好的预览更多类型的文件
还在各种邮件软件中切换，公司邮箱里的邮件特别多，无法快速分类整理
还在使用系统自带的终端，不了解神奇 iTerm2 的各种技巧
想在终端科学上网，解决 npm 等命令慢的问题
想要查看磁盘的剩余空间，每次都要点击屏幕左上角的苹果图标并选择存储那一列
想要查看某个目录下，所有子目录和文件的大小，以及它们的总大小，但不知道如何查看
记得以前复制过一段内容，想通过的搜索关键字的方式找回来
地址，手机号，身份证号，邮箱等常用信息总是一遍又一遍的输入
不了解能大幅度提高浏览器使用效率的插件，或者装了太多插件找不到想用的
想知道某个目录（或者子目录）中是否包含特定名称的文件，甚至想用正则去搜索
想知道当前的<span class="hljs-built_in"> ip </span>地址但每次点击 WiFi 图标又太麻烦
想知道或切换当前系统的代理但每次点击 WiFi 图标又太麻烦
不了解 Vim 的强大之处和神级插件
在诸多 IDE 中举棋不定，不知道什么是最佳实践
Git 还只会使用基本的 add/commit 命令
想快速查看本地、远程都有哪些分支
记得某次提交的 log 中有一些关键字，还搜出这次提交
记得某次提交的内容中有一些关键字，想搜出这次提交
想快速系统的隐藏文件或者隐藏他们
每次调用 ssh 命令都记不得端口、主机和密码
想知道某个文件夹内，是否有某个文件包含特定的字符串，系统的 Finder 搜索非常低效
想知道当前哪个软件最占用 CPU，内存和网速
每次去百度搜索 urlencode 或者 base64 解码，然后跳到站长之家
项目文件特别多，找到 .xcproj 文件特别费力，然后双击打开它
想知道某个进程占用了那些端口，或者某个端口被哪个进程占用
还需要在线的 JSON 美化、校验工具甚至是 GUI 版本的，每次格式化 JSON 都需要打开好几个网站，Chrome 一堆无用标签
只想看到命令行输出结果的前（后）几行（列）
有翻译（英译中或者中译英）的需求，但是不想单独装一个 App 或者每次都打开翻译网站</code></pre><h1 data-source-line="130" id="第-2-章-系统配置"><a class="markdownIt-Anchor" href="#第-2-章-系统配置"></a>第 2 章 系统配置</h1>
<p data-source-line="132">本章主要介绍对原生操作系统的配置和优化，基本不依赖其它第三方软件。</p>
<p data-source-line="134">第一节主要通过 <code>default writes</code>
命令来修改系统的配置，让键盘，触摸板等硬件用起来更加得心应手。以及一些常用的软件方面的优化。</p>
<p data-source-line="137">第二节介绍很简单，但是大部分人不知道的快捷键使用，比如 Option 键和 Ctrl 键的用法， 帮助读者快速移动光标和编辑文字。</p>
<p data-source-line="139">第三节介绍如何增强系统自带的预览程序的功能，支持更好的显示效果和更多文件格式。这样就可以在不打开文件的前提下快速浏览了。</p>
<p data-source-line="141">第四节主要介绍对 Dock 栏的优化方案，还读者一个干净整洁，而且不打扰人的工作环境</p>
<h2 data-source-line="144" id="第-21-章-系统配置优化"><a class="markdownIt-Anchor" href="#第-21-章-系统配置优化"></a>第 2.1 章 系统配置优化</h2>
<h3 data-source-line="145" id="大小写键和-ctrl-键交换"><a class="markdownIt-Anchor" href="#大小写键和-ctrl-键交换"></a>大小写键和 Ctrl 键交换</h3>
<p data-source-line="147">首先说两个我的主观看法，当然读者可以选择不接受，那样就不用浪费时间读下去了。如果你表示认可，并且希望解决这个问题，相信本文会帮到你。</p>
<p data-source-line="150"><strong>1. 用 Caps Lock（也就是大小写切换键）来切换大小写是非常低效的</strong>。以输入文字 aBc 为例，我们需要按下 Caps Lock 键进入大写模式，输入 B，再按一次键回到小写模式，输入 c。正确的做法是<strong>使用 shift 键</strong>，我们按住 shift 键输入 b 就会得到大写的字母，再松开就回到了小写模式。和 Caps Lock 键相比，少了一次按键。
<strong>2. 键盘上的 Ctrl 键位置很差</strong>，如果你是用标准的打字手势，你会发现这个键刚好在左手的手心，无论哪个手指都不方便去按它。而 Caps Lock 键则占据了左手小拇指左侧的黄金位置。更重要的是，Ctrl 键的用途非常广，无论是作为 Vim 或者 Emacs 的功能键，还是各种快捷键的修饰键，都是一个非常常用的按键，比如在下一章中就会介绍 Ctrl 键的妙用</p>
<p data-source-line="153">简单总结一下就是：</p>
<pre data-source-line="155"><code class="hljs">Caps <span class="hljs-keyword">Lock</span> 键效率低，自身毫无用处
Caps <span class="hljs-keyword">Lock</span> 键占据了黄金的位置
Ctrl 键用处多，使用频率高
Ctrl 键位置差，很不方便按</code></pre><p data-source-line="160">当这四个理由合在一起时，你很难否认，最好的做法就是：<strong>交换 Caps Lock 键和 Ctrl</strong> 键。实际上系统的键盘设置里面已经支持了这个操作，但本文会从命令行的角度来聊聊，这样可以方便我们<a href="https://github.com/bestswifter/macbootstrap" target="_blank">快速搭建 Mac 的工作环境</a>。</p>
<p data-source-line="162">踩了无数坑以后，终于发现了一个可用的脚本，原理啥的就不说了，因为基本上没有别的用途：</p>
<pre data-source-line="164"><code class="hljs">hidutil <span class="hljs-keyword">property</span><span class="hljs-title"> </span>--set '{<span class="hljs-string">"UserKeyMapping"</span>:[{<span class="hljs-string">"HIDKeyboardModifierMappingSrc"</span>:<span class="hljs-number">0</span>x700000039,<span class="hljs-string">"HIDKeyboardModifierMappingDst"</span>:<span class="hljs-number">0</span>x7000000E0},{<span class="hljs-string">"HIDKeyboardModifierMappingSrc"</span>:<span class="hljs-number">0</span>x7000000E0,<span class="hljs-string">"HIDKeyboardModifierMappingDst"</span>:<span class="hljs-number">0</span>x700000039}]}'</code></pre><p data-source-line="166">不过这个脚本有一个大坑，就是虽然立刻就会生效，但是重启后就失效了，所以我们需要在每次启动时都执行一次这个命令。</p>
<h3 data-source-line="167" id="添加开机任务"><a class="markdownIt-Anchor" href="#添加开机任务"></a>添加开机任务</h3>
<p data-source-line="169">很多程序的设置中都可以选择是否开机自动启动，其实除了启动 App，我们可以编写自己的 shell 脚本，并将它设置为启动时自动执行，这样就获得了更大的灵活性，可以完成任何自己想做的操作。</p>
<p data-source-line="171">首先我们需要一个配置文件，先给它随便去个名字，比如叫做 <code>com.bestswifter.onlogin.plist</code>
。内容如下所示，虽然很多，但绝大多数地方都是模板，我们只需要修改其中一处即可：</p>
<pre data-source-line="174"><code class="hljs"><span class="php"><span class="hljs-meta">&lt;?</span>xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span><span class="hljs-meta">?&gt;</span></span>
<span class="hljs-meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1.0"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>LaunchOnlyOnce<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>com.bestswifter.onlogin<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>ProgramArguments<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>zsh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>-c<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>"$HOME/.macbootstrap/onlogin.sh"<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>KeepAlive<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span></code></pre><p data-source-line="193">注意这里的几个键，<code>LaunchOnlyOnce</code>表示脚本只会执行一次，否则可能会每隔 10s 就执行一次。<code>Label</code>是自定义的名字，理论上来说随便写，不过我建议和文件名保持一致即可，一定不会出错。</p>
<p data-source-line="195"><code>array</code>标签里面就是自己要执行的命令了，前两行<code>zsh -c</code>不要动，表示用 <code>zsh</code> 来执行脚本，然后后面写脚本的路径。比如在这个例子里面我就把入口收敛到了自己的<code>onlogin.sh</code>里面，然后再执行任何事情就很方便了。</p>
<p data-source-line="197">对于普通用户来说，上述 plist 文件唯一需要修改的就是执行脚本的位置了。修改后后把这个文件拷贝到 <code>~/Library/LaunchAgents</code>目录下，表示仅对当前用户生效，然后执行：</p>
<pre data-source-line="199"><code class="hljs">sudo launchctl load ~/Library/LaunchAgents/com<span class="hljs-selector-class">.bestswifter</span><span class="hljs-selector-class">.onlogin</span><span class="hljs-selector-class">.plist</span></code></pre><p data-source-line="201">将这个文件注册到系统中。</p>
<h3 data-source-line="202" id="触摸板优化"><a class="markdownIt-Anchor" href="#触摸板优化"></a>触摸板优化</h3>
<p data-source-line="204">首先可以开启轻按点击功能，这样只要轻轻的触碰触摸板，不用真的按下去，就可以点击了，这样真的很轻松：</p>
<pre data-source-line="206"><code class="hljs">defaults write com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.AppleMultitouchTrackpad</span> Clicking -int <span class="hljs-number">1</span>
defaults -currentHost write NSGlobalDomain com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.mouse</span><span class="hljs-selector-class">.tapBehavior</span> -int <span class="hljs-number">1</span>
defaults write NSGlobalDomain com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.mouse</span><span class="hljs-selector-class">.tapBehavior</span> -int <span class="hljs-number">1</span></code></pre><p data-source-line="210">除此以外我们还可以开启三指拖拽功能，这样想移动窗口位置时，只要用三个手指即可拖拽，而不用先点击选中窗口，再拖拽：</p>
<pre data-source-line="212"><code class="hljs">defaults write com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.driver</span><span class="hljs-selector-class">.AppleBluetoothMultitouch</span><span class="hljs-selector-class">.trackpad</span> TrackpadThreeFingerDrag -bool true
defaults write com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.AppleMultitouchTrackpad</span> TrackpadThreeFingerDrag -bool true</code></pre><h3 data-source-line="215" id="用好-f1-f12"><a class="markdownIt-Anchor" href="#用好-f1-f12"></a>用好 F1-F12</h3>
<p data-source-line="217">默认情况下，键盘最上面一排的 F1- F12 都有各自的作用，从图标上就能看出。比如 F1 和 F2 用来调节屏幕亮度，F5 和 F6 调节键盘灯亮度灯。此时他们可以被理解为特殊按键，更偏向与娱乐，而不是普通的 F1 - F12。</p>
<p data-source-line="219">对于工作重心在编程的码农来说，这些特殊按键有些浪费，而很多 IDE 提供的快捷键都需要 F1 - F12，尤其在断点调试时格外有用，以 Xcode 为例说明下：</p>
<pre data-source-line="221"><code class="hljs"><span class="hljs-symbol">F6</span>：执行下一行代码
<span class="hljs-symbol">F7</span>：跳到代码内部执行，比如当前停在一个函数上，<span class="hljs-built_in">F6</span> 会直接执行这个函数，<span class="hljs-built_in">F7</span> 会跳到函数内部的第一行去执行
<span class="hljs-symbol">F8</span>：跳出当前代码块，和 <span class="hljs-built_in">F7</span> 的作用恰好相反</code></pre><p data-source-line="225">这里的 F6 是标准按键，需要我们同时按下键盘左下角的 fn 键和顶部的 F6 键才能触发，效率极其低下。然而，作为程序员，我们并不太需要那些花哨的娱乐功能，因此我建议在设置中把 F1 - F12 改为标准按键，如下图所示：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F809cf9841277c022863b298f629418c0.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/809cf9841277c022863b298f629418c0.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F809cf9841277c022863b298f629418c0.png">
或者更高效的做法是使用命令行：</p>
<pre data-source-line="229"><code class="hljs">defaults write -globalDomain com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.keyboard</span><span class="hljs-selector-class">.fnState</span> -int <span class="hljs-number">1</span></code></pre><p data-source-line="231"><strong>关闭第三方程序验证</strong></p>
<p data-source-line="233">有时候，或许是囊中羞涩，或许是国外厂商定价不合理，我们或多或少会下载某些破解版的应用，此时直接打开很可能被系统拒绝，或者报错：无法打开已损坏的安装包。我们可以通过命令行关闭这一保（限）护（制）：</p>
<pre data-source-line="235"><code class="hljs">sudo spctl <span class="hljs-comment">--master-disable</span>
defaults <span class="hljs-built_in">write</span> com.apple.LaunchServices LSQuarantine -bool <span class="hljs-literal">false</span></code></pre><p data-source-line="238"><strong>关闭镜像验证</strong></p>
<p data-source-line="240">在打开 .dmg 格式的安装文件时，默认会先验证镜像，如果文件本身很大，验证的时间会很长，可以输入以下命令关闭验证：</p>
<pre data-source-line="242"><code class="hljs">defaults write com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.frameworks</span><span class="hljs-selector-class">.diskimages</span> skip-verify -bool true
defaults write com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.frameworks</span><span class="hljs-selector-class">.diskimages</span> skip-verify-locked -bool true
defaults write com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.frameworks</span><span class="hljs-selector-class">.diskimages</span> skip-verify-remote -bool true</code></pre><p data-source-line="246"><strong>完全键盘控制</strong></p>
<p data-source-line="248">很多操作都会弹出系统的对话框，要求我们确认或者取消
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F313c81547567a781cbe02a5d5662bd4a.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/313c81547567a781cbe02a5d5662bd4a.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F313c81547567a781cbe02a5d5662bd4a.png">
如果没有开启<strong>完全键盘控制</strong>，我们只能按回车键确认，或者移动鼠标选择取消。如果开启了完全键盘控制，只要<strong>按下空格键</strong>，就相当于选中蓝色边框的按钮，也就是这里的取消键。按下 <strong>Tab 键</strong>可以在多个按钮之间切换。</p>
<p data-source-line="252">完全键盘控制可以在系统的设置界面开启，也可以直接通过命令行开启：</p>
<pre data-source-line="254"><code class="hljs">defaults <span class="hljs-built_in">write</span> NSGlobalDomain AppleKeyboardUIMode -<span class="hljs-keyword">int</span> <span class="hljs-number">3</span></code></pre><h2 data-source-line="257" id="第-22-章-系统快捷键进阶"><a class="markdownIt-Anchor" href="#第-22-章-系统快捷键进阶"></a>第 2.2 章 系统快捷键进阶</h2>
<p data-source-line="259">除了 Command + C/V 这种入门必备的快捷键，还有一些系统级的常用快捷键是有必要掌握一下的。</p>
<h3 data-source-line="260" id="光标移动"><a class="markdownIt-Anchor" href="#光标移动"></a>光标移动</h3>
<p data-source-line="262">这里比较推荐使用 Emacs 系的快捷键而不是传统的 Command + ←/→/Delete之类的。因为后者并不通用，比如在终端中就无法使用，而 Emacs 系的快捷键则在几乎所有系统级别的输入框内都通用。</p>
<p data-source-line="264">常见的几个行级别操作有：</p>
<pre data-source-line="266"><code class="hljs">Ctrl + A：移动到行首
Ctrl + <span class="hljs-keyword">E</span>：移动到行尾
Ctrl + <span class="hljs-keyword">K</span>：删除到行尾
Ctrl + <span class="hljs-keyword">N</span>：移动到下一行
Ctrl + P：移动到上一行</code></pre><p data-source-line="272">前三个命令在终端中非常常用，能大幅度提高工作效率。后两个命令则在 Vim 系列中很常见，多用于上下切换列表中的选项。</p>
<p data-source-line="274">几个比较常见的字母级别操作有：</p>
<pre data-source-line="276"><code class="hljs">Ctrl + F：向右（<span class="hljs-keyword">Forward</span>）移动一个字母，等价于方向键 →
Ctrl + B：向左（<span class="hljs-keyword">Backward</span>）移动一个字母，等价于方向键 ←
Ctrl + <span class="hljs-keyword">D</span>：向右删除一个字母，等价于 → + <span class="hljs-keyword">Delete</span>这个快捷键也很常用
Ctrl + H：向左删除一个字母，等价于 <span class="hljs-keyword">Delete</span></code></pre><h3 data-source-line="281" id="使用-option-键"><a class="markdownIt-Anchor" href="#使用-option-键"></a>使用 Option 键</h3>
<p data-source-line="283">如果觉得按字母操作太过于细粒度，按行操作又太粗粒度，那么 Option 键绝对算得上神器，因为它可以<strong>按单词操作。</strong></p>
<pre data-source-line="285"><code class="hljs"><span class="hljs-keyword">Option</span> + ←：光标向左移动一个单词
<span class="hljs-keyword">Option</span> + →：光标向右移动一个单词
<span class="hljs-keyword">Option</span> + Delete：删除一个单词</code></pre><h3 data-source-line="289" id="使用-shift-键"><a class="markdownIt-Anchor" href="#使用-shift-键"></a>使用 Shift 键</h3>
<p data-source-line="291">Shift 键类似于可视模式，比如在某个位置点击光标并按<strong>住 shift 键不松开</strong>，再去另一个位置点击一次，就可以选中两次点击位置之间的文本内容。</p>
<p data-source-line="293">注意，shift 键可视模式还可以和 Option 键一起合用，感兴趣的读者可以自行尝试。</p>
<h2 data-source-line="296" id="第-23-章-拓展预览程序"><a class="markdownIt-Anchor" href="#第-23-章-拓展预览程序"></a>第 2.3 章 拓展预览程序</h2>
<p data-source-line="298">对于一些文本文件，按下空格键就可以调用系统的<strong>预览</strong>程序，快速浏览文件内容。但如果想<strong>获得更好的阅读体验</strong>，或<strong>支持更多类型文件的快速浏览</strong>，就需要通过插件来完成。</p>
<p data-source-line="300">可以输入以下命令来安装拓展，下面会逐个介绍：</p>
<pre data-source-line="302"><code class="hljs"><span class="hljs-keyword">brew </span>cask <span class="hljs-keyword">install </span>qlcolorcode qlstephen qlmarkdown quicklook-<span class="hljs-keyword">json </span>qlimagesize webpquicklook qlvideo provisionql quicklookapk</code></pre><h3 data-source-line="304" id="qlcolorcode"><a class="markdownIt-Anchor" href="#qlcolorcode"></a>qlcolorcode</h3>
<p data-source-line="306">顾名思义，这是一个代码高亮的插件，效果如图所示：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F7d2b6dc9c86b3ad20e23f9fa6674a110.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/7d2b6dc9c86b3ad20e23f9fa6674a110.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F7d2b6dc9c86b3ad20e23f9fa6674a110.png"></p>
<h3 data-source-line="309" id="qlstephen"><a class="markdownIt-Anchor" href="#qlstephen"></a>qlstephen</h3>
<p data-source-line="311">这个插件能让我们预览没有后缀的文本文件，效果如图所示：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F956b4de9a51411db871c113ac3df20c4.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/956b4de9a51411db871c113ac3df20c4.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F956b4de9a51411db871c113ac3df20c4.png"></p>
<h3 data-source-line="313" id="qlmarkdown"><a class="markdownIt-Anchor" href="#qlmarkdown"></a>qlmarkdown</h3>
<p data-source-line="315">这个插件能让我们预览 markdown 文件的渲染效果:
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F298101903dfb7986b5bdf05b185f8660.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/298101903dfb7986b5bdf05b185f8660.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F298101903dfb7986b5bdf05b185f8660.png"></p>
<h3 data-source-line="317" id="quicklook-json"><a class="markdownIt-Anchor" href="#quicklook-json"></a>quicklook-json</h3>
<p data-source-line="319">这个插件也很容易理解，提供对 JSON 文件的格式化和高亮支持：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F04cd6b1c0c12704944593b4fd2ecbc28.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/04cd6b1c0c12704944593b4fd2ecbc28.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F04cd6b1c0c12704944593b4fd2ecbc28.png"></p>
<h3 data-source-line="321" id="betterzip"><a class="markdownIt-Anchor" href="#betterzip"></a>betterzip</h3>
<p data-source-line="323">这个插件我没有安装，因为它需要付费，它可以预览压缩文件内部的内容，还支持自定义各种解压缩时的行为（比如解压缩后自动删除压缩包）。下图是安装前的压缩文件预览图：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F1161b1d391ffecd8c2275eb7b384162d.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/1161b1d391ffecd8c2275eb7b384162d.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F1161b1d391ffecd8c2275eb7b384162d.png">
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F6770c00f1b6f150f54979461f79803e8.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/6770c00f1b6f150f54979461f79803e8.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F6770c00f1b6f150f54979461f79803e8.png"></p>
<h3 data-source-line="326" id="qlimagesize"><a class="markdownIt-Anchor" href="#qlimagesize"></a>qlimagesize</h3>
<p data-source-line="328">这个拓展可以展示图片的分辨率和大小：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fa0753aa5fed15d7d9fb2eb31b7bd5191.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/a0753aa5fed15d7d9fb2eb31b7bd5191.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fa0753aa5fed15d7d9fb2eb31b7bd5191.png"></p>
<h3 data-source-line="330" id="webpquicklook"><a class="markdownIt-Anchor" href="#webpquicklook"></a>webpquicklook</h3>
<p data-source-line="332">这个拓展可以让我们预览 WebP 格式的图片：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F4e2e4692e21ac746e0c8ddc9bdbe4822.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/4e2e4692e21ac746e0c8ddc9bdbe4822.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F4e2e4692e21ac746e0c8ddc9bdbe4822.png"></p>
<h3 data-source-line="334" id="qlvideo"><a class="markdownIt-Anchor" href="#qlvideo"></a>qlvideo</h3>
<p data-source-line="336">预览更多格式的视频文件：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F782ccc4bc41cb4e64a8d9a438f4728f2.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/782ccc4bc41cb4e64a8d9a438f4728f2.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F782ccc4bc41cb4e64a8d9a438f4728f2.png"></p>
<h3 data-source-line="338" id="provisionql"><a class="markdownIt-Anchor" href="#provisionql"></a>provisionql</h3>
<p data-source-line="340">这个插件可以预览 .app 或者 .ipa 后缀的程序：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F4ae736f3a13b7801e1fed47b077c80af.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/4ae736f3a13b7801e1fed47b077c80af.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F4ae736f3a13b7801e1fed47b077c80af.png"></p>
<h3 data-source-line="342" id="quicklookapk"><a class="markdownIt-Anchor" href="#quicklookapk"></a>quicklookapk</h3>
<p data-source-line="344">预览安卓的 .apk文件：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd304d308c143d9f180402302458dc217.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/d304d308c143d9f180402302458dc217.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd304d308c143d9f180402302458dc217.png">
以上就是和程序员相关的常用插件，还有一些设计师可能用到的插件，可以访问<a href="https://github.com/sindresorhus/quick-look-plugins" target="_blank">这个网址</a>自行查看。</p>
<h2 data-source-line="349" id="第-24-章-dock-栏优化"><a class="markdownIt-Anchor" href="#第-24-章-dock-栏优化"></a>第 2.4 章 Dock 栏优化</h2>
<h3 data-source-line="350" id="自动隐藏-dock"><a class="markdownIt-Anchor" href="#自动隐藏-dock"></a>自动隐藏 Dock</h3>
<p data-source-line="352">我们知道 Dock 默认位于屏幕底部，而且屏幕本身是 16 : 9 的，这就导致屏幕的可视部分更加扁平。所以我的习惯是把它放在屏幕左侧（右侧也是同理），这样会使屏幕的宽高比更加自然一些。</p>
<p data-source-line="354">长期展示 Dock 对并不大的屏幕空间来说是一种浪费，我们可以把它设置为自动隐藏，当鼠标滑过去以后再显示：</p>
<pre data-source-line="356"><code class="hljs">defaults write com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.dock</span> autohide -bool true</code></pre><p data-source-line="358">在后面的章节中我会介绍如何快速唤起应用，所以大多数时候 Dock 栏其实是没用的，大可不必担心看不到 Dock 栏。</p>
<h3 data-source-line="359" id="定制你的-dock"><a class="markdownIt-Anchor" href="#定制你的-dock"></a>定制你的 Dock</h3>
<p data-source-line="361">同时，系统默认会添加很多程序在 Dock 中，很多程序基本上用不到（比如地图、通讯录等等），我的做法是先把它们都移除出去，对于常用的程序，再保留在 Dock 中。</p>
<p data-source-line="363">为了完成上述目的，命令行看起来就不太够了，我们可以直接用 OC 来编辑对应的 plist 文件来达到目的，代码比较冗长，感兴趣的读者可以去 我的 MacBootstrap 上查看。</p>
<p data-source-line="365">然后用 clang 编译源码并执行：</p>
<pre data-source-line="367"><code class="hljs">clang -framework Foundation path-<span class="hljs-keyword">to</span>-<span class="hljs-built_in">file</span>.m -o DockIconHider
./DockIconHider</code></pre><h1 data-source-line="371" id="第-3-章-mac-工作流"><a class="markdownIt-Anchor" href="#第-3-章-mac-工作流"></a>第 3 章 Mac 工作流</h1>
<p data-source-line="373">本章主要介绍各种好用的工具来进一步提升 Mac 的使用效率。</p>
<p data-source-line="375">第一节会介绍系统自带的邮件应用，通过添加各种规则，实现邮件的过滤与分类，让自己的邮箱更加整洁。</p>
<p data-source-line="377">第二节会介绍系统终端应用的替代品：iTerm2。虽然它并没有什么值得单独拿出来大说特说的优点，但在使用过程中就会感受到这款软件的强大之处，似乎每个细节上都比原生的终端更加优秀一点。绝对是必装应用之一。</p>
<p data-source-line="379">第三节主要介绍 SSH 的配置管理。有多台远程设备的同学一定有过记不住 ip 地址，密码和端口的尴尬经历，本节会介绍管理这些设备的最佳实践。</p>
<p data-source-line="381">第四到六节是一个正常程序员必备的，科学上网的知识，也是最容易在各个群里被问到的问题之一。我会分别从原理，Mac 上的最佳实践和移动端最佳实践三个方向来介绍。</p>
<p data-source-line="383">第七、八节则是 Alfred 从入门到进阶，会介绍软件自身的功能，以及优秀的第三方插件，还会教大家如何自己写一个简单的插件。</p>
<p data-source-line="385">最后一节则是 Chrome 的插件介绍和管理，这些插件能帮助我们的浏览器变得更加强大易用。</p>
<h2 data-source-line="388" id="第-31-章-邮件规则"><a class="markdownIt-Anchor" href="#第-31-章-邮件规则"></a>第 3.1 章 邮件规则</h2>
<p data-source-line="390">无论是公司邮箱还是个人邮箱，经常会收到具备某些固定特征的邮件。比如银行信用卡的邮件，某个网站订阅后的邮件，或者公司内特定部门、发件人的邮件等等。</p>
<p data-source-line="392">对于这类具备固定特征的邮件，我们可以利用系统自带的邮件应用，给他们添加分类、过滤规则。</p>
<p data-source-line="394">以个人邮箱为例，<strong>假设我想整理所有谷歌账号相关的通知邮件</strong>，首先在邮箱列表找到它，然后点击右侧的加号，添加某个子文件夹：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F6fb6b70b210c0415ffc81704d3058c19.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/6fb6b70b210c0415ffc81704d3058c19.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F6fb6b70b210c0415ffc81704d3058c19.png"></p>
<p data-source-line="397">然后输入子文件夹的名字：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fef05a76d60bb2ffec956ff383dbb64a0.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/ef05a76d60bb2ffec956ff383dbb64a0.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fef05a76d60bb2ffec956ff383dbb64a0.png">
接下来在邮件列表中选中来<strong>自谷歌的账号提醒邮件</strong>，按下 <code>Command +</code> , 打开邮件设置，找到最后一列的规则，选择添加规则。注意：也可以不选中邮件直接<strong>添加规则</strong>，这样的缺点是不能识别邮件的特征，需要自己手动填写。</p>
<p data-source-line="401">点击添加规则：
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F7719cda0883570da387b1fdaa0cfbf02.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/7719cda0883570da387b1fdaa0cfbf02.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F7719cda0883570da387b1fdaa0cfbf02.png">
首先填写规则描述，这个只要能让自己以后看得懂即可。可以给规则添加多个条件，并且指定同时满足或满足任一条件。</p>
<p data-source-line="405">每个条件可以在邮件的发件人、主题、收件人等各种特征之间选择，如果当初选中了邮件再打开规则列表，就会自动那条邮件的特征，否则只有自行填写了。</p>
<p data-source-line="407">最后的操作可以有多个，比如先标记为已读/星标再移动到刚刚创建的子文件夹下，或者对于公司里特别烦人的全员邮件，可以直接删除。</p>
<p data-source-line="409">最后点击确定，然后应用到所有邮件即可。</p>
<h2 data-source-line="412" id="第-32-章-终端神器-iterm2"><a class="markdownIt-Anchor" href="#第-32-章-终端神器-iterm2"></a>第 3.2 章 终端神器 iTerm2</h2>
<p data-source-line="414">iTerm2 是一个用来取代系统终端的命令行工具，功能比原生的终端程序强大很多，可以一行命令安装：</p>
<pre data-source-line="416"><code class="hljs"><span class="hljs-keyword">brew </span>cask <span class="hljs-keyword">install </span>iterm2</code></pre><h3 data-source-line="418" id="光标移动-2"><a class="markdownIt-Anchor" href="#光标移动-2"></a>光标移动</h3>
<p data-source-line="420">上一章 系统快捷键进阶 一节中曾经介绍过光标移动的快捷键，其中以 Ctrl 键开头的快捷键依然可用，比如移动到行首、行尾，向左/右移动或删除字符等等。</p>
<p data-source-line="422">但在 iTerm2 中无法使用 Option 键进行单词跳转，因此需要自行配置快捷键，我选择用 Command + ← 来表示光标向左移动一个单词。对应的，向右移动一个单词就是 Command + →。打开设置，添加这两个快捷键：</p>
<p data-source-line="424"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fc9f68eeeb9d2f9feeb3e90ed6041048a.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/c9f68eeeb9d2f9feeb3e90ed6041048a.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fc9f68eeeb9d2f9feeb3e90ed6041048a.png"></p>
<h3 data-source-line="425" id="选择文本"><a class="markdownIt-Anchor" href="#选择文本"></a>选择文本</h3>
<p data-source-line="427">iTerm2 中选择文本有三种方式，分别是：</p>
<pre data-source-line="429"><code class="hljs">双击：选中单词
三击：选中整行
四击：智能选择</code></pre><p data-source-line="433">智能选择是一个比较有意思的功能，完整的介绍可以参考官方文档。对于我来说，以下几种情况下用智能选择是非常棒的：</p>
<pre data-source-line="435"><code class="hljs">代码片段，比如智能选择会自动选中 namespace::identifier以及 foo<span class="hljs-selector-class">.bar</span><span class="hljs-selector-class">.baz</span> 这种语法
双引号内的字符，比如 <span class="hljs-string">"this is a quoted string"</span>
电子邮件，智能选择会选中整个邮件地址
完整的 URL，智能选择会选中 scheme</code></pre><p data-source-line="440">另外，iTerm2 默认选中即复制，所以不用额外的 Command + C 这一步了。</p>
<h3 data-source-line="441" id="command-键"><a class="markdownIt-Anchor" href="#command-键"></a>Command 键</h3>
<p data-source-line="443">Command 主要用来打开文件或者 URL。对于输出到终端的文件名或者 URL，我们可以按住 Command 键点击它，就可以直接打开了。</p>
<p data-source-line="445">此外，按下 Command + Option 还可以选中矩形范围内的文本。</p>
<h3 data-source-line="446" id="tab-和-pane"><a class="markdownIt-Anchor" href="#tab-和-pane"></a>Tab 和 Pane</h3>
<p data-source-line="448">按下 Command + T 可以新建一个 Tab，每个标签页的后面都会标记一个序号，通过 Command + 序号 就可以在多个页面之间切换了，或者用 Command + [ 和 Command + ] 来切换到左侧或者右侧的标签页。</p>
<p data-source-line="450">同一个 Tab 内，还可以切分出多个 Pane，有两种切分方式：</p>
<pre data-source-line="452"><code class="hljs">Command + <span class="hljs-keyword">D</span>：水平切分，切分出一左一右两个 <span class="hljs-keyword">Pane</span>
Command + Shift + <span class="hljs-keyword">D</span>：垂直切分，切分出一上一下两个 <span class="hljs-keyword">Pane</span></code></pre><p data-source-line="455">通过 Command + Ctrl + 方向键 可以调整每个 Pane 的大小，通过 Command + Option + 方向键 可以切换 Pane。</p>
<h3 data-source-line="456" id="快速编辑"><a class="markdownIt-Anchor" href="#快速编辑"></a>快速编辑</h3>
<p data-source-line="458">有时候，如果上一条命令出现了某个小错误，其实不必重新打一遍，可以使用 <sup>old</sup>new 的写法进行替换，它表示把原来命令中匹配 old 的部分替换成 new，如下图所示：</p>
<p data-source-line="460"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDvQXj1FAD-kiaMg-4g%252F-LDvQiDgnia_CPL_Dr4H%252Fiterm-edit.gif%3Falt%3Dmedia%26token%3Da5fdece9-287b-46ef-bf18-5c2ac1d395ca" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDvQXj1FAD-kiaMg-4g%2F-LDvQiDgnia_CPL_Dr4H%2Fiterm-edit.gif?alt=media&amp;token=a5fdece9-287b-46ef-bf18-5c2ac1d395ca&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDvQXj1FAD-kiaMg-4g%252F-LDvQiDgnia_CPL_Dr4H%252Fiterm-edit.gif%3Falt%3Dmedia%26token%3Da5fdece9-287b-46ef-bf18-5c2ac1d395ca"></p>
<p data-source-line="462">对于特别长的命令，可以使用 zsh 提供的快捷键 Ctrl-x + Ctrl-e 进入 vim 编辑：</p>
<p data-source-line="464"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDvQXj1FAD-kiaMg-4g%252F-LDvQjoj8MWI4S_5beyR%252Fiterm-vim.gif%3Falt%3Dmedia%26token%3D1079c090-1067-43e3-b5f0-8203cec1abc7" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDvQXj1FAD-kiaMg-4g%2F-LDvQjoj8MWI4S_5beyR%2Fiterm-vim.gif?alt=media&amp;token=1079c090-1067-43e3-b5f0-8203cec1abc7&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDvQXj1FAD-kiaMg-4g%252F-LDvQjoj8MWI4S_5beyR%252Fiterm-vim.gif%3Falt%3Dmedia%26token%3D1079c090-1067-43e3-b5f0-8203cec1abc7"></p>
<h3 data-source-line="466" id="背景图"><a class="markdownIt-Anchor" href="#背景图"></a>背景图</h3>
<p data-source-line="468">打开设置，选择背景图案并设置好透明度：</p>
<p data-source-line="470"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F4b99027e775e0ead00c72f997b050fa5.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/4b99027e775e0ead00c72f997b050fa5.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F4b99027e775e0ead00c72f997b050fa5.png"></p>
<p data-source-line="472">最终效果图如下：</p>
<p data-source-line="474"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F44595bdab20ba823b193999a28d3ee66.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/44595bdab20ba823b193999a28d3ee66.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F44595bdab20ba823b193999a28d3ee66.png"></p>
<h2 data-source-line="477" id="第-33-章-ssh-的配置与管理"><a class="markdownIt-Anchor" href="#第-33-章-ssh-的配置与管理"></a>第 3.3 章 SSH 的配置与管理</h2>
<p data-source-line="479">SSH 是 Secure Shell 的缩写，其实就是远程 Shell 登陆。只要能远程登录到某台机器的 Shell 上，大到 Mac 笔记本，小到树莓派和智能路由器，我们就可以上传或下载文件、执行脚本等等，几乎掌握了设备的控制权。</p>
<p data-source-line="481">一般来说，如果想配置自己的云服务器或者树莓派，都需要通过 SSH 登陆。登陆时一般需要指定地址和用户名，比如我们想登陆 IP 地址为 1.2.3.4 的主机上的 root 用户，需要这样写：</p>
<pre data-source-line="483"><code class="hljs"><span class="hljs-selector-tag">ssh</span> <span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">1</span>.<span class="hljs-keyword">2</span>.<span class="hljs-keyword">3</span>.<span class="hljs-keyword">4</span></code></pre><p data-source-line="485">默认的 SSH 协议端口号是 22，所以无需填写，但有些设备为了安全起见，会更改 SSH 的端口号，比如改成 54321，我们就需要这样写：</p>
<pre data-source-line="487"><code class="hljs"><span class="hljs-selector-tag">ssh</span> <span class="hljs-selector-tag">-p</span> 54321 <span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">1</span>.<span class="hljs-keyword">2</span>.<span class="hljs-keyword">3</span>.<span class="hljs-keyword">4</span></code></pre><p data-source-line="489">接下来写上 root 账户的密码就可以登录了。</p>
<h3 data-source-line="490" id="免密登陆"><a class="markdownIt-Anchor" href="#免密登陆"></a>免密登陆</h3>
<p data-source-line="492">记忆密码是一件很麻烦的事，好在 SSH 支持利用 RSA 的公钥和私钥体系来验证身份。执行以下命令：</p>
<pre data-source-line="494"><code class="hljs">brew install ssh-<span class="hljs-keyword">copy</span><span class="bash">-id
</span>ssh-<span class="hljs-keyword">copy</span><span class="bash">-id root@1.2.3.4
</span><span class="hljs-comment"># 等价于下面这个命令，省掉了两个默认参数</span>
<span class="hljs-comment"># ssh-copy-id -i ~/.ssh/id_rsa.pub root@100.100.100.100 -p 22</span></code></pre><p data-source-line="499">这里我们利用了 ssh-copy-id 这个工具，它的原理其实是把自己的公钥（默认使用 <code>~/.ssh/id_rsa.pub</code> 这个文件中的内容）复制到目标服务器的 <code>~/.ssh/authorized_keys</code> 文件内。所以完全可以手动完成，不过用工具来实现的话，速度快，而且可以自动设置文件权限。</p>
<h3 data-source-line="500" id="别名"><a class="markdownIt-Anchor" href="#别名"></a>别名</h3>
<p data-source-line="502">即使配置了免密登陆，但用户名、IP 地址和端口号还是不想记忆，此时可以利用 SSH 的配置文件来实现。</p>
<p data-source-line="504">编辑<code>~/.ssh/config</code> 文件，添加以下内容：</p>
<pre data-source-line="506"><code class="hljs">Host testhost
    HostName 1.2.3.4
   <span class="hljs-built_in"> User </span>root
   <span class="hljs-built_in"> Port </span>54321
    IdentityFile ~/.ssh/id_rsa</code></pre><p data-source-line="512">这个配置文件还是很容易理解的，我们给地址为 1.2.3.4，端口为 54321，用户名为 root 的远程主机起了一个别名，然后就可以这样连接了：</p>
<pre data-source-line="514"><code class="hljs"><span class="hljs-attribute">ssh testhost</span></code></pre><p data-source-line="516">再也不用担心自己记不住那么多远程主机了，更神奇的是，iTerm2 还支持自动补全：</p>
<h3 data-source-line="518" id="全局-ssh-配置"><a class="markdownIt-Anchor" href="#全局-ssh-配置"></a>全局 SSH 配置</h3>
<p data-source-line="520">ssh 还可以添加一些全局配置，让它变得更好用，我的配置如下：</p>
<pre data-source-line="522"><code class="hljs"><span class="hljs-string">Host</span> <span class="hljs-string">*</span>
    <span class="hljs-string">ForwardAgent</span> <span class="hljs-literal">yes</span>
    <span class="hljs-string">ServerAliveInterval</span> <span class="hljs-number">10</span>
    <span class="hljs-string">ServerAliveCountMax</span> <span class="hljs-number">10000</span>
    <span class="hljs-string">TCPKeepAlive</span> <span class="hljs-literal">no</span>
    <span class="hljs-string">ControlMaster</span> <span class="hljs-string">auto</span>
    <span class="hljs-string">ControlPath</span> <span class="hljs-string">~/.ssh/%h-%p-%r</span>
    <span class="hljs-string">ControlPersist</span> <span class="hljs-number">4</span><span class="hljs-string">h</span>
    <span class="hljs-string">Compression</span> <span class="hljs-literal">yes</span></code></pre><p data-source-line="532">逐个解释下：</p>
<pre data-source-line="534"><code class="hljs">ForwardAgent：假设我通过 SSH 连接上了服务器 A（通常在公司内部有跳板机时格外有用），又从服务器 A 连接到服务器 B，如果将 ForwardAgent 配置为 YES，在两台服务器之间传输数据就不会经过本机。
ServerAliveInterval 和 ServerAliveCountMax：表示客户端定期向服务端发送心跳包，使得服务端不会断开 SSH 的连接。这里表示 <span class="hljs-number">10</span> 秒发一次，发 <span class="hljs-number">1</span>W 次。
Contro***：每次建立远程连接，在 ~/.ssh 目录下都会建立一个 socket 文件。这三个配置连用，表示缓存 socket 文件，并保留 <span class="hljs-number">4</span> 小时，这样可以加快下次连接的速度。</code></pre><h2 data-source-line="540" id="第-34-章-vpn-与-shadowsocks-科普扫盲"><a class="markdownIt-Anchor" href="#第-34-章-vpn-与-shadowsocks-科普扫盲"></a>第 3.4 章 VPN 与 shadowsocks 科普扫盲</h2>
<p data-source-line="542">很多人一提到 VPN 和 Shadowsocks，只是大概知道它们可以爱国上网，对于背后的原理并不太了解。本文也不会讲太多底层协议，主要是概述一下两者的区别，以及相关名词。</p>
<p data-source-line="544">首先说结论，如果你租了一台境外的主机，<strong>能用 Shadowsocks 就绝对不要用 VPN</strong>，当然直接选购爱国上网的软件时也是如此，因为 VPN 不方便配置规则，也更容易被封。</p>
<p data-source-line="546">所谓的配置规则是指，使用 Shadowsocks 时可以配置一个规则列表，只有满足规则的特定网址才走代理，对于百度/淘宝等一系列国内网站则直接连接。这样可以节省流量，加快访问速度，对用户完全透明。为什么 Shadowsocks 可以配置规则，VPN 就无法配置呢？带着这样问题，本文简单解释一下。</p>
<p data-source-line="548">首先 VPN 的含义是指虚拟专用网络，一般来说如果我们在公网，需要访问企业内网，就需要一个 VPN 服务器做代理，所有指向企业内网的请求都由这台 VPN 服务器负责代理转发，<strong>这样无需我们的电脑能访问内网，只要 VPN 服务器可以访问内网即可</strong>。如果把这里的内网换成境外网站，就是 VPN 能用于爱国上网的原理。</p>
<p data-source-line="550">VPN 只是一个概念，它的本意是建立虚拟私有网络，它可以通过多种协议来实现，比如 L2TP 协议或者 IPSec 协议，但在爱国上网范畴内，这些协议则是扮演了代理的作用。至于另一个很有名的协议，socks 协议（没错，就是 Shadowsocks 最后的 socks，因为是先有 socks 协议才有 Shadowsocks）则是一个标准的代理协议，它和前两者的区别在于，它是一个传输层的协议，能够利用 TCP/IP 协议。而 L2TP 和 IPSec 协议则是非常底层的协议，前者在数据链路层，后者在 IP 层。</p>
<p data-source-line="552">接下来聊聊 Shadowsocks 协议，从它的名字就能看出来它是基于 socks 协议实现的，这里盗用<a href="http://www.desgard.com/Shadowsocks-1/" target="_blank">冬瓜大神博客</a>里的一张图来简单说明 Shadowsocks 协议的工作原理：</p>
<p data-source-line="554"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fb20d2b9ddb2487389b5c33ad4ee046c1.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/b20d2b9ddb2487389b5c33ad4ee046c1.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fb20d2b9ddb2487389b5c33ad4ee046c1.png">
当我们在本地打开 GoAgentX 等应用时，实际上是启动了一个名为 sslocal 的本地进程，左侧绿色的 Socks5 Client 可以是浏览器，也可以是 git 或者 curl 命令等，它们之间的传输通过 socks 协议实现。sslocal 是一个实现了 socks 协议的代理服务器，并对标准 socks 协议做了一些改造：当 sslocal 进程获取请求后，它会将请求加密，发送到 ssserver 上，这样就不会被防火墙识别。ssserver 拿到数据后会解密，发送原始请求到目的地址，再将请求结果加密返回。</p>
<p data-source-line="557">因此，整个 Shadowsocks 方案由 socks 代理 加上 sslocal 到 ssserver 加密通信 以及 ssserver 还原请求这三部分组成。注意 Shadowsocks 是没有配置规则这个概念的，它对于 Client 来说是透明的，只要 Client 选择了使用 socks 代理，并把地址指向本地的 sslocal 进程，就会走到 Shadowsocks 的这套流程（当然 Client 还是以为自己只用了 socks 协议）。</p>
<p data-source-line="559">我们平时接触到的带规则配置一般只有两种场景，一个是系统的 PAC 文件，另一类则是 Chrome 之类的 App。</p>
<p data-source-line="561">先说说 PAC 文件，它的全名叫 <strong>Proxy Auto Config</strong>，是一个系统级别的代理规则配置表，本质上就是一段用 JavaScript 写成的脚本，脚本中会列出一堆网址，并且指定这些网址的请求方式，比如：</p>
<pre data-source-line="563"><code class="hljs">var<span class="hljs-built_in"> proxy </span>= <span class="hljs-string">"SOCKS5 127.0.0.1:1080; DIRECT;"</span>;</code></pre><p data-source-line="565">这里的 proxy 就表示先尝试用 SOCKS5 协议代理到 127.0.0.1:1080，不行再直接连接。一旦给系统配置了 PAC 文件，对于<strong>任意网络请求</strong>，系统都会调用 PAC 里的脚本，得到它的请求方式。</p>
<p data-source-line="567">Chrome 之类的浏览器也是类似的原理，通过插件来判断请求的地址，然后选择代理方式。</p>
<p data-source-line="569">再次强调，Shadowsocks <strong>并不存在配置规则的概念</strong>，它只是一种对应用层透明，但进行过改造的 socks 协议，只有操作系统或应用程序能够支持配置规则，其实就是自行选择是否使用 socks 代理。</p>
<p data-source-line="571">那么按照这个分析，理论上讲 VPN 也是可以配置的，只要应用程序可以选择是否使用 L2TP/IPSec 之类的协议就行了。然而，前文已经说过，这类协议非常底层，以 IPSec 为例，如果想用它，就得自己实现传输层的协议（TCP 或者 UDP），这个难度难如登天。在一个操作系统中，TCP/UDP 协议的实现都是系统自带的，因此对于运行在更底层的 L2TP/IPSec 这类协议而言，只有操作系统会提供默认实现，没有任何一个 App 会提供对它的支持。</p>
<p data-source-line="573">打开网络设置我们就会看到，VPN 是独立于 Wi-Fi/有线连接的另外一种连接方式，而 socks 代理仅仅是诸多代理方式的一种。</p>
<p data-source-line="575">希望通过本文，读者能了解 VPN、Shadowsocks、socks 等名词的含义以及简单的工作原理，下面两章会介绍如何在移动端和 Mac 平台上搭建完全透明的网络代理，享受最优雅的爱国上网体验。</p>
<h2 data-source-line="578" id="第-35-章-mac-端爱国上网最佳实践"><a class="markdownIt-Anchor" href="#第-35-章-mac-端爱国上网最佳实践"></a>第 3.5 章 Mac 端爱国上网最佳实践</h2>
<h3 data-source-line="579" id="背景"><a class="markdownIt-Anchor" href="#背景"></a>背景</h3>
<p data-source-line="581">最优秀的配置就是在使用时感觉不到配置的存在，然而复杂的应用场景决定了我们需要多种代理配置。虽然最终的目的是摆脱繁琐的配置切换，但在此之前，我们有必要梳理一下日常使用中常见的痛点。</p>
<pre data-source-line="583"><code class="hljs">模拟器需要连代理，因此电脑必须设置 HTTP/HTTPS 代理
终端无法使用 Shadowsocks 代理，即使设置了全局代理也不行
某些应用，比如 Telegram，需要科学上网
访问墙外网站需要连 VPS，墙内网站不需要连接，代理会让国内网站访问速度降低</code></pre><h3 data-source-line="588" id="本质"><a class="markdownIt-Anchor" href="#本质"></a>本质</h3>
<p data-source-line="590">复杂的需求导致了代理场景的多样化，一般来说有三种：</p>
<pre data-source-line="592"><code class="hljs">Charles 的 HTTP<span class="hljs-symbol">\(</span>s<span class="hljs-symbol">\)</span> 代理
VPS 的 socks5 代理或 PAC
直接连接</code></pre><p data-source-line="596">上述问题的本质都来源于这三种代理是互斥的，而且切换起来比较麻烦。在 Mac 上有脚本可以切换，但有时依然无法人工区分改用哪种代理，在 iOS 上，就连设置代理都会非常耗时。</p>
<h3 data-source-line="597" id="目标与解决思路"><a class="markdownIt-Anchor" href="#目标与解决思路"></a>目标与解决思路</h3>
<p data-source-line="599">明确了问题与问题背后的复杂度以后，我们需要确定一个目标，以目标为导向，来指导自己的行动。</p>
<p data-source-line="601">目标其实非常简单：</p>
<pre data-source-line="603"><code class="hljs">经过有限次的配置，彻底避免切换代理</code></pre><p data-source-line="605">换句话说，就是希望代理的切换是自动进行的，全程不再需要人工干预。</p>
<p data-source-line="607">这似乎有悖于目前的工作模式，不过没关系，既然系统代理不方便，我们就需要一个全局代理，起到 路由 作用，根据一定的规则把请求转发到合适的代理上去。这样就把代理的切换简化成了规则的配置，规则永远存在，只要不断维护完善就行。</p>
<h3 data-source-line="608" id="mac-配置"><a class="markdownIt-Anchor" href="#mac-配置"></a>Mac 配置</h3>
<p data-source-line="610">Mac 上用到四个工具：</p>
<pre data-source-line="612"><code class="hljs">Proxifier： 全局控制工具，负责应用层面的请求转发
Charles：一种代理，负责处理那些需要被抓包的请求
sslocal： ss 代理的客户端，负责处理那些需要走 <span class="hljs-keyword">Shadowsocks </span>协议的请求
<span class="hljs-keyword">SwitchyOmega：Chrome </span>拓展工具，负责对 Chrome 中的网页进行智能代理选择</code></pre><h3 data-source-line="617" id="sslocal"><a class="markdownIt-Anchor" href="#sslocal"></a>sslocal</h3>
<p data-source-line="619">首先我们要租一台境外的服务器，用来运行 shadowsocks 的服务端。如果还没有租用服务器，可以购买搬瓦工的服务，便宜且稳定，<a href="https://bwh1.net/aff.php?aff=19860&amp;pid=43" target="_blank">这个链接</a> 年费 20 美元，每月 500G 流量，<a href="https://bwh1.net/aff.php?aff=19860&amp;pid=44" target="_blank">这个链接</a> 年费 50 美元，每月 1000G 流量，</p>
<p data-source-line="621">首先运行：</p>
<pre data-source-line="623"><code class="hljs">pip <span class="hljs-keyword">install</span> shadowsocks</code></pre><p data-source-line="625">然后运行：</p>
<pre data-source-line="627"><code class="hljs">ssserver -p<span class="hljs-built_in"> port </span>-k password -m method
<span class="hljs-comment"># port 指定 ssserver 运行在服务端的哪个端口</span>
<span class="hljs-comment"># password 是客户端用来连接的密码</span>
<span class="hljs-comment"># method 是加密方式，比如 rc-md5 或 aes-256-cfb 等</span></code></pre><p data-source-line="632">**注意：**如果你通过 ssh 连接到服务器， 在 ssh 断开后，你执行的进程也会随之被杀死。要想让 ssserver 长久运行，需要下面这个命令：</p>
<pre data-source-line="634"><code class="hljs">nohup ssserver -p port -k password -m <span class="hljs-function"><span class="hljs-keyword">method</span> &amp;</span></code></pre><p data-source-line="636">简单两行代码，一个 shadowsocks 的服务就搭建完成了。</p>
<p data-source-line="638">在 Mac 上运行 Shadowsocks 客户端一样容易，根本不需要那些乱七八糟的 GUI 工具，同样先安装 shadowsocks 工具：</p>
<pre data-source-line="640"><code class="hljs">pip <span class="hljs-keyword">install</span> shadowsocks</code></pre><p data-source-line="642">如果你还没有安装 pip3，则先输入：</p>
<pre data-source-line="644"><code class="hljs"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>python3</code></pre><p data-source-line="646">接下来填写一下 sslocal 的配置，按照 JSON 格式填写即可：</p>
<pre data-source-line="648"><code class="hljs">{
    <span class="hljs-string">"server"</span>:<span class="hljs-string">"ip"</span>,
    <span class="hljs-string">"server_port"</span>:<span class="hljs-number">443</span>,  <span class="hljs-comment">// 填写服务端的 port</span>
    <span class="hljs-string">"local_port"</span>:<span class="hljs-number">14179</span>,
    <span class="hljs-string">"password"</span>:<span class="hljs-string">"password"</span>,  <span class="hljs-comment">// 填写服务端的 password</span>
    <span class="hljs-string">"timeout"</span>:<span class="hljs-number">600</span>,
    <span class="hljs-string">"method"</span>:<span class="hljs-string">"aes-256-cfb"</span> <span class="hljs-comment">// 填写服务端的 method</span>
}</code></pre><p data-source-line="657">然后就可以运行 sslocal 了：</p>
<pre data-source-line="659"><code class="hljs">nohup sslocal -<span class="hljs-selector-tag">q</span> -c shadowsocks<span class="hljs-selector-class">.json</span> &amp;</code></pre><p data-source-line="661">这样就在后台运行了 sslocal 进程，任何应用都可以使用 socks 协议代理到本机的 14179 端口，从而实现科学上网。</p>
<h3 data-source-line="662" id="proxifier"><a class="markdownIt-Anchor" href="#proxifier"></a>Proxifier</h3>
<p data-source-line="664">Proxifer 是一个控制 app 代理方式的软件，有了它，我们就可以控制某个 app，比如 Telegram 使用哪种代理。首先在 Proxifier 中建立一个 Shadowsocks 代理：</p>
<p data-source-line="666"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fe26ba7768132974c8604a3f88779823b.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/e26ba7768132974c8604a3f88779823b.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fe26ba7768132974c8604a3f88779823b.png">
依次选择 Proxies、Add 并填写本机的端口。接下来就可以把某些特定应用的流量转到代理上了：</p>
<p data-source-line="669"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F6f45c16485f41bc37893d607b1d14a4f.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/6f45c16485f41bc37893d607b1d14a4f.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F6f45c16485f41bc37893d607b1d14a4f.png"></p>
<h3 data-source-line="671" id="终端科学上网-终端科学上网"><a class="markdownIt-Anchor" href="#终端科学上网-终端科学上网"></a>终端科学上网 {#终端科学上网}</h3>
<p data-source-line="673">有些时候，安装一些软件包会非常慢，这是因为数据源存在国外的服务器上，但终端默认不会走代理，即使设置了全局代理也无效。</p>
<p data-source-line="675">最简单的方式是使用如下命令：</p>
<pre data-source-line="677"><code class="hljs"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">ALL_PROXY</span>=socks5://127.0.0.1:1080
<span class="hljs-comment"># 取消代理可以用下面命令</span>
<span class="hljs-comment"># unset ALL_PROXY</span></code></pre><p data-source-line="681">不过根据个人实践，偶尔这个命令会有抽风的时候，更复杂，也更靠谱的做法是安装 polipo。完整教程可以参考这篇文章：<a href="https://droidyue.com/blog/2016/04/04/set-shadowsocks-proxy-for-terminal/" target="_blank">为终端设置 Shadowsocks 代理。
</a>
当然，如果你能用<a href="http://fullstack.blog/2018/03/27/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%88%B1%E5%9B%BD%E4%B8%8A%E7%BD%91%E3%80%81%E5%B1%8F%E8%94%BD%E5%B9%BF%E5%91%8A%E4%B8%8E%E5%AE%BD%E5%B8%A6%E6%8F%90%E9%80%9F/" target="_blank">路由器翻墙</a>，那么就不存在终端翻墙的问题了。</p>
<h3 data-source-line="684" id="charles"><a class="markdownIt-Anchor" href="#charles"></a>Charles</h3>
<p data-source-line="686">Charles 作为一个大名鼎鼎的抓包工具，具体使用方法就不用我细说了，可以参考巧哥的这篇文章：<a href="http://blog.devtang.com/2013/12/11/network-tool-charles-intr/" target="_blank">iOS 开发工具-网络封包分析工具 Charles。
</a></p>
<p data-source-line="689">虽然 Charles 的抓包功能足够强大，但美中不足的是，它的数据处理能力极为孱弱。虽然有 Map Local/Remote 和 Rewrite 功能，但终究不是图灵完备的语言， 灵活性和可拓展性还不够强大，比如如果数据是使用 protobuf 的形式传输，Charles 就无能为力了。</p>
<p data-source-line="691">通常情况下，为了搭建一个多端统一、长期可维护的测试环境，我们需要一个中间人服务器，经过一段时间的尝试和技术选型，最终我们选择了 MITM，详细内容可以参考我的这篇博客<a href="https://github.com/bestswifter/blog/blob/master/articles/http-proxy-tools.md" target="_blank">：HTTP 代理服务器技术选型之旅</a>。</p>
<p data-source-line="693">有了 MITM 工具以后，iOS 模拟器的调试问题就迎刃而解了。注意，此时不要直接修改系统的代理，因为来回切换代理比较麻烦，Charles 提供了一个非常好用的功能，叫 External Proxy。顾名思义，Charles 可以把自己视为一个中转站，把经过自己的数据发送到下一个代理服务器上去。</p>
<p data-source-line="695">因此，日常工作中，我采用的方案是系统代理长期设置为 Charles，且 Charles 长期将外部代理设置为 MITM，两者要么同时生效，要么同时失效，经过 Charles 数据一定会经过 MITM 。</p>
<p data-source-line="697"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fbe39299f5ac1462db70d08351a429212.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/be39299f5ac1462db70d08351a429212.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fbe39299f5ac1462db70d08351a429212.png">
<img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fb755283dee49e8d3563110e188bc9064.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/b755283dee49e8d3563110e188bc9064.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fb755283dee49e8d3563110e188bc9064.png"></p>
<h3 data-source-line="700" id="快速切换系统代理"><a class="markdownIt-Anchor" href="#快速切换系统代理"></a>快速切换系统代理</h3>
<p data-source-line="702">上述配置虽然大部分时候都能 work，但万一出现 Proxifier 不能指定代理，而且这个网络流量又不能走代理服务器时，我们还需要一个终极方案——快速把系统代理还原为默认。虽然我至今只在某次更新 App Store 时遇到过上述问题，但做好技术储备还是没有坏处的。</p>
<p data-source-line="704">使用 networksetup 配合各种参数即可实现上述需求，我写了一个可以自动切换 Charles 和 GoAgentX 代理的脚本，<a href="https://github.com/bestswifter/macbootstrap/blob/master/zsh-config/platform.mac.sh#L8-#L100" target="_blank">在这里</a> 可以下载并根据自己的需求自行修改。</p>
<p data-source-line="706">效果如图所示：</p>
<p data-source-line="708"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd9e9218f71e77bcd09414750270e0516.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/d9e9218f71e77bcd09414750270e0516.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd9e9218f71e77bcd09414750270e0516.png"></p>
<h3 data-source-line="710" id="switchyomega"><a class="markdownIt-Anchor" href="#switchyomega"></a>SwitchyOmega</h3>
<p data-source-line="712">最后一个要用到的工具是 Chrome 的一个插件：<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank">SwitchyOmega</a>，它可以给不同的 URL 配置不同的访问策略。</p>
<p data-source-line="714">首先我们新建一个情景，用来处理需要科学上网的网站。</p>
<p data-source-line="716"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fdd67cec90ba9756a22ab98d2b20bd123.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/dd67cec90ba9756a22ab98d2b20bd123.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fdd67cec90ba9756a22ab98d2b20bd123.png"></p>
<p data-source-line="718">如果是前端开发，那些需要抓包调试的网站可以代理到 Charles 上，过程类似就不赘述了。</p>
<p data-source-line="720">然后需要配置下 <code>auto switch</code> 场景，在绝大多数时候，我们都将使用这个场景：</p>
<p data-source-line="722"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F53b73b985009a8ee4e33a1dee30df89b.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/53b73b985009a8ee4e33a1dee30df89b.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F53b73b985009a8ee4e33a1dee30df89b.png"></p>
<p data-source-line="724">第一个区域内是一些自己制定的规则，如果自动配置中某些网站的访问方式不符合我们的要求，可以单独列在这里。第二个区域表示如果命中规则列表，则使用 socks 代理，否则就直接连接。第三个区域则使用了一个开源的网址列表，列出了那些需要科学上网的网站。</p>
<p data-source-line="726">有了这样的配置，我们就可以实现 百度、淘宝、京东等网站直接连接，YouTube、Google、草榴等网站科学上网了。</p>
<h3 data-source-line="727" id="mac-配置小结"><a class="markdownIt-Anchor" href="#mac-配置小结"></a>Mac 配置小结</h3>
<p data-source-line="729">Mac 上需要用到的软件较多，但每个软件的使用都不太复杂，回忆一下之前的几个痛点：</p>
<pre data-source-line="731"><code class="hljs">模拟器需要连接代理，因此电脑需要设置 HTTP/HTTPS 代理。
这一点我们其实是通过长期设置代理为 C<span class="hljs-function"><span class="hljs-title">harles</span> -&gt;</span> MITM 实现的，并且利用脚本来快速切换代理。
终端无法使用 SS 代理，即使是全局代理也不行。这个问题通过 polipo 工具解决，并且编写了脚本。
某些应用，比如 Telegram，需要科学上网。这个问题通过 Proxifier 来设置某个 app 使用的代理方式。
按需代理，只有需要科学上网的网站才用代理。这个需求通过 Chrome 的插件 SwitchyOmega 完成。</code></pre><h2 data-source-line="738" id="第-36-章-移动端爱国上网最佳实践"><a class="markdownIt-Anchor" href="#第-36-章-移动端爱国上网最佳实践"></a>第 3.6 章 移动端爱国上网最佳实践</h2>
<p data-source-line="740">如果说 Mac 上有各种需求，难以找到通用解决方案的话，手机端就很简单了，我想绝大多数人都只有这几个需求：</p>
<pre data-source-line="742"><code class="hljs">对于移动端开发者，需要代理到 Mac 上，抓取应用的网络数据
某些应用会对客户端证书做校验， 比如 <span class="hljs-keyword">iTunes、微信支付等安全性较高的场景，无法通过代理打开
</span>如果想科学上网，需要连接 VPN，这与 HTTP 代理冲突
系统默认只支持 VPN 连接，无法配置规则</code></pre><p data-source-line="747">以 iOS 系统为例，这些问题可以交给一个应用：Shadowrocket（又叫小火箭）来解决，这类应用已经在国内的 App Store 下架，需要使用美国账号购买。</p>
<p data-source-line="749">打开 shadowrocket 以后，在首页点击右上角的加号，可以新建一个节点，也就是我们的代理服务器：</p>
<p data-source-line="751"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F7a071aec5db432c8b1495e06bb770f77.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/7a071aec5db432c8b1495e06bb770f77.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F7a071aec5db432c8b1495e06bb770f77.png"></p>
<p data-source-line="753">这里强烈建议给节点添加备注，原因稍后会讲。</p>
<h3 data-source-line="754" id="自动选择代理"><a class="markdownIt-Anchor" href="#自动选择代理"></a>自动选择代理</h3>
<p data-source-line="756"><img data-src="http%3A%2F%2Fbos.nj.bpc.baidu.com%2Fv1%2Fagroup%2Fdc956533d21907d2dd7dc7bbb4eafd3c1d76b3fb" alt="image" src="http://bos.nj.bpc.baidu.com/v1/agroup/dc956533d21907d2dd7dc7bbb4eafd3c1d76b3fb?ynotemdtimestamp=1536291187205" data-processed="http%3A%2F%2Fbos.nj.bpc.baidu.com%2Fv1%2Fagroup%2Fdc956533d21907d2dd7dc7bbb4eafd3c1d76b3fb"></p>
<p data-source-line="758">接下来，我们需要选择路由模式，一共有四种。直连的意思很好理解，就是不走任何代理，相当于没用上 shadowrocket，可以理解为一种回滚方案。全局则表示 app 所有网络流量都走代理服务器，相当于使用了系统的 VPN。这两者功能都太单一，基本上不会使用。</p>
<p data-source-line="760">配置模式和上文说过的 <code>auto switch</code>差不多，都是实现了黑名单 + 广告屏蔽的功能：</p>
<pre data-source-line="762"><code class="hljs">广告屏蔽：对于某些专门用于投放广告的域名，直接屏蔽掉网络请求，从而起到去除广告的效果。
黑名单：列出需要科学上网的网址，走代理服务器。
其它：默认是直接连接。</code></pre><p data-source-line="766">我使用的是这份配置：<a href="https://raw.githubusercontent.com/lhie1/Surge/master/Shadowrocket.conf" target="_blank">https://raw.githubusercontent.com/lhie1/Surge/master/Shadowrocket.conf</a></p>
<p data-source-line="768">它的主体结构可以分为三部分：</p>
<pre data-source-line="770"><code class="hljs"><span class="hljs-comment">// 屏蔽广告</span>
<span class="hljs-comment">// 爱奇艺</span>
DOMAIN-SUFFIX,ad<span class="hljs-selector-class">.m</span><span class="hljs-selector-class">.iqiyi</span><span class="hljs-selector-class">.com</span>,REJECT
DOMAIN-SUFFIX,afp<span class="hljs-selector-class">.iqiyi</span><span class="hljs-selector-class">.com</span>,REJECT
DOMAIN-SUFFIX,api<span class="hljs-selector-class">.cupid</span><span class="hljs-selector-class">.iqiyi</span><span class="hljs-selector-class">.com</span>,REJECT
.......
<span class="hljs-comment">// 优酷</span>
......

<span class="hljs-comment">// 科学上网</span>
<span class="hljs-comment">// 以 gmail.com 结尾的网址要求走代理，并且要求代理服务器做 DNS 解析</span>
DOMAIN-SUFFIX,gmail<span class="hljs-selector-class">.com</span>,PROXY,force-remote-dns

<span class="hljs-comment">// 直连</span>
<span class="hljs-comment">// BAT 等首页直连</span>
DOMAIN-SUFFIX,baidu<span class="hljs-selector-class">.com</span>,DIRECT
DOMAIN-SUFFIX,qq<span class="hljs-selector-class">.com</span>,DIRECT
DOMAIN-SUFFIX,alipay<span class="hljs-selector-class">.com</span>,DIRECT</code></pre><p data-source-line="789">这套配置绝大多数情况下足够使用了，奈何客户端开发者经常需要对 APP 抓包，以前是通过修改系统代理实现的，现在直接修改配置文件就行了。</p>
<h3 data-source-line="790" id="自定义配置"><a class="markdownIt-Anchor" href="#自定义配置"></a>自定义配置</h3>
<p data-source-line="792">现在我们的需求变成了：</p>
<pre data-source-line="794"><code class="hljs">检查是否是广告，如果是广告则拒绝连接
检查是否需要科学上网，如果需要的话，走代理服务器
检查是否需要抓包，如果需要的话，走 <span class="hljs-keyword">Mac</span> 的 Charles 代理代理代理
剩下的请求默认直连</code></pre><p data-source-line="799">其中第三四步的逻辑可以颠倒，也就是说可以默认走抓包模式，只有那些不能抓包的连接才直连。然而这种模式问题比较多，因为很多对安全性比较高的 app 或者网页，比如支付模块等等，都会检查客户端证书， 这种情况下通过 Charles 代理就无法访问了。</p>
<p data-source-line="801">这种需求是无法使用默认的配置模式实现的， 因为它只能选择代理 or 直连，而我们的需求实际上是有两种代理，即 Shadowsocks 代理和 Charles 代理，这需要我们对配置文件做一些手动编辑。</p>
<p data-source-line="803">注意到之前的每一条配置都是三段式：</p>
<pre data-source-line="805"><code class="hljs">规则类型,规则特征,连接方式</code></pre><p data-source-line="807">其中连接方式可以是 DIRECT（直连）、PROXY（代理）和 REJECT（拒绝），实际上这里还可以填写前文所说的节点标签。比如我把 VPS 的标签设置为 DigitalOcean，这里就可以改成 DigitalOcean，效果和 PROXY 一致。</p>
<p data-source-line="809">有了这个大前提，我们可以新建一个 HTTP 代理，标记为 Mac Pro，然后把需要抓包的连接的代理方式设置为 Mac Pro 即可：</p>
<p data-source-line="811"><img data-src="http%3A%2F%2Fbos.nj.bpc.baidu.com%2Fv1%2Fagroup%2F92e2056e5d6fd321fa051e1a30fdc5bd5b9bf2d8" alt="image" src="http://bos.nj.bpc.baidu.com/v1/agroup/92e2056e5d6fd321fa051e1a30fdc5bd5b9bf2d8?ynotemdtimestamp=1536291187205" data-processed="http%3A%2F%2Fbos.nj.bpc.baidu.com%2Fv1%2Fagroup%2F92e2056e5d6fd321fa051e1a30fdc5bd5b9bf2d8"></p>
<p data-source-line="813">配置文件更新为：</p>
<pre data-source-line="815"><code class="hljs"><span class="hljs-comment">// 需要抓包的地址走 Charles 代理</span>
DOMAIN-SUFFIX,api<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span>,MAC PRO<span class="hljs-comment">// 屏蔽广告DOMAIN-SUFFIX,ad.m.iqiyi.com,REJECT// 以 gmail.com 结尾的网址要求走代理，并且要求代理服务器做 DNS 解析DOMAIN-SUFFIX,gmail.com,DigitalOcean,force-remote-dns// BAT 等首页直连DOMAIN-SUFFIX,baidu.com,DIRECT</span></code></pre><h3 data-source-line="818" id="场景模式-与-widget"><a class="markdownIt-Anchor" href="#场景模式-与-widget"></a>场景模式 与 Widget</h3>
<p data-source-line="820">真正让我下定决心使用 shadowrocket 而不是其它应用的原因是它的场景模式。有时候，在 WiFi 模式和 4G 模式，甚至是不同的 WiFi 下，我们使用的配置文件并不相同。比如我在家的 WiFi 和外出 4G 模式下，并不需要抓包。一个场景就是一种数据接入方式和配置文件的集合，最神奇的是，场景可以自动切换。</p>
<p data-source-line="822">比如我创建了三个场景，分别表示 4G、家庭 WiFi 和公司 WiFi，每个场景有自己的配置文件，通过 WiFi 名称来区分：</p>
<p data-source-line="824"><img data-src="http%3A%2F%2Fbos.nj.bpc.baidu.com%2Fv1%2Fagroup%2Fa49681daab457fcec22dded470c79a6cb7687b51" alt="image" src="http://bos.nj.bpc.baidu.com/v1/agroup/a49681daab457fcec22dded470c79a6cb7687b51?ynotemdtimestamp=1536291187205" data-processed="http%3A%2F%2Fbos.nj.bpc.baidu.com%2Fv1%2Fagroup%2Fa49681daab457fcec22dded470c79a6cb7687b51"></p>
<p data-source-line="826">这样当我回家以后，shadowrocket 切换场景，自然也就会切换配置文件，从而避免了手动切换。</p>
<h3 data-source-line="827" id="ios-配置总结"><a class="markdownIt-Anchor" href="#ios-配置总结"></a>iOS 配置总结</h3>
<p data-source-line="829">在 iOS 平台上，我们也遵循了不用系统代理，利用全局代理软件来控制代理的原则，通过 shadowrocket 提供的配置文件和规则实现了需求。同时 Widget、场景模式、iCloud 备份与二维码导出提高了软件的使用效率。另一个好用的工具就是 Widget，除了全局开关以外，可以快速在场景、代理、直连、配置四种路由方式中快速选择，这个相当于之前我们编写的切换系统代理的脚本。虽然用到的场景不多，但作为一种备用方案，还是不可或缺的。</p>
<p data-source-line="831"><img data-src="http%3A%2F%2Fbos.nj.bpc.baidu.com%2Fv1%2Fagroup%2Fb2b48b033800ba57c5ca8a01d5204baa2041c3ac" alt="image" src="http://bos.nj.bpc.baidu.com/v1/agroup/b2b48b033800ba57c5ca8a01d5204baa2041c3ac?ynotemdtimestamp=1536291187205" data-processed="http%3A%2F%2Fbos.nj.bpc.baidu.com%2Fv1%2Fagroup%2Fb2b48b033800ba57c5ca8a01d5204baa2041c3ac"></p>
<p data-source-line="833">除此以外，shadowrocket 导入导出配置也很容易，默认使用 iCloud 同步数据，自己的节点和配置还可以用二维码的方式分享给别人，别人在使用时只要扫码即可导入。</p>
<h3 data-source-line="834" id="总结"><a class="markdownIt-Anchor" href="#总结"></a>总结</h3>
<p data-source-line="836">在 iOS 平台上，我们也遵循了不用系统代理，利用全局代理软件来控制代理的原则，通过 shadowrocket 提供的配置文件和规则实现了需求。同时 Widget、场景模式、iCloud 备份与二维码导出提高了软件的使用效率。</p>
<p data-source-line="838">有了这些配置以后，各个软件的存在感反而不强了，因为几乎都会保持打开状态，交给配置文件去决定代理方式，大大提升了工作效率。</p>
<p data-source-line="840">由于我没有使用安卓手机，所以暂时没有安卓平台的教程，读者可以自行搜索类似的代理软件并进行配置。</p>
<h2 data-source-line="842" id="第-37-章-alfred-简介"><a class="markdownIt-Anchor" href="#第-37-章-alfred-简介"></a>第 3.7 章 Alfred 简介</h2>
<p data-source-line="844">Alfred 绝对是让 Mac 更加好用的神器之一，如果 Mac 上只能安装一款三方软件，那非 Alfred 莫选。我把 Alfred 拔高到如此地位绝非是为了捧杀它，而是确实实至名归，本文主要会介绍 Alfred 原生的用法。</p>
<p data-source-line="846">除了 Alfred 软件自带的功能外，它还允许用户自己开发 workflow 并分享出来，正是这些 workflow，彻底奠定了 Alfred 的神器地位，下一章将会详细介绍它们的详细使用方式。</p>
<h3 data-source-line="847" id="alfred-简介"><a class="markdownIt-Anchor" href="#alfred-简介"></a>Alfred 简介</h3>
<p data-source-line="849">打开程序，首页中可以编辑 Alfred 的启动快捷键，这里我把它设置为 双击 Command 键，最好用的 App 当让要配备最好按的快捷键。</p>
<p data-source-line="851"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F56033e43b97c3aba721302f421fbb2de.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/56033e43b97c3aba721302f421fbb2de.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F56033e43b97c3aba721302f421fbb2de.png"></p>
<p data-source-line="853">Alfred 使用的是免费 App + 付费高级功能的模式，本文所介绍的所有内容都是 Alfred 免费提供的。</p>
<h3 data-source-line="854" id="文件程序搜索"><a class="markdownIt-Anchor" href="#文件程序搜索"></a>文件/程序搜索</h3>
<p data-source-line="856">文件搜索是 Alfred 最基础的功能，类似于系统的 Spotlight，直接双击 Command 打开 Alfred 的窗口，然后输入文件名即可。</p>
<p data-source-line="858"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fcdc15cc076e2f98c06f3c474d1d47c40.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/cdc15cc076e2f98c06f3c474d1d47c40.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fcdc15cc076e2f98c06f3c474d1d47c40.png"></p>
<p data-source-line="860">这也是为什么我会设置 Dock 栏隐藏的原因，毕竟有了 Alfred，谁会去 Dock 里面找 App 呢。</p>
<p data-source-line="862">关于文件的搜索，我们还可以配置搜索的范围，搜索哪些类型的文件等等，读者可以在 <code>Features -&gt; Default Results</code> 中配置。</p>
<h3 data-source-line="863" id="网络搜索"><a class="markdownIt-Anchor" href="#网络搜索"></a>网络搜索</h3>
<p data-source-line="865">如果我们想通过 Google 搜索东西，常规步骤是：</p>
<pre data-source-line="867"><code class="hljs">打开 Chrome
在地址栏输入 google<span class="hljs-selector-class">.com</span>
打开谷歌主页，输入搜索内容</code></pre><p data-source-line="871">然而有了 Alfred，搜索步骤变成了：</p>
<pre data-source-line="873"><code class="hljs">唤起 Alfred（显然比打开 Chrome 再进入 google<span class="hljs-selector-class">.com</span> 快得多）
输入搜索内容，回车</code></pre><p data-source-line="876">如图所示，先输入字母 g，大概率你会看到这个场景：</p>
<p data-source-line="878"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F31c8b7ff89ea07816000a7f57b82b19e.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/31c8b7ff89ea07816000a7f57b82b19e.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F31c8b7ff89ea07816000a7f57b82b19e.png"></p>
<p data-source-line="880">这说明 Alfred 目前认为，你最有可能的行为是搜索 Chrome 这个应用并打开，所以把它排在第一位，第二个选项才是使用 Google 搜索。</p>
<p data-source-line="882">没关系，我们 按照提示，按下 Command + 2，效果等同于点击第二个选项。Alfred 很聪明，会智能记忆，只要多重复几次，使用 Google 搜索就变成默认选项了。</p>
<p data-source-line="884"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F39b12e96ee7b740a75bc91ee432244fd.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/39b12e96ee7b740a75bc91ee432244fd.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F39b12e96ee7b740a75bc91ee432244fd.png"></p>
<p data-source-line="886">此时按下 Tab 键或者回车键都可以快速补全命令：</p>
<p data-source-line="888"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F95af01dca2ac3e7c454782877edb6980.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/95af01dca2ac3e7c454782877edb6980.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F95af01dca2ac3e7c454782877edb6980.png"></p>
<p data-source-line="890">输入想要搜索的内容按下回车，Alfred 就会自动帮我们打开浏览器，并且拼接好地址，直接跳转过去。</p>
<p data-source-line="892">PS：如果你觉得 Google 搜索非常高频，不想每次把 g 补全为 google，可以在<code>Features -&gt; Web Search</code>中修改 Google 搜索的 keyword。在 Web Search 的配置中，你还会看到除了 Google 搜索外，更多的搜索方式，比如搜索 Wikipedia、YouTube 和 Gmail 等等。</p>
<h3 data-source-line="893" id="计算器"><a class="markdownIt-Anchor" href="#计算器"></a>计算器</h3>
<p data-source-line="895">有了 Alfred，我们就不需要找到系统的计算器并打开了，可以直接在 Alfred 中做基本的运算：</p>
<p data-source-line="897"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F6647f504e4881e027cfc70bd90928bb1.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/6647f504e4881e027cfc70bd90928bb1.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F6647f504e4881e027cfc70bd90928bb1.png"></p>
<h3 data-source-line="899" id="剪贴板历史"><a class="markdownIt-Anchor" href="#剪贴板历史"></a>剪贴板历史</h3>
<p data-source-line="901">考虑下面几种场景，你的做法是什么？</p>
<pre data-source-line="903"><code class="hljs">不知道现在剪贴板中的内容是什么，需要先粘贴出来，如果不满意再删除？
想要拿到上上次复制的内容，但是剪贴板里面已经被覆盖了
上周复制过一段话，依稀只记得某些关键字，想要再把内容找出来</code></pre><p data-source-line="907">有了 Alfred 的剪贴板增强，以上场景都不是问题，首先要在 Features -&gt;; Clipboard 中打开剪贴板历史：</p>
<p data-source-line="909"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F305c9c0742ffdff7bb42fc9aebf28893.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/305c9c0742ffdff7bb42fc9aebf28893.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F305c9c0742ffdff7bb42fc9aebf28893.png"></p>
<p data-source-line="911">这里我把它们都设置为存储三个月，同时把打开剪贴板的快捷键设置为 Command + Shift + C，按下快捷键我们会看到：</p>
<p data-source-line="913"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fb8f49bb97f28c1894cf67119fa404747.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/b8f49bb97f28c1894cf67119fa404747.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fb8f49bb97f28c1894cf67119fa404747.png"></p>
<p data-source-line="915">所有的复制历史，包括图片的预览都一目了然，我们还可以搜索剪贴板历史：</p>
<p data-source-line="917"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F8ab13d5124319c092ee284ee057fe560.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/8ab13d5124319c092ee284ee057fe560.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F8ab13d5124319c092ee284ee057fe560.png"></p>
<p data-source-line="919">同样通过 Command + 数字键，就可以把它粘贴出来。同时被粘贴出来的内容会移动到剪贴板历史的最前方。</p>
<h3 data-source-line="920" id="文本片段"><a class="markdownIt-Anchor" href="#文本片段"></a>文本片段</h3>
<p data-source-line="922">有一些文本是需要反复输入的，比如你的邮箱、QQ号、地址、手机号码、某个网址等信息，亦或者聊天常用语句、表情等等，这些都可以通过 Alfred 来管理，节省输入时间。打开<code>Features -&gt;</code>; Snippets：</p>
<p data-source-line="924"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F73a7f7135360f5b93d4f66a2c26ae27f.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/73a7f7135360f5b93d4f66a2c26ae27f.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F73a7f7135360f5b93d4f66a2c26ae27f.png"></p>
<p data-source-line="926">首先勾选右上角的 <strong>Automatically</strong> expand，它表示只要你输入关键字，就会自动展开成文本内容。</p>
<p data-source-line="928"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBsexZUY1rHtI2Ly2Y6%252F-LBsf3htKP6qYfsZU_7E%252Fsnippet.gif%3Falt%3Dmedia%26token%3D2d305a8b-e688-4c76-85ec-d36f2c6cb306" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LBsexZUY1rHtI2Ly2Y6%2F-LBsf3htKP6qYfsZU_7E%2Fsnippet.gif?alt=media&amp;token=2d305a8b-e688-4c76-85ec-d36f2c6cb306&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBsexZUY1rHtI2Ly2Y6%252F-LBsf3htKP6qYfsZU_7E%252Fsnippet.gif%3Falt%3Dmedia%26token%3D2d305a8b-e688-4c76-85ec-d36f2c6cb306"></p>
<p data-source-line="930">建议根据文本的使用场景，建立多个 Collection，比如开发相关的，个人信息相关的，聊天相关的等。</p>
<h2 data-source-line="933" id="第-38-章-优秀-workflow-推荐"><a class="markdownIt-Anchor" href="#第-38-章-优秀-workflow-推荐"></a>第 3.8 章 优秀 workflow 推荐</h2>
<p data-source-line="935">Workflow 中文的意思是工作流，它表示把多个事件联合在一起，形成一个连贯的开发体验。如果想使用 Workflow，必须购买 Alfred 的 PowerPack，价格在 19 - 35镑不等。</p>
<p data-source-line="937">如果没有额外说明地址，下面的 Workflow 都可以在<a href="https://github.com/bestswifter/my-workflow" target="_blank">我的 GitHub 上面下载</a>。</p>
<h3 data-source-line="938" id="evernote"><a class="markdownIt-Anchor" href="#evernote"></a>Evernote</h3>
<p data-source-line="940">当下大多数资历中使用的还是 v8 版本的 Workflow，根据我的测试已经无法使用，推荐下载使用<a href="https://www.alfredforum.com/topic/840-evernote-9-beta-2-for-alfred-3-search-create-append-set-reminders-all-within-alfred/" target="_blank"> v9 版本</a>。</p>
<p data-source-line="942">我本人只把 Evernote 当做收藏集（也就是只收录文章，不自己编辑），所以只有搜索的需求。可以输入 ens 进行全文搜索，或者用 ent 来搜索标题。</p>
<p data-source-line="944">在 ens 命令后面还可以加上 @ 来指定笔记本，或者加上 # 来指定标签。</p>
<p data-source-line="946"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBuqP_U2iyTmuzb4uKD%252F-LBuvBRcCgw9iAHAa7Vx%252Fevernote-workflow.gif%3Falt%3Dmedia%26token%3D4031a7a7-1c9c-4056-8b8b-1aa2baf5358b" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LBuqP_U2iyTmuzb4uKD%2F-LBuvBRcCgw9iAHAa7Vx%2Fevernote-workflow.gif?alt=media&amp;token=4031a7a7-1c9c-4056-8b8b-1aa2baf5358b&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBuqP_U2iyTmuzb4uKD%252F-LBuvBRcCgw9iAHAa7Vx%252Fevernote-workflow.gif%3Falt%3Dmedia%26token%3D4031a7a7-1c9c-4056-8b8b-1aa2baf5358b"></p>
<p data-source-line="948">命令 enn 用于新建一条笔记，同样支持 # 和 @ 语法。</p>
<h3 data-source-line="949" id="applauncher"><a class="markdownIt-Anchor" href="#applauncher"></a>AppLauncher</h3>
<p data-source-line="951">这是我独立开发的一个 Workflow，用来全局快速打开 App：</p>
<p data-source-line="953"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F6fe07e27df8a631782393e3d1a3eb471.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/6fe07e27df8a631782393e3d1a3eb471.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F6fe07e27df8a631782393e3d1a3eb471.png"></p>
<p data-source-line="955">所有 App 快捷键都以 Command + Ctrl 开头，这样选择是因为不容易和系统快捷键产生冲突。如果你交换过 Ctrl 和 Caps Lock 键，就会发现触发起来非常方便、</p>
<h3 data-source-line="956" id="dash"><a class="markdownIt-Anchor" href="#dash"></a>Dash</h3>
<p data-source-line="958">如果电脑上装了 Dash，这个 Workflow 允许我们快速搜索文档：</p>
<p data-source-line="960"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBuqP_U2iyTmuzb4uKD%252F-LBuuDSn51s6eC8XZc0Y%252Fdash-workflow.gif%3Falt%3Dmedia%26token%3Dd201251a-63ec-4cf9-b812-eccf8b8c2d3d" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LBuqP_U2iyTmuzb4uKD%2F-LBuuDSn51s6eC8XZc0Y%2Fdash-workflow.gif?alt=media&amp;token=d201251a-63ec-4cf9-b812-eccf8b8c2d3d&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBuqP_U2iyTmuzb4uKD%252F-LBuuDSn51s6eC8XZc0Y%252Fdash-workflow.gif%3Falt%3Dmedia%26token%3Dd201251a-63ec-4cf9-b812-eccf8b8c2d3d"></p>
<h3 data-source-line="962" id="ip"><a class="markdownIt-Anchor" href="#ip"></a>IP</h3>
<p data-source-line="964">这个 Workflow 比较简单， 可以显示自己的内网 IP 和公网 IP：</p>
<p data-source-line="966"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F524a66ae9eb560a52d649077d8b4de33.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/524a66ae9eb560a52d649077d8b4de33.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F524a66ae9eb560a52d649077d8b4de33.png"></p>
<h3 data-source-line="968" id="有道词典"><a class="markdownIt-Anchor" href="#有道词典"></a>有道词典</h3>
<p data-source-line="970">有道词典已经把 API 迁移到了有道智云，所以需要自行注册 API Token，关于 Workflow 的下载和使用，请参考这个 <a href="https://github.com/wensonsmith/YoudaoTranslate" target="_blank">GItHub 仓库</a>。</p>
<p data-source-line="972">使用效果如下：</p>
<p data-source-line="974"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBuqP_U2iyTmuzb4uKD%252F-LBuxb0Aa6wsCGngTll3%252Fyd-workflow.gif%3Falt%3Dmedia%26token%3D1e3d242d-f191-4b90-8d5b-a1656b1414a9" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LBuqP_U2iyTmuzb4uKD%2F-LBuxb0Aa6wsCGngTll3%2Fyd-workflow.gif?alt=media&amp;token=1e3d242d-f191-4b90-8d5b-a1656b1414a9&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBuqP_U2iyTmuzb4uKD%252F-LBuxb0Aa6wsCGngTll3%252Fyd-workflow.gif%3Falt%3Dmedia%26token%3D1e3d242d-f191-4b90-8d5b-a1656b1414a9"></p>
<h3 data-source-line="976" id="github"><a class="markdownIt-Anchor" href="#github"></a>GitHub</h3>
<p data-source-line="978">作为程序员，难免要和 GitHub 打交道，<a href="https://github.com/gharlan/alfred-github-workflow" target="_blank">这个 Workflow</a> 能帮助我们快速搜索、操作 GitHub：</p>
<p data-source-line="980"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBuqP_U2iyTmuzb4uKD%252F-LBuypB2ErGZ0wgkFK6V%252Fgithub-workflow.gif%3Falt%3Dmedia%26token%3Dbb1c9493-75b1-420b-88a5-fe5b0f277810" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LBuqP_U2iyTmuzb4uKD%2F-LBuypB2ErGZ0wgkFK6V%2Fgithub-workflow.gif?alt=media&amp;token=bb1c9493-75b1-420b-88a5-fe5b0f277810&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBuqP_U2iyTmuzb4uKD%252F-LBuypB2ErGZ0wgkFK6V%252Fgithub-workflow.gif%3Falt%3Dmedia%26token%3Dbb1c9493-75b1-420b-88a5-fe5b0f277810"></p>
<h3 data-source-line="982" id="hashbase64-工具"><a class="markdownIt-Anchor" href="#hashbase64-工具"></a>Hash/BASE64 工具</h3>
<p data-source-line="984">提供了一些 md5、hash、sha1 计算工具和 base64 加密解密的功能：</p>
<p data-source-line="986"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F671b6b716644d92b2ed042d876f4dc28.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/671b6b716644d92b2ed042d876f4dc28.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F671b6b716644d92b2ed042d876f4dc28.png"></p>
<h3 data-source-line="988" id="layout"><a class="markdownIt-Anchor" href="#layout"></a>layout</h3>
<p data-source-line="990">这是一个调整窗口布局的工具，可以设置窗口全屏或者摆放位置，甚至还可以切换屏幕。详情参考：<a href="https://github.com/untoldwind/alfred2-layout" target="_blank">alfred2-layout</a></p>
<h3 data-source-line="991" id="color"><a class="markdownIt-Anchor" href="#color"></a>color</h3>
<p data-source-line="992">这是一个颜色格式转换的工具，可以把英文单词转换成各种格式的颜色写法，也可以直接读取 16 进制的颜色：</p>
<p data-source-line="994"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBxZu_0oEkbCD5PAeHN%252F-LBx_ZrOdrUlAsK0Q7fS%252Fcolor-workflow.gif%3Falt%3Dmedia%26token%3Dc3b2a2b3-fe84-4c40-a834-274063f97edf" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LBxZu_0oEkbCD5PAeHN%2F-LBx_ZrOdrUlAsK0Q7fS%2Fcolor-workflow.gif?alt=media&amp;token=c3b2a2b3-fe84-4c40-a834-274063f97edf&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBxZu_0oEkbCD5PAeHN%252F-LBx_ZrOdrUlAsK0Q7fS%252Fcolor-workflow.gif%3Falt%3Dmedia%26token%3Dc3b2a2b3-fe84-4c40-a834-274063f97edf"></p>
<h3 data-source-line="996" id="快递查询"><a class="markdownIt-Anchor" href="#快递查询"></a>快递查询</h3>
<p data-source-line="998">如果在淘宝买了个 MacBook/iPhone 之类的大件，等快递的过程真是心急如焚，恨不得过一会儿就查一次快递到哪了，此时用上快递查询这个 Workflow 了：</p>
<p data-source-line="1000"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fe08cd319d532f711d9fd02415b34670b.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/e08cd319d532f711d9fd02415b34670b.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fe08cd319d532f711d9fd02415b34670b.png"></p>
<h2 data-source-line="1003" id="第-39-章-chrome-插件介绍"><a class="markdownIt-Anchor" href="#第-39-章-chrome-插件介绍"></a>第 3.9 章 Chrome 插件介绍</h2>
<h3 data-source-line="1004" id="插件管理技巧"><a class="markdownIt-Anchor" href="#插件管理技巧"></a>插件管理技巧</h3>
<p data-source-line="1006">有些插件是属于不需要交互，默默在后台运行的那种，比如屏蔽广告、显示 GitHub 仓库大小等等，这类插件可以设置为在 Chrome 中隐藏，这样 Chrome 就不会显得特别乱了。</p>
<p data-source-line="1008"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F2384468e56e44213612bd4a045caef13.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/2384468e56e44213612bd4a045caef13.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F2384468e56e44213612bd4a045caef13.png"></p>
<p data-source-line="1010">对于那些需要手动点击，使用频率还很高的插件，我们还可以设置快捷键，打开 <code>chrome://extensions/</code> 点击左上角的设置，选择 键盘快捷键：</p>
<p data-source-line="1012"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F49a989c941a81d18b11b507228fcb20c.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/49a989c941a81d18b11b507228fcb20c.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F49a989c941a81d18b11b507228fcb20c.png"></p>
<p data-source-line="1014">比如我经常用印象笔记收藏文章，所以就可以给它配上快捷键：</p>
<p data-source-line="1016"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F5b5bda61b02e6cd33fa2f21afc915f4e.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/5b5bda61b02e6cd33fa2f21afc915f4e.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F5b5bda61b02e6cd33fa2f21afc915f4e.png"></p>
<p data-source-line="1018">应用这两种管理方式后，插件栏就会很简洁，高频交互类和非交互类插件都可以隐藏，只会留下少数低频（不值得设置快捷键）交互类插件。</p>
<h3 data-source-line="1019" id="vimium"><a class="markdownIt-Anchor" href="#vimium"></a>Vimium++</h3>
<p data-source-line="1021">一个致力于无鼠标操作 Chrome 的插件，因为按键规则类似于 Vim 风格而得名，主要功能有：</p>
<pre data-source-line="1023"><code class="hljs">f<span class="hljs-regexp">/F: 在当前/</span>新页面打开链接
x<span class="hljs-regexp">/X：关闭/</span>恢复页面
j<span class="hljs-regexp">/k：向下/</span>上滑动网页
J/K：左右切换标签页
H/L：浏览记录前进后退
u<span class="hljs-regexp">/d：向上/</span>下滑动半页
b<span class="hljs-regexp">/B：在当前/</span>新页面打开收藏夹内的页面，支持搜索
o<span class="hljs-regexp">/O：在当前/</span>新页面打开新的网址，支持历史记录搜索
gs：查看网页源码
gi：鼠标定位到输入框
gu/U：前往网页的上一层或根路径
yy：复制当前网址
yf：复制某个链接的地址
p<span class="hljs-regexp">/P：在当前/</span>新页面打开剪贴板中的网址</code></pre><p data-source-line="1038">使用体验如下：</p>
<p data-source-line="1040"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBzKobmeH6Ujbmi6x4S%252F-LBzKsY_F5mOcm_qkVz5%252Fvimium.gif%3Falt%3Dmedia%26token%3D58e5cc68-4e1b-407b-a439-c5384b6f2db2" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LBzKobmeH6Ujbmi6x4S%2F-LBzKsY_F5mOcm_qkVz5%2Fvimium.gif?alt=media&amp;token=58e5cc68-4e1b-407b-a439-c5384b6f2db2&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LBzKobmeH6Ujbmi6x4S%252F-LBzKsY_F5mOcm_qkVz5%252Fvimium.gif%3Falt%3Dmedia%26token%3D58e5cc68-4e1b-407b-a439-c5384b6f2db2"></p>
<h3 data-source-line="1042" id="github-repo-size"><a class="markdownIt-Anchor" href="#github-repo-size"></a>GitHub Repo Size</h3>
<p data-source-line="1044">顾名思义，可以查看 GitHub 中某个 Repo 的大小，是一个小巧实用的工具：</p>
<p data-source-line="1046"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F05810300799059d6f021d4135c53d68e.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/05810300799059d6f021d4135c53d68e.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F05810300799059d6f021d4135c53d68e.png"></p>
<h3 data-source-line="1048" id="fe-助手"><a class="markdownIt-Anchor" href="#fe-助手"></a>FE 助手</h3>
<p data-source-line="1050">这是一个工具集合，包含了字符串编解码、二维码生成器、网页转图片、网页取色、时间戳转换、BASE64 加解密、页面性能检测等工具。</p>
<p data-source-line="1052">这些功能都属于二级入口，如果有特别高频的使用场景，可以考虑使用单独的插件。下图展示了开启 JSON 格式化前后的区别（左侧开启 VS 右侧关闭）：</p>
<h3 data-source-line="1054" id="adblock-plus"><a class="markdownIt-Anchor" href="#adblock-plus"></a>Adblock plus</h3>
<p data-source-line="1056">自动屏蔽广告</p>
<h3 data-source-line="1057" id="印象笔记剪裁"><a class="markdownIt-Anchor" href="#印象笔记剪裁"></a>印象笔记·剪裁</h3>
<p data-source-line="1059">一键收藏喜欢的文章</p>
<h3 data-source-line="1060" id="vue"><a class="markdownIt-Anchor" href="#vue"></a>Vue</h3>
<p data-source-line="1062">开发模式下可以用来调试 Vue 界面</p>
<h3 data-source-line="1063" id="toby"><a class="markdownIt-Anchor" href="#toby"></a>Toby</h3>
<p data-source-line="1065">可以跨设备同步 Chrome 的标签</p>
<h2 data-source-line="1068" id="第-4-章-编辑器之神vim"><a class="markdownIt-Anchor" href="#第-4-章-编辑器之神vim"></a>第 4 章 编辑器之神：Vim</h2>
<p data-source-line="1070">Vim 是纯键盘操作，因此在本书开头就描述过的误区同样适用于 Vim：</p>
<pre data-source-line="1072"><code class="hljs">一些极端的人不够了解 Vim，感受不到 Vim 的价值，因此拒绝学习 Vim。

另一些极端的人过于沉迷于 Vim，想把 Vim 从编辑器打造成 IDE。因此在本章开头我就想强调的是：

Vim 就是个编辑器，用来输入、标记文本的，编程相关的东西交给 IDE 就好了</code></pre><p data-source-line="1078">所以最理想的方案应该是：<strong>选择一款 IDE，给它装上 Vim 插件</strong>。</p>
<p data-source-line="1080">但曾经的我，在 JetBrains 系列 IDE 和 Vim 之间犹豫不决，甚至还花了相当一段时间研究怎么用 Vim 开发 iOS，至于 Atom 和 Sublime 就根本没考虑过，一切的原因都在于：虽然很多 IDE 都有 Vim 模式，<strong>但都不支持 Vim 的插件</strong>。</p>
<p data-source-line="1082">不要小瞧 Vim 插件，很多插件真的是** Life-Changing** 系列的，本章第五篇文章就包含了我对一些 Vim 插件的介绍。</p>
<p data-source-line="1084">最后我放弃了 JetBrains 家的 IDE 套装，主要理由有：</p>
<pre data-source-line="1086"><code class="hljs"><span class="hljs-keyword">JetBrains </span>系列的 IDE 太庞大，繁重了。如果你要写不同语言，就要装不同的软件，而且每一个都很占用资源
VSCode 确实是地球上最好的 IDE，微软的技术真的很强。而且 VSCode 有着极活跃的社区，只需要安装这一个 App，配合上各种插件，就可以开发绝大多数语语言。</code></pre><h3 data-source-line="1089" id="最终我的编辑器选型为"><a class="markdownIt-Anchor" href="#最终我的编辑器选型为"></a>最终我的编辑器选型为：</h3>
<pre data-source-line="1091"><code class="hljs">前端/<span class="hljs-keyword">Node</span><span class="hljs-title">/其它脚本开发：VSCode</span> + Vim 插件
iOS 开发：Xcode，没有选择 XVim 是因为经常遇到诡异问题，而且不支持 Vim 插件根本没法用
Android 开发：Android Studio + Vim 插件</code></pre><p data-source-line="1095">客户端开发其实没什么选择的，因为暂时没有能完全替代官方 IDE 的东西。而 VSCode 功能就比较强大了，<strong>在我的日常工作中它基本上已经取代了原生的 Vim</strong>，最后一章会介绍一些 VSCode 中的用法和插件。</p>
<p data-source-line="1097">我使用了 neovim 来替代 vim，主要区别在于 neovim 更加先进，并且支持插件的异步加载。在使用上和 Vim 几乎是一致的</p>
<p data-source-line="1099">安装 NeoVim 需要以下几步：</p>
<pre data-source-line="1101"><code class="hljs">brew install nvim
pip3 install <span class="hljs-params">--trusted-host</span> pypi.python.org neovim jedi ipython
pip3 install <span class="hljs-params">--user</span> <span class="hljs-params">--upgrade</span> <span class="hljs-params">--trusted-host</span> pypi.python.org PyYAML

<span class="hljs-comment"># 下载配置</span>
git clone https:<span class="hljs-string">//github.com/bestswifter/vim-config.git</span> ~<span class="hljs-string">/.config/nvim</span>
ln -s ~<span class="hljs-string">/.config/nvim</span> ~<span class="hljs-string">/.vim</span></code></pre><p data-source-line="1109">用 nvim 命令打开文件后可以看到如下效果：</p>
<p data-source-line="1111"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F71881e9b2d2013705e7333b524ea361a.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/71881e9b2d2013705e7333b524ea361a.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F71881e9b2d2013705e7333b524ea361a.png"></p>
<h2 data-source-line="1114" id="第-41-章-vim-基本操作"><a class="markdownIt-Anchor" href="#第-41-章-vim-基本操作"></a>第 4.1 章 Vim 基本操作</h2>
<p data-source-line="1116">Vim 分为三种模式：</p>
<pre data-source-line="1118"><code class="hljs">输入模式：这就很普通的编辑器一样，光标在某个位置上闪烁，表示我们可以输入内容了。
普通模式：在输入模式下按下 Esc键可以退出输入模式，进入到普通模式。
命令模式：执行搜索、替换等命令或调用插件。</code></pre><p data-source-line="1122">普通模式是 Vim 的一大特色，能够进行很多操作，比如：</p>
<pre data-source-line="1124"><code class="hljs">快速移动光标
快速替换、删除某些内容
进入输入模式或命令模式</code></pre><p data-source-line="1128">使用 nvim 打开文件后，默认进入普通模式，如果我们要编辑文本，可以按下 i进入编辑模式，编辑完后再按下 Esc键可以退出输入模式，进入到普通模式。</p>
<p data-source-line="1130">如果想退出 nvim，则需要借助命令模式。按下 : 并输入以下内容之一：</p>
<pre data-source-line="1132"><code class="hljs">q：退出
q!：如果对文件作了修改，无法用 q 退出，此时 q! 表示丢弃修改并退出
x：保存并退出</code></pre><p data-source-line="1136">因为每次按下冒号还挺麻烦，所以我对我的 Vim 做了配置，无需进入命令模式，直接在普通模式就可以退出：</p>
<pre data-source-line="1138"><code class="hljs">q：退出
Ctrl-q：丢弃修改并退出
Ctrl-<span class="hljs-keyword">x</span>：保存并退出</code></pre><p data-source-line="1142">这种效果可以使用 Vim 的 map 配置来实现：</p>
<pre data-source-line="1144"><code class="hljs"><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span><span class="hljs-symbol">&lt;buffer&gt;</span> q  :pclose!<span class="hljs-symbol">&lt;CR&gt;</span>:<span class="hljs-keyword">quit</span><span class="hljs-symbol">&lt;CR&gt;</span>
<span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;C-x&gt;</span> :<span class="hljs-keyword">x</span><span class="hljs-symbol">&lt;CR&gt;</span>

// <span class="hljs-keyword">nnoremap</span> 表示普通模式下的 <span class="hljs-keyword">map</span>，等价于先输入冒号再输入 <span class="hljs-keyword">quit</span>
// <span class="hljs-keyword">inoremap</span> 表示输入模式下的 <span class="hljs-keyword">map</span>，因此输入模式下也可以用 C-q 快捷键
<span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> <span class="hljs-symbol">&lt;C-q&gt;</span> :<span class="hljs-symbol">&lt;C-u&gt;</span>:quit!<span class="hljs-symbol">&lt;CR&gt;</span>
<span class="hljs-keyword">inoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> <span class="hljs-symbol">&lt;C-q&gt;</span> <span class="hljs-symbol">&lt;Esc&gt;</span>:<span class="hljs-symbol">&lt;C-u&gt;</span>:quit!<span class="hljs-symbol">&lt;CR&gt;</span></code></pre><h2 data-source-line="1153" id="第-42-章-vim-光标移动"><a class="markdownIt-Anchor" href="#第-42-章-vim-光标移动"></a>第 4.2 章 Vim 光标移动</h2>
<p data-source-line="1155">上一节中我们介绍了 Vim 的基本操作，靠着 i 、:x等指令，配合上方向键，基本上能在 Vim 的世界里幸存下来了。勉强编辑一下服务器上的文件不是问题。</p>
<p data-source-line="1157">如果你的打字手势标准的话，你会发现方向键其实挺难触摸到，至少会破坏右手的姿势。因此在 Vim 中不鼓励使用方向键，可以用 hjkl 来代替：</p>
<pre data-source-line="1159"><code class="hljs">h：向左移动一个字符
l：向右移动一个字符
<span class="hljs-built_in">j</span>：向下移动一行
k：向上移动一行</code></pre><h3 data-source-line="1164" id="重复移动"><a class="markdownIt-Anchor" href="#重复移动"></a>重复移动</h3>
<p data-source-line="1166">如果要向上移动 5 行，或者向右移动 10 个字符，我们是不是要重复按下很多次呢？显然只有方向键才要这么做，Vim 中可以用数字来表示重复：</p>
<pre data-source-line="1168"><code class="hljs"><span class="hljs-number">10</span><span class="hljs-string">j:</span> 向下移动 <span class="hljs-number">10</span> 行
<span class="hljs-number">5</span><span class="hljs-string">l:</span>向右移动五个字符</code></pre><p data-source-line="1171">这个操作虽然简单，但是引出了两个很有意思的话题。首先，Vim 中的行号应该配置为相对行号 + 绝对行号：</p>
<p data-source-line="1173"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LC1O3mswIRs7b_jMQic%252F-LC1TYt0Vgohnblru3B1%252Fimage.png%3Falt%3Dmedia%26token%3D6bede799-6455-46d5-90b2-78d95cefba2d" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LC1O3mswIRs7b_jMQic%2F-LC1TYt0Vgohnblru3B1%2Fimage.png?alt=media&amp;token=6bede799-6455-46d5-90b2-78d95cefba2d&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LC1O3mswIRs7b_jMQic%252F-LC1TYt0Vgohnblru3B1%252Fimage.png%3Falt%3Dmedia%26token%3D6bede799-6455-46d5-90b2-78d95cefba2d"></p>
<p data-source-line="1175">图中左侧高亮显示的 22 是当前的绝对行号，上下都是相对偏移量。这样的好处在于既方便知道当前的位置，又方便通过相对行号进行跳转。</p>
<p data-source-line="1177">另一个话题则是贯穿 Vim 始终的核心思想：<strong>就像英语、中文有语法一样，Vim 也有语法</strong>。</p>
<p data-source-line="1179">Vim 的操作可以由若干个部分组合而成，每个部分又有多个可选值（比如光标移动就分上下左右）。Vim 的入门难度高，是因为每个部分都要学习，一下子需要掌握很多新知识点。但 Vim 后期的学习成本很低，因为无非就是各种组合而已。</p>
<p data-source-line="1181">还是以光标移动为例，5j 由重复次数和动作组成，后面我们会介绍更多的动作，而且它们的前面都可以加上数字表示重复。</p>
<h3 data-source-line="1182" id="单词移动"><a class="markdownIt-Anchor" href="#单词移动"></a>单词移动</h3>
<p data-source-line="1184">前面我们讲过利用 Option 键进行单词间移动，得益于普通模式和语法，Vim 支持更强大的单词间移动：</p>
<pre data-source-line="1186"><code class="hljs">w移动光标到下一个单词的词首<span class="hljs-symbol">\(</span>word<span class="hljs-symbol">\)</span>
b 移动光标到上一个单词的词首<span class="hljs-symbol">\(</span>begin<span class="hljs-symbol">\)</span>
e移动光标到下一个单词的结尾<span class="hljs-symbol">\(</span>end<span class="hljs-symbol">\)</span>
ge移动光标到上一个单词的结尾<span class="hljs-symbol">\(</span>不知道怎么解释了。。。<span class="hljs-symbol">\)</span></code></pre><p data-source-line="1191">这里的单词是有严格约定的，而且不是那么显然，所以个人感觉这几个键并不是特别好用（往往你以为的跳转地址和真实跳转地址并不一致）。</p>
<p data-source-line="1193">不过如果你把空格当做单词的分隔符，倒是有比较简单的跳转方式，前三个命令都有大写格式：</p>
<pre data-source-line="1195"><code class="hljs">W 移动光标到下一个单词的词首<span class="hljs-symbol">\(</span>word<span class="hljs-symbol">\)</span>
B 移动光标到上一个单词的词首<span class="hljs-symbol">\(</span>begin<span class="hljs-symbol">\)</span>
E 移动光标到下一个单词的结尾<span class="hljs-symbol">\(</span>end<span class="hljs-symbol">\)</span></code></pre><p data-source-line="1199">这里的单词特指以空格分割。</p>
<p data-source-line="1201">同样的，这些移动也支持重复任意多次</p>
<p data-source-line="1203">在后面的插件一节中，我会介绍如何用 EasyMotion 来让光标移动变得简单。</p>
<h3 data-source-line="1204" id="行和屏幕移动"><a class="markdownIt-Anchor" href="#行和屏幕移动"></a>行和屏幕移动</h3>
<p data-source-line="1206">在行内，^ 表示移动到行首，它会自动忽视掉行首的空格，大部分情况下这是符合预期的，尤其是在代码缩进的情况下。如果想回到行首的空格上，可以用 0 。$ 表示移动到行尾。</p>
<p data-source-line="1208">Vim 的翻页快捷键是：</p>
<pre data-source-line="1210"><code class="hljs">Ctrl + f：向后翻一页（forward）
Ctrl + b：向前翻一页（backward）
Ctrl + d：向后翻半页（<span class="hljs-meta">down</span>）
Ctrl + u：向前翻半页（<span class="hljs-meta">up</span>）</code></pre><p data-source-line="1215">很巧的是，前两个命令和系统输入框内的，向左向右移动一个字符的快捷键是一样的。后两个命令(u 和 d)则被 Vimium 借鉴，用于浏览器的翻页。</p>
<p data-source-line="1217">还有几个快捷键可以用于调整页面布局：</p>
<pre data-source-line="1219"><code class="hljs">zz：让当前行居中显示，方便浏览上下文
zt：让当前行显示在最上方，方便浏览后面的内容（t 表示 <span class="hljs-attribute">top</span>）
zb：让当前行显示在最下方，方便浏览前面的内容（<span class="hljs-selector-tag">b</span> 表示 <span class="hljs-attribute">bottom</span>）</code></pre><h3 data-source-line="1223" id="高级移动"><a class="markdownIt-Anchor" href="#高级移动"></a>高级移动</h3>
<p data-source-line="1225">代码中经常遇到括号（包括 (、[ 和 {，也就是大中小三中括号），如果当前光标停留在括号上，按下 % 即可匹配到对应的括号上。</p>
<p data-source-line="1227">除此以外，*和#分别表示匹配当前光标下的单词，并移动到下一个单词和上一个单词</p>
<h2 data-source-line="1231" id="第-43-章-vim-文本编辑"><a class="markdownIt-Anchor" href="#第-43-章-vim-文本编辑"></a>第 4.3 章 Vim 文本编辑</h2>
<p data-source-line="1233">阅读完前两章，相信读者以及能够在 Vim 中自如的移动光标了，不过我们的编辑方式还比较简陋，只能进入编辑模式，像往常一样逐个字符的输入和删除，本节会介绍一些更高级的操作。</p>
<h3 data-source-line="1234" id="基础文本编辑"><a class="markdownIt-Anchor" href="#基础文本编辑"></a>基础文本编辑</h3>
<p data-source-line="1236">在普通模式下，按下 o会快速进入输入模式，并且在下一行进行编辑。如果按下大写的O会在上一行编辑：</p>
<p data-source-line="1238"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LCNNt5akQ6aHw7e8VsL%252F-LCNTq4nv4dGm4tbHgEr%252Fvim-o.gif%3Falt%3Dmedia%26token%3D9e01b693-a2ca-4aa3-9fb7-e73000dd3c49" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LCNNt5akQ6aHw7e8VsL%2F-LCNTq4nv4dGm4tbHgEr%2Fvim-o.gif?alt=media&amp;token=9e01b693-a2ca-4aa3-9fb7-e73000dd3c49&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LCNNt5akQ6aHw7e8VsL%252F-LCNTq4nv4dGm4tbHgEr%252Fvim-o.gif%3Falt%3Dmedia%26token%3D9e01b693-a2ca-4aa3-9fb7-e73000dd3c49"></p>
<p data-source-line="1240">如果想在当前光标位置开始编辑，可以按下 a 或 i，前者表示在光标所在字符的右侧开始编辑，后者表示在左侧开始编辑。</p>
<p data-source-line="1242">我们还可以用 I 前往行头开始编辑，或者用 A 跳转到行尾编辑。</p>
<p data-source-line="1244">按下 dd 可以快速删除一行，此时被删除的那一行会保存在 Vim 的剪贴板中。这一点类似于系统的 Ctrl + X 剪切，我们可以通过配置 Vim 来选择是否要与系统共享剪贴板。</p>
<p data-source-line="1246">普通模式下，按下 p 可以把 Vim 剪贴板中的内容再拷贝出来，注意这里总是会拷贝到下一行或者光标的右侧。因此如果想交换当前行和下一行，可以输入：ddp，这是因为当前被删除的行会复制到下一行的下面。</p>
<p data-source-line="1248">如果只想复制，不想删除，可以把命令 p 换成 y（表示：yank）。如果想删除后进入编辑模式，可以把 p 换成 c，比如 cc 表示删除当前行并且从行首开始编辑。</p>
<pre data-source-line="1250"><code class="hljs">注意这里的 p、c、y、d 都是动作，和前面说的 j、k、l、h、w、<span class="hljs-keyword">b、e </span>一样，都支持用数字来重复，比如 <span class="hljs-number">2</span>dd 表示删除两行。</code></pre><h3 data-source-line="1252" id="撤销与重做"><a class="markdownIt-Anchor" href="#撤销与重做"></a>撤销与重做</h3>
<p data-source-line="1254">如果想撤销上一次修改，可以用 u，类似于系统的 Command + z 快捷键。</p>
<p data-source-line="1256">如果想重做，可以用 Ctrl + R，类似于系统的 Command + Shift + z 快捷键。</p>
<h3 data-source-line="1257" id="文本对象"><a class="markdownIt-Anchor" href="#文本对象"></a>文本对象</h3>
<p data-source-line="1259">Vim 的文本对象能极大幅度的提高编辑效率，也是 Vim 进阶之路上必须要掌握的概念。</p>
<p data-source-line="1261">对于上文介绍的 c、d、y 这些动作来说，作为单独的动作用处并不大，无非就是连续按两下对当前行做一些操作，而文本对象则扮演了语法中名词的概念，提供了更细粒度的操作。比如以下几种操作：</p>
<pre data-source-line="1263"><code class="hljs">diw： 删除一个单词（word）
<span class="hljs-keyword">ca</span><span class="hljs-comment">"：删除双引号内的文本并编辑（包含双引号自身）</span>
yi<span class="hljs-comment">"：复制双引号内的文本（不包含双引号自身）</span>
dtx：向右删除，直到遇到遇到字符 <span class="hljs-keyword">x</span>（不包含 <span class="hljs-keyword">x</span>）</code></pre><p data-source-line="1268">以上三个命令都属于同一大类操作，它们普遍遵循以下模式：</p>
<pre data-source-line="1270"><code class="hljs"><span class="hljs-attr">命令 </span>=<span class="hljs-string"> 动作 + 数量 + 描述词 + 文本对象</span></code></pre><p data-source-line="1272">这类命令通常由三个到字母组成：</p>
<pre data-source-line="1274"><code class="hljs">第一个字母是动词，包括上文介绍的 c、y、d等，表示你这个命令的主要目的。
第二个字母是可选的，表示重复几次
第三个字母是对范围的描述，比如 <span class="hljs-selector-tag">a</span> 表示包含边界，<span class="hljs-selector-tag">i</span> 不包含，t 表示向右查找，T 向左。
第四个字母是文本对象，可以是内容的字面量描述，比如 <span class="hljs-string">"、'、&lt;、`、{、( 等等，也可以是固定单词</span></code></pre><p data-source-line="1279">这里详细介绍下文本对象，除了字面量外，以下单词有特定的含义：</p>
<pre data-source-line="1281"><code class="hljs"><span class="hljs-keyword">p</span>：表示段落
s：表示句子
<span class="hljs-keyword">w</span>：表示单词
t：特指标签，一定要具备 <span class="hljs-symbol">&lt;xx&gt;</span><span class="hljs-keyword">abc</span>&lt;/xx&gt; 的结构，此时的 t 代表 <span class="hljs-keyword">abc</span>

对于字面量的文本对象，除了 <span class="hljs-comment">"、' 和 这三个引号外，另外几个括号都可以用 b 来表示（block），这样就不用区分大中小和尖括号了。</span></code></pre><h3 data-source-line="1288" id="搜索与替换"><a class="markdownIt-Anchor" href="#搜索与替换"></a>搜索与替换</h3>
<p data-source-line="1290">使用 / 进行搜索，我的搜索默认是忽略大小写的，使用 /pattern\C 可以强制匹配大小写。</p>
<p data-source-line="1292">使用 :范围s/oldpattern/newpattern/替换模式 可以进行替换。</p>
<p data-source-line="1294">如果我们已经进行过搜索，那么 oldpattern 可以省略不写，默认就是上一次的搜索内容。</p>
<p data-source-line="1296">最常用的范围是 begin,end，其中 begin 是开始行号，end 是结束行号，表示在第 begin 行到第 end 行之间进行替换，比如：:1,10s/hello/hallo/g 表示把第 1 - 10 行中所有的 hello 换成 hallo。</p>
<p data-source-line="1298">范围还有一些简单的表示法：</p>
<pre data-source-line="1300"><code class="hljs">.,<span class="hljs-number">10</span> 表示当前行到第 <span class="hljs-number">10</span> 行，点表示当前行
.,<span class="hljs-variable">$ </span>表示当前行到文件末尾，美刀符号表示文件结尾
% 表示 <span class="hljs-number">1</span>,<span class="hljs-variable">$，</span>也就是整个文件，比如全文替换通常写成 <span class="hljs-symbol">:%s/old/new/g</span>
.,+<span class="hljs-number">2</span> 表示当前行和接下来的两行</code></pre><p data-source-line="1305">上文反复提到的字母 g 其实是一种替换模式，表示替换这个范围内所有出现的 oldpattern，如果不写则只替换第一次出现。常用的模式还有 c，表示替换需要确认（Confirm），i 表示大小写不敏感，I 表示大小写敏感。</p>
<p data-source-line="1307">如果需要替换光标停留的单词，并不需要搜索，或者手动输入它。直接使用 &lt;Leader + s&gt; 即可。接下来只需要输入替换后的内容和替换模式。这种替换是全局替换。</p>
<h3 data-source-line="1308" id="大小写切换"><a class="markdownIt-Anchor" href="#大小写切换"></a>大小写切换</h3>
<p data-source-line="1310">以下是几个常用的，切换大小写的命令</p>
<pre data-source-line="1312"><code class="hljs"><span class="hljs-attribute">guu</span> 当前行全部小写，gUU 当前行全部大写
<span class="hljs-regexp">~ 当前光标下的字符切换大小写,</span> <span class="hljs-number">3</span><span class="hljs-regexp">~ 当前光标下后面三个字符切换大小写</span>
guiw 当前单词全部小写，gUiw 当前单词全部大写
g~iw 当前单词每个字符大小写交换</code></pre><h3 data-source-line="1317" id="列操作"><a class="markdownIt-Anchor" href="#列操作"></a>列操作</h3>
<p data-source-line="1319">如果有多行文本要做相同的操作，可以借助 Vim 中列操作的概念来快速完成，举一个实际实际的例子，假设有以下这段代码：</p>
<pre data-source-line="1321"><code class="hljs"><span class="hljs-keyword">int</span> a;
<span class="hljs-keyword">int</span> b;
<span class="hljs-keyword">int</span> c;
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">int</span> z;</code></pre><p data-source-line="1327">有一天我们发现 int 不是很准确，要改成：</p>
<pre data-source-line="1329"><code class="hljs"><span class="hljs-keyword">uint8_t</span> a;
<span class="hljs-keyword">uint8_t</span> b;
<span class="hljs-keyword">uint8_t</span> c;
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">uint8_t</span> z;</code></pre><p data-source-line="1335">难道还要手动复制粘贴不成？请看列操作大法：</p>
<pre data-source-line="1337"><code class="hljs">首先按下 Ctrl + V 进入列操作模式
然后用 j、k 进行跳转，表示你要操作多少行
这时你对每一行的操作都会应用到所有行上，比如输入 ec，删除单词进入编辑模式
输入 ui<span class="hljs-symbol">nt_8</span>，按下 Esc 退出编辑，Vim 会自动应用到所有行上。</code></pre><p data-source-line="1342"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LCNNt5akQ6aHw7e8VsL%252F-LCNs-FBoyd-a_lGr41g%252Fvim-ctrlv.gif%3Falt%3Dmedia%26token%3D4dcaef2b-adcf-46aa-a8c1-f638246a2cc9" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LCNNt5akQ6aHw7e8VsL%2F-LCNs-FBoyd-a_lGr41g%2Fvim-ctrlv.gif?alt=media&amp;token=4dcaef2b-adcf-46aa-a8c1-f638246a2cc9&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LCNNt5akQ6aHw7e8VsL%252F-LCNs-FBoyd-a_lGr41g%252Fvim-ctrlv.gif%3Falt%3Dmedia%26token%3D4dcaef2b-adcf-46aa-a8c1-f638246a2cc9"></p>
<h3 data-source-line="1344" id="宏"><a class="markdownIt-Anchor" href="#宏"></a>宏</h3>
<p data-source-line="1346">列操作的本质是多行同时操作，如果每一行的操作类似，但都有细微差别，就需要引入 录制、回放 的概念了。此时可以用 Vim 中的宏。</p>
<p data-source-line="1348">一个典型的场景是，我们在写 Markdown：</p>
<pre data-source-line="1350"><code class="hljs"><span class="hljs-bullet">1. </span>第一条
<span class="hljs-bullet">2. </span>第二条
<span class="hljs-bullet">3. </span>第三题
...
<span class="hljs-bullet">10. </span>第十条</code></pre><p data-source-line="1356">写着写着突然发现，第一条和第二条中间还要加一条，左边的序号就不好处理了，因为我们要把原来的序号 2 到 10 分别加一。</p>
<p data-source-line="1358">在 Vim 中，我们“只”需要输入 qajC-aq6@a，相信你一定很想打我，这特么一点也不简单啊。别急，拆开来看：</p>
<pre data-source-line="1360"><code class="hljs">qa（<span class="hljs-selector-tag">q</span> 表示开始录制宏，<span class="hljs-selector-tag">a</span> 表示录制内容存储在寄存器 <span class="hljs-selector-tag">a</span> 中）
j（向下一行）
Ctrl + a（数字加一）
q（再按一次 <span class="hljs-selector-tag">q</span> 表示结束录制）
<span class="hljs-number">6</span>@a（把存储在寄存器 <span class="hljs-selector-tag">a</span> 中的宏执行 <span class="hljs-number">6</span> 次）</code></pre><p data-source-line="1366">是不是感觉 So Easy（录像中我用的是大写 Q，因为小写 q 被映射了）：</p>
<p data-source-line="1368"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LCZGS_asahSdMyQ3Ya_%252F-LCZGW1bNTE26UxJB9px%252Fvim-macro.gif%3Falt%3Dmedia%26token%3D1949c7aa-78ee-4e9c-8e7a-08cdd079e4cf" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LCZGS_asahSdMyQ3Ya_%2F-LCZGW1bNTE26UxJB9px%2Fvim-macro.gif?alt=media&amp;token=1949c7aa-78ee-4e9c-8e7a-08cdd079e4cf&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LCZGS_asahSdMyQ3Ya_%252F-LCZGW1bNTE26UxJB9px%252Fvim-macro.gif%3Falt%3Dmedia%26token%3D1949c7aa-78ee-4e9c-8e7a-08cdd079e4cf"></p>
<h2 data-source-line="1372" id="第-44-章-vim-神级插件"><a class="markdownIt-Anchor" href="#第-44-章-vim-神级插件"></a>第 4.4 章 Vim 神级插件</h2>
<p data-source-line="1374">在本章的开头，我就提到目前的主力 IDE 是 VSCode，其实和 Atom/Sublime 这类 IDE 一样，它也是模拟了 Vim 的按键，并不支持 .vimrc配置文件。不过 VSCode 的强大之处在于，它支持了部分 Vim 的插件。</p>
<p data-source-line="1376">我想，不需要我做过多解释，读者也能明白这几个被支持的插件的重要性了，必然都是 <strong>Life-Changing</strong> 系列的。下面就逐个介绍一下：</p>
<h3 data-source-line="1377" id="easymotion"><a class="markdownIt-Anchor" href="#easymotion"></a>Easymotion</h3>
<p data-source-line="1379">从名字就能看出，这个插件的目的是快速光标跳转。它支持按行跳转，按字符/字符串跳转和按单词跳转等。跳转时还可以选择方向为向前或者向后， 不过这就增加了一倍的复杂度，作为一个懒人，我一般选择全屏跳转。</p>
<p data-source-line="1381">我配置的快捷键有：</p>
<pre data-source-line="1383"><code class="hljs"><span class="hljs-comment">;s：按字符串跳转（跳转到开头）</span>
<span class="hljs-comment">;w：按单词的开头跳转</span>
<span class="hljs-comment">;e：按单词的结尾跳转</span>
<span class="hljs-comment">;c：按字符串跳转</span>
<span class="hljs-comment">;l：按行首跳转（忽略空格）</span></code></pre><p data-source-line="1389">完整的快捷键列表可以查看文档。</p>
<h3 data-source-line="1390" id="surround"><a class="markdownIt-Anchor" href="#surround"></a>Surround</h3>
<p data-source-line="1392">上一节中介绍过文本对象（Text Object）的概念，它主要用来描述括号和引号中间的文本，但考虑一下变换：</p>
<pre data-source-line="1394"><code class="hljs"><span class="hljs-string">"hello"</span> -&gt; <span class="hljs-string">'hello'</span></code></pre><p data-source-line="1396">如果想把双引号换成单引号，就远远比改变 hello 这个单词难了。而 Surround 这个插件的目的，就是为了方便对引号和括号做修改。</p>
<p data-source-line="1398">它支持以下几种用法：</p>
<pre data-source-line="1400"><code class="hljs"><span class="hljs-keyword">y</span> s motion + <span class="hljs-symbol">&lt;char&gt;</span>：给指定范围添加 surround 字符，比如：ysaw<span class="hljs-comment">" 表示用双引号包裹单词。</span>
d s <span class="hljs-symbol">&lt;char&gt;</span>：删除周围的 surround，比如 <span class="hljs-keyword">ds</span><span class="hljs-comment">" 表示删除两侧的双引号</span>
<span class="hljs-keyword">c</span> s <span class="hljs-symbol">&lt;old-char&gt;</span> <span class="hljs-symbol">&lt;new-char&gt;</span>：更换周围的 surround，比如 <span class="hljs-keyword">cs</span><span class="hljs-comment">"'表示把周围的双引号换成单引号。</span></code></pre><p data-source-line="1404"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LCaUHn76WMdiUgSg2sp%252F-LCaZx9Al7sDaL9qznNx%252Fvim-surround.gif%3Falt%3Dmedia%26token%3D157433ba-74fc-4eb3-845b-be4d30d2fd0e" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LCaUHn76WMdiUgSg2sp%2F-LCaZx9Al7sDaL9qznNx%2Fvim-surround.gif?alt=media&amp;token=157433ba-74fc-4eb3-845b-be4d30d2fd0e&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LCaUHn76WMdiUgSg2sp%252F-LCaZx9Al7sDaL9qznNx%252Fvim-surround.gif%3Falt%3Dmedia%26token%3D157433ba-74fc-4eb3-845b-be4d30d2fd0e"></p>
<h3 data-source-line="1406" id="comment"><a class="markdownIt-Anchor" href="#comment"></a>Comment</h3>
<p data-source-line="1408">大多数 IDE 都支持 Command + / 给当前行添加注释，而且会根据语言自动选择注释方式。</p>
<p data-source-line="1410">在 Vim 中，给当前行添加/取消注释的方式是用 gcc，虽然多了一个按键，但按起来更容易了，而且支持多行注释。这里前两个字符 gc 表示按行注释，最后一个 c 表示当前行。如果想注释当前行和下面一行，可以输入 gcj。</p>
<p data-source-line="1412">美中不足的是，有些语言（如 HTML）中 VSCode 会用 /* ... */ 的写法进行多行注释，这样如果想取消注释，就只能去注释开始或结束的那一行把注释全部取消，而不能只单独取消中间某一行的注释。</p>
<p data-source-line="1414">输入 gC 可以注释某一块代码，后面接一个文本对象，比如 gCi( 表示注释括号内的东西（不包含括号）。不过个人认为注释小括号的需求几乎不存在，但下面这个场景还是有的，考虑这段代码：</p>
<pre data-source-line="1416"><code class="hljs"><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"wrold"</span>);
}</code></pre><p data-source-line="1421">有时候我们只想注释掉那两行 printf，写点别的逻辑，有时候会注释掉整个 if。问题是，怎么用文本对象来表示呢？下一个插件可以让我们用文本对象的方式来表示某一块缩进</p>
<h3 data-source-line="1422" id="indent"><a class="markdownIt-Anchor" href="#indent"></a>Indent</h3>
<p data-source-line="1424">其实很简单，一般就两个文本对象：</p>
<pre data-source-line="1426"><code class="hljs">ii：表示某一块缩进，不包含上一层，比如上面例子中的两个 <span class="hljs-built_in">printf</span>
aI：表示某一块缩进，包含上一层，比如上面例子中整个的 <span class="hljs-keyword">if</span> 语句</code></pre><p data-source-line="1429">其实还有一个不太常用的，ai 表示某一块缩进，和它的上面一行，也就是上面例子中的前三行，不包括第四行的大括号。这在 Python 中非常常用，因为它没有大括号，完全靠缩进来区分代码块。</p>
<p data-source-line="1431">因此，注释掉两行 printf 的语法是 gCii，注释掉整个 if 语句的方法是 gCaI。</p>
<p data-source-line="1433"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LCfPWVLjV7K6OdrlKkV%252F-LCfb1UTrJyzrkm7ZOMX%252Fvim-indent.gif%3Falt%3Dmedia%26token%3De18a4c3f-2f40-44f6-bbd9-90879a65c2ad" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LCfPWVLjV7K6OdrlKkV%2F-LCfb1UTrJyzrkm7ZOMX%2Fvim-indent.gif?alt=media&amp;token=e18a4c3f-2f40-44f6-bbd9-90879a65c2ad&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LCfPWVLjV7K6OdrlKkV%252F-LCfb1UTrJyzrkm7ZOMX%252Fvim-indent.gif%3Falt%3Dmedia%26token%3De18a4c3f-2f40-44f6-bbd9-90879a65c2ad"></p>
<h3 data-source-line="1435" id="sneak"><a class="markdownIt-Anchor" href="#sneak"></a>Sneak</h3>
<p data-source-line="1437">sneak 是和 EasyMotion 差不多的插件，主打快速跳转的功能。用法是 s&lt;char&gt;&lt;char&gt;，即按下 s 键后输入两个字符，可以跳转到下一个，这俩字符连续出现的位置。</p>
<p data-source-line="1439">然而相比原生的插件，VSCode 似乎有一个很严重的问题：不支持搜索高亮，这就导致我根本无法肉眼看出在当前位置和我的目标位置之间，隔了多少个 &lt;char&gt;&lt;char&gt;，导致无法用重复来跳转，也不支持标签跳转。更何况这个功能以及由 EasyMotion 实现了（快捷键 ;s），所以我就不再研究了。</p>
<h2 data-source-line="1442" id="第-45-章-vscode-最佳实践"><a class="markdownIt-Anchor" href="#第-45-章-vscode-最佳实践"></a>第 4.5 章 VSCode 最佳实践</h2>
<h3 data-source-line="1443" id="基本设置"><a class="markdownIt-Anchor" href="#基本设置"></a>基本设置</h3>
<pre data-source-line="1445"><code class="hljs">在 VSCode 中，按下 Command + ,可以编辑配置，配置分为全局配置和项目配置，项目配置的优先级高于全局配置。
按下 Command + k + Command + s键可以管理快捷键。
按下 Command + <span class="hljs-selector-tag">p</span> 可以在项目中根据名称搜索并打开文件。
按下 Command + Shift + <span class="hljs-selector-tag">p</span> 可以打开命令面板，那些不记得快捷键的命令，都可以在这里找到。</code></pre><p data-source-line="1450">掌握这些就可以初步使用 VSCode 了，下面会列举一些我的配置和插件，更多关于 VSCode 的配置介绍，请参考：vscode-tips-and-tricks</p>
<h3 data-source-line="1451" id="通用插件"><a class="markdownIt-Anchor" href="#通用插件"></a>通用插件</h3>
<pre data-source-line="1453"><code class="hljs"><span class="hljs-keyword">Beautify：代码格式化插件，可以将 </span>JS、CSS 和 HTML 代码格式化
<span class="hljs-symbol">Code</span> Outline ：支持多种语言的 outline 提取
<span class="hljs-symbol">Code</span> Runner：可以运行多种语言，我配置的快捷键为 Command + R。注意新的文本文件因为没有后缀名，要用快捷键 Command + K + M 手动切换语言类型。
<span class="hljs-symbol">Dash</span>：使用快捷键 Ctrl + h 快速打开 Dash 查找当前单词
<span class="hljs-keyword">MarkdownLint：Markdown </span>语法检查，帮助你写出标准的 <span class="hljs-keyword">Markdown
</span><span class="hljs-symbol">Project</span> Manager：帮助你管理项目，在多个项目间切换，快捷键 Option + P（首先要添加进项目列表）
<span class="hljs-symbol">TODO</span> Highlight：高亮显示 TODO
<span class="hljs-symbol">VSCode</span> Icons：根据文件和文件夹名称展示恰当的图标
<span class="hljs-keyword">Bracket </span>Pair Colorizer：给成对的括号配上颜色，方便区分
<span class="hljs-symbol">File</span> Size：在底部 <span class="hljs-keyword">bar </span>中显示文件大小
<span class="hljs-symbol">Path</span> Intellisense：自动补全文件路径</code></pre><p data-source-line="1465"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LD-FK8Web0NMZT_xa4Q%252F-LD-HJNWwzux0QZxlNJW%252Fcoderunner.gif%3Falt%3Dmedia%26token%3Dfe038b0a-63ab-4bc4-b95c-253b32458a87" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LD-FK8Web0NMZT_xa4Q%2F-LD-HJNWwzux0QZxlNJW%2Fcoderunner.gif?alt=media&amp;token=fe038b0a-63ab-4bc4-b95c-253b32458a87&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LD-FK8Web0NMZT_xa4Q%252F-LD-HJNWwzux0QZxlNJW%252Fcoderunner.gif%3Falt%3Dmedia%26token%3Dfe038b0a-63ab-4bc4-b95c-253b32458a87"></p>
<h3 data-source-line="1467" id="前端插件"><a class="markdownIt-Anchor" href="#前端插件"></a>前端插件</h3>
<pre data-source-line="1469"><code class="hljs">Auto Close <span class="hljs-keyword">Tag</span>：自动补全另一侧的 <span class="hljs-keyword">Tag</span>
<span class="hljs-title">Auto</span> Rename <span class="hljs-keyword">Tag</span>：修改一个 <span class="hljs-keyword">Tag</span> <span class="hljs-title">时，另一侧的 Tag</span> 自动修改
Color Highlight：遇到颜色字符串，自动在旁边显示颜色，方便预览
CSS Peek：
ESLint：代码格式化，支持实时监测和保存时自动修改
HTML Snippets：HTML 语法片段，方便快速输入
IntelliSense for CSS class：CSS 自动补全
JavaScript code snippets：JS 的语法片段，方便快速输入
Modern JavaScript Snippets：补充了一些更新的语法片段
HTML CSS Support：方便在 HTML 中插入 CSS 代码
SASS：sass 格式文件的代码补全和高亮
Vetur：Vue 开发必备的插件，提供代码补全、高亮等功能
Vue <span class="hljs-number">2</span> Snippets：Vue <span class="hljs-number">2</span> 的代码片段
Vue peek：快速跳转定义</code></pre><h3 data-source-line="1484" id="语法插件"><a class="markdownIt-Anchor" href="#语法插件"></a>语法插件</h3>
<p data-source-line="1486">一般用什么语言就装什么插件就行了。比如 Node、Bash、Python、Go、Ruby 等。</p>
<h3 data-source-line="1487" id="集成终端"><a class="markdownIt-Anchor" href="#集成终端"></a>集成终端</h3>
<p data-source-line="1489">VSCode 集成了一个终端，可以直接读取 .zshrc 中的配置（也就是说使用起来和 iTerm 几乎是一模一样的）。相关快捷键有：</p>
<pre data-source-line="1491"><code class="hljs"><span class="hljs-keyword">cmd</span><span class="bash"> + \： 水平切割，生成一个新的终端界面
</span><span class="hljs-keyword">cmd</span><span class="bash"> + 数字：当光标停留在终端时，通过数字来选择要聚焦的窗口
</span><span class="hljs-keyword">cmd</span><span class="bash"> + w：当光标停留在终端时，关闭当前终端
</span><span class="hljs-keyword">cmd</span><span class="bash"> + t：当光标停留在终端时，新建一个终端
</span><span class="hljs-keyword">cmd</span><span class="bash"> + l： 在 VSCode 内嵌的终端和代码编辑器中互相切换，再也不用跳出到 iTerm 了
</span>``ctrl + ```：隐藏/展示 终端</code></pre><h1 data-source-line="1499" id="第-5-章-git-从入门到进阶"><a class="markdownIt-Anchor" href="#第-5-章-git-从入门到进阶"></a>第 5 章 Git 从入门到进阶</h1>
<p data-source-line="1501">对于很多人来说，Git 只是一种代码同步工具，他们要做的无非就是在 Source Tree 或 Tower 这样的应用上，先把代码同步下来，然后选中本地的修改，推送到远程仓库而已。</p>
<p data-source-line="1503">有了这么傻瓜式的 GUI 工具，为什么还要学习 Git 呢？在我看来，主要有以下原因：</p>
<pre data-source-line="1505"><code class="hljs">GUI 工具底层还是通过 git 命令行来实现，学习多个 GUI 工具的使用，不见得比学习 git 来得快。
git 命令博大精深，GUI 工具只支持一些最基本的操作，很多强大的命令无法通过 GUI 工具来实现。
git 命令能让你从本质上去了解 git 的设计思想，这样的思想将来可能会在别的场景下复用。
GUI 工具的操作无法自动化，而 git 命令可以借助 <span class="hljs-keyword">Shell</span><span class="bash"> 脚本，部署在任何机器上，与任何上下游服务串联。</span></code></pre><p data-source-line="1510">本章将由浅入深，首先介绍基本的 Git 配置，然后介绍 log、branch、tag、push、commit、diff、stash、reset、checkout、grep等操作。最后则会介绍一些进阶配置和 Git 的核心原理。</p>
<p data-source-line="1512">由于本书的目的是提高效率，因此不会过多介绍每个命令的基础用法，而是侧重于分享很多人可能不清楚的进阶用法，展示 git 命令行工具强大、高效的一面。</p>
<h2 data-source-line="1515" id="第-51-章-git-配置"><a class="markdownIt-Anchor" href="#第-51-章-git-配置"></a>第 5.1 章 Git 配置</h2>
<h3 data-source-line="1517" id="入门配置"><a class="markdownIt-Anchor" href="#入门配置"></a><strong>入门配置</strong></h3>
<h3 data-source-line="1518" id="配置文件原理"><a class="markdownIt-Anchor" href="#配置文件原理"></a>配置文件原理</h3>
<p data-source-line="1520">在 Git 中，我们一般只需要关注两个配置文件，gitconfig 和 .gitignore，前者用来对 git 的行为进行配置，后者则用来指定文件的忽略规则。如果命中了规则，就不会添加到 Git 的版本管理中。</p>
<p data-source-line="1522">对于某个 Git 仓库来说，一般同时有两个 gitconfig 文件生效，一个是 ~/.gitconfig，它是全局的配置，另一个则位于每个 git 仓库下的 .git/config。如果有重复的配置项，项目配置的优先级高于全局配置，否则两者是相辅相成的关系。</p>
<p data-source-line="1524">.gitignore 文件也是类似，分为全局和项目两个配置，区别在于在 git 仓库中的任意一个目录都可以有 .gitignore 文件，当然这个文件只对此目录内的文件生效</p>
<h3 data-source-line="1525" id="配置-gpg-秘钥"><a class="markdownIt-Anchor" href="#配置-gpg-秘钥"></a>配置 GPG 秘钥</h3>
<p data-source-line="1527">GPG 秘钥可以确保提交的安全性，和 HTTPS 有些类似的是，使用 GPG 秘钥的提交在 GitHub 上会显示成绿色的 Verified 字样。</p>
<p data-source-line="1529"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDZId2SsY1dq8wePBmK%252F-LDZJvZXQrTcgELMbvz0%252Fimage.png%3Falt%3Dmedia%26token%3D2478f5e6-69ee-48c8-b009-1b66ab1509e3" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDZId2SsY1dq8wePBmK%2F-LDZJvZXQrTcgELMbvz0%2Fimage.png?alt=media&amp;token=2478f5e6-69ee-48c8-b009-1b66ab1509e3&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDZId2SsY1dq8wePBmK%252F-LDZJvZXQrTcgELMbvz0%252Fimage.png%3Falt%3Dmedia%26token%3D2478f5e6-69ee-48c8-b009-1b66ab1509e3"></p>
<p data-source-line="1531">为了实现这个效果，需要进行以下几步：</p>
<pre data-source-line="1533"><code class="hljs">如果使用我的安装脚本可以跳过这一步，否则执行 brew install gpg 来安装依赖。
输入 gpg --full-generate-key 并按照配置安装，注意第三步选择时长时，如果是个人使用可以填 0，表示永不过期，避免以后的麻烦。最后填写密码时可以不填。
安装完成后输入 gpg --list-keys 查看刚刚生成的秘钥，在 pub 下面有一长串数字和字母，这个是 GPG-ID。
输入 gpg --armor --export pub GPG-ID 把公钥复制出来，拷贝到 [<span class="hljs-string">GitHub GPG Keys</span>](<span class="hljs-link">https://github.com/settings/keys</span>) 上。
输入 git config --global user.signingkey GPG-ID 来配置使用哪个 key。
单次提交时使用 git commit -s 参数来开启 GPG key，或者使用git config --global commit.gpgsign true 设置为全局默认使用。
输入 gvc <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">commit_hash</span>&gt;</span></span> 来检查某次提交的 GPG 签名情况，如果没有输出，说明没有签名。它是git verify-commit命令的缩写。</code></pre><h3 data-source-line="1541" id="配置个人信息"><a class="markdownIt-Anchor" href="#配置个人信息"></a>配置个人信息</h3>
<p data-source-line="1543">首先要配置个人的名字和邮箱：</p>
<pre data-source-line="1545"><code class="hljs">gce ktzhang@bestswifter.com：配置邮箱，这是我的简写，完整的命令是：git<span class="hljs-built_in"> config </span>user.email
gcn bestswifter：配置用户名，完整的命令是 git<span class="hljs-built_in"> config </span>user.name</code></pre><h3 data-source-line="1548" id="配置忽略规则"><a class="markdownIt-Anchor" href="#配置忽略规则"></a>配置忽略规则</h3>
<p data-source-line="1550">在 .gitignore 文件中我们可以配置需要忽略哪些文件和文件夹。注意，这个文件仅对还没有被纳入 git 版本管理的文件生效，一旦某个文件被暂存过，再配置 .gitignore 就无效了，此时我们需要先把所有的文件取消暂存，再重新暂存。</p>
<p data-source-line="1552">我配置了命令 reignore 专门用于解决这类问题，它的完整定义如下：</p>
<pre data-source-line="1554"><code class="hljs"><span class="hljs-keyword">alias</span> reignore=<span class="hljs-symbol">'git</span> rm -r <span class="hljs-comment">--cached . &amp;&amp; git add .'</span></code></pre><p data-source-line="1556">如果某个文件不小心命中了忽略策略，就无法暂存到 git 中，而且 git 给出的提示并不友好。尤其是如果有多个 .gitignore 文件，很难知道哪一条规则导致了文件被忽略，此时可以使用 whyignore file_name 命令，它的完整定义时：</p>
<pre data-source-line="1558"><code class="hljs">alias whyignore='git<span class="hljs-built_in"> check-ignore </span>-v'</code></pre><h3 data-source-line="1560" id="进阶配置"><a class="markdownIt-Anchor" href="#进阶配置"></a>进阶配置</h3>
<h4 data-source-line="1561" id="scmpuff"><a class="markdownIt-Anchor" href="#scmpuff"></a>scmpuff</h4>
<p data-source-line="1563"><a href="https://github.com/mroth/scmpuff" target="_blank">scmpuff</a> 是一个 git 拓展，支持数字快捷键的操作，如图所示：</p>
<p data-source-line="1565"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDuHND1oS1WGQ-lzuGt%252F-LDuHeZoy8d96wRwe_qY%252Fimage.png%3Falt%3Dmedia%26token%3Df8cf50db-8518-4fe7-8180-9cedc3d87d8b" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDuHND1oS1WGQ-lzuGt%2F-LDuHeZoy8d96wRwe_qY%2Fimage.png?alt=media&amp;token=f8cf50db-8518-4fe7-8180-9cedc3d87d8b&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDuHND1oS1WGQ-lzuGt%252F-LDuHeZoy8d96wRwe_qY%252Fimage.png%3Falt%3Dmedia%26token%3Df8cf50db-8518-4fe7-8180-9cedc3d87d8b"></p>
<p data-source-line="1567">尤其是当文件路径较长时，我们可以用数字来代替文件，同时也支持 1-3 这种写法，表示多个文件。</p>
<h4 data-source-line="1568" id="icdiff"><a class="markdownIt-Anchor" href="#icdiff"></a>icdiff</h4>
<p data-source-line="1570">git 默认的对比是上下对比，但个人认为不够直观。尤其是在大屏显示器上，浪费了大量空间。</p>
<p data-source-line="1572"><a href="https://github.com/jeffkaufman/icdiff" target="_blank">icdiff </a>是一个左右水平显示的 diff 工具，在 git 中也可以使用：</p>
<pre data-source-line="1574"><code class="hljs"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">gdt</span></span>() {
    params=<span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>
    <span class="hljs-keyword">if</span> brew ls --versions scmpuff &gt; /dev/null; <span class="hljs-keyword">then</span>
        params=`scmpuff expand <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span> 2&gt;/dev/null`
    <span class="hljs-keyword">fi</span>

    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -eq 0 ]; <span class="hljs-keyword">then</span>
        git difftool --no-prompt --extcmd <span class="hljs-string">"icdiff --line-numbers --no-bold"</span> | less
    <span class="hljs-keyword">elif</span> [ <span class="hljs-variable">${#params}</span> -eq 0 ]; <span class="hljs-keyword">then</span>
        git difftool --no-prompt --extcmd <span class="hljs-string">"icdiff --line-numbers --no-bold"</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span> | less
    <span class="hljs-keyword">else</span>
        git difftool --no-prompt --extcmd <span class="hljs-string">"icdiff --line-numbers --no-bold"</span> <span class="hljs-string">"<span class="hljs-variable">$params</span>"</span> | less
    <span class="hljs-keyword">fi</span>
}</code></pre><p data-source-line="1589">然后用 gdt 来代替 git diff 即可，效果如图所示：</p>
<p data-source-line="1591">尤其是当两行只有少数变化时，默认的 git diff 会展示太多无用的干扰信息，而 icdiff 的输出就非常简洁直观了。</p>
<h4 data-source-line="1592" id="非文本文件-diff"><a class="markdownIt-Anchor" href="#非文本文件-diff"></a>非文本文件 Diff</h4>
<p data-source-line="1594">默认情况下，对于图片或者二进制文件，git 不会显示它们的具体变化。但如果我们自己配置了 diff 工具，就可以显示特定类型文件的变动。如果使用我的配置，默认自带了图片和 plist 文件的 diff 的功能。</p>
<p data-source-line="1596">也可以手动开启，首先编辑 ~/.gitconfig 文件：</p>
<pre data-source-line="1598"><code class="hljs">[<span class="hljs-meta">core</span>]
    attributesfile = ~/.gitattributes
[<span class="hljs-meta">diff <span class="hljs-meta-string">"exif"</span></span>]
    textconv = exiftool
[<span class="hljs-meta">diff <span class="hljs-meta-string">"plist"</span></span>]
    textconv = plutil -convert xml1 -o -</code></pre><p data-source-line="1605">然后编辑 ~/gitattributes 文件：</p>
<pre data-source-line="1607"><code class="hljs">*.png <span class="hljs-attribute">diff</span>=exif
*.jpg <span class="hljs-attribute">diff</span>=exif
*.plist <span class="hljs-attribute">diff</span>=plist</code></pre><p data-source-line="1611">最后再安装一下依赖：</p>
<pre data-source-line="1613"><code class="hljs"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>exiftool</code></pre><p data-source-line="1615">最终 plist 文件的 diff 效果如图所示：</p>
<p data-source-line="1617"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDuHND1oS1WGQ-lzuGt%252F-LDuPa82XlnAxRBRzx_z%252Fimage.png%3Falt%3Dmedia%26token%3D50423608-7095-4d1d-b744-c416c198d14b" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDuHND1oS1WGQ-lzuGt%2F-LDuPa82XlnAxRBRzx_z%2Fimage.png?alt=media&amp;token=50423608-7095-4d1d-b744-c416c198d14b&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDuHND1oS1WGQ-lzuGt%252F-LDuPa82XlnAxRBRzx_z%252Fimage.png%3Falt%3Dmedia%26token%3D50423608-7095-4d1d-b744-c416c198d14b"></p>
<h2 data-source-line="1620" id="第-52-章-查看提交记录"><a class="markdownIt-Anchor" href="#第-52-章-查看提交记录"></a>第 5.2 章 查看提交记录</h2>
<p data-source-line="1622">Git 做为版本管理工具，最重要的特色之一就是强大的记录查询，可以花式查看各种提交历史和变动，同时也支持过滤和筛选。本章主要介绍 log、diff 等工具的使用</p>
<h3 data-source-line="1623" id="log"><a class="markdownIt-Anchor" href="#log"></a>Log</h3>
<p data-source-line="1625">通过 git log 命令可以查看过去的提交记录。这个命令非常常用，但也非常复杂，常见的有以下几种：</p>
<h3 data-source-line="1626" id="基础命令"><a class="markdownIt-Anchor" href="#基础命令"></a>基础命令</h3>
<p data-source-line="1628">在我的配置中，输入 gg，它会单行展示提交历史，也支持展示分支的关系，如图所示。</p>
<p data-source-line="1630"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDk074RQr2kko78aG4f%252F-LDk0JfmyGfg4emf5xsw%252Fimage.png%3Falt%3Dmedia%26token%3D38b0b805-94c6-424e-80d9-e76795c7c67e" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDk074RQr2kko78aG4f%2F-LDk0JfmyGfg4emf5xsw%2Fimage.png?alt=media&amp;token=38b0b805-94c6-424e-80d9-e76795c7c67e&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDk074RQr2kko78aG4f%252F-LDk0JfmyGfg4emf5xsw%252Fimage.png%3Falt%3Dmedia%26token%3D38b0b805-94c6-424e-80d9-e76795c7c67e"></p>
<p data-source-line="1632">它的完整命令是：</p>
<pre data-source-line="1634"><code class="hljs"><span class="hljs-built_in">alias</span> gg=<span class="hljs-string">'git lg'</span></code></pre><p data-source-line="1636">lg 命令可以通过上一节介绍的 gitconfig 来配置：</p>
<pre data-source-line="1638"><code class="hljs">[<span class="hljs-keyword">alias</span>]
    lg = log --color --graph --pretty=format:'<span class="hljs-symbol">%Cred</span><span class="hljs-symbol">%h</span><span class="hljs-symbol">%Creset</span> -<span class="hljs-symbol">%C</span>(yellow)<span class="hljs-symbol">%d</span><span class="hljs-symbol">%Creset</span> <span class="hljs-symbol">%s</span> <span class="hljs-symbol">%Cgreen</span>(<span class="hljs-symbol">%ci</span>) <span class="hljs-symbol">%C</span>(bold blue) &lt;<span class="hljs-symbol">%an</span>&gt;<span class="hljs-symbol">%Creset</span>' --abbrev-commit</code></pre><h3 data-source-line="1641" id="常用拓展"><a class="markdownIt-Anchor" href="#常用拓展"></a>常用拓展</h3>
<p data-source-line="1643">如果只想简单的查看提交历史，使用 gg 命令就足够了。但如果想查看更细的内容，gg 就不太够用了。我们可以输入 ggs 命令，它在 gg 的基础上会展示每次提交具体改动的文件，等价于命令 gg --stat，如图所示：</p>
<p data-source-line="1645"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDk074RQr2kko78aG4f%252F-LDk1lqxnI8fTw_KgZnh%252Fimage.png%3Falt%3Dmedia%26token%3D40a90b87-75de-4606-b868-9d3c0c8bce77" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDk074RQr2kko78aG4f%2F-LDk1lqxnI8fTw_KgZnh%2Fimage.png?alt=media&amp;token=40a90b87-75de-4606-b868-9d3c0c8bce77&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDk074RQr2kko78aG4f%252F-LDk1lqxnI8fTw_KgZnh%252Fimage.png%3Falt%3Dmedia%26token%3D40a90b87-75de-4606-b868-9d3c0c8bce77"></p>
<p data-source-line="1647">如果想查看某次提交具体的变动，可以使用 ggp 命令。它在 gg 的基础上会展示文件的具体改动，等价于命令 gg -p，如图所示</p>
<p data-source-line="1649"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDk074RQr2kko78aG4f%252F-LDk1zZ_ju4Mt9ckVQ04%252Fimage.png%3Falt%3Dmedia%26token%3Dc6a3b985-80a2-4f3a-a4cf-134eab2b85ba" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDk074RQr2kko78aG4f%2F-LDk1zZ_ju4Mt9ckVQ04%2Fimage.png?alt=media&amp;token=c6a3b985-80a2-4f3a-a4cf-134eab2b85ba&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDk074RQr2kko78aG4f%252F-LDk1zZ_ju4Mt9ckVQ04%252Fimage.png%3Falt%3Dmedia%26token%3Dc6a3b985-80a2-4f3a-a4cf-134eab2b85ba"></p>
<h3 data-source-line="1651" id="进阶使用"><a class="markdownIt-Anchor" href="#进阶使用"></a>进阶使用</h3>
<pre data-source-line="1653"><code class="hljs">输入 gga，可以展示所有的分支，一般建议用它代替 gg，它等价于命令 gg <span class="hljs-comment">--all</span>
不管是gg，还是衍生出来的 ggs 和 ggp，后面都可以加上 -n，比如 ggs <span class="hljs-number">-2</span>，或者 ggp <span class="hljs-number">-1</span>，表示只显示前 n 个提交
如果想看某一个区间内的 <span class="hljs-built_in">log</span>，可以输入 gg HEAD~<span class="hljs-number">3.</span>.HEAD，注意区间是左开右闭，所以这个命令会查看三次提交的记录。注意较早的提交要写在左边。
如果只记得某次提交内容\(content\)里有一个词，比如 networksetup，可以用 ggp -G networksetup 来查找所有提交内容中包含 networksetup 的提交。-G 选项和 -S 选项主要有两个区别， 前者可以接收正则，而后者只会查找那些导致 <span class="hljs-built_in">string</span> 出现次数发现变动的提交，比如把 <span class="hljs-built_in">name</span>:<span class="hljs-number">0</span> 换成 <span class="hljs-built_in">name</span>:<span class="hljs-number">1</span>，用 -S 就无法搜索到 <span class="hljs-built_in">name</span>, 因为它的出现次数并没有改变，但是用 -G 可以。
如果只记得某次提交记录\(message\)里有一个词，比如 highlight，可以用 ggp <span class="hljs-comment">--grep highlight 来查找所有提交记录中包含 highlight 的提交</span>
如果想查看某个文件中某一段代码的提交记录，可以用 ggp -L start,<span class="hljs-keyword">end</span>:file_name 命令，详情请参考 Git grep 这一节的用法。
如果想查看某个文件或者文件夹的改动历史，可以输入 gg file_name，当然 ggs 和 ggp 也都是支持的。</code></pre><h3 data-source-line="1661" id="diff"><a class="markdownIt-Anchor" href="#diff"></a>Diff</h3>
<pre data-source-line="1663"><code class="hljs">输入 <span class="hljs-built_in">gd</span> 即可查看工作区内的变动，等价于命令 git <span class="hljs-built_in">diff</span>
输入 gds 可以查看暂存区的变动，也就是查看那些被 git add 了的文件的变动，等价于命令 git <span class="hljs-built_in">diff</span> --staged
输入 gdc 可以查看最近一次提交的变动，等价于命令 git <span class="hljs-built_in">diff</span> HEAD^ HEAD
输入 gdcr 可以倒过来查看某次提交的变动，它的第一个参数是提交的 SHA-<span class="hljs-number">1</span> 值，如果不写则是 HEAD，所以 gdcr 和 gdc 是恰好相反的 <span class="hljs-built_in">diff</span>。这样的好处是如果 想撤销某次提交，只要用 gdcr sha-<span class="hljs-number">1</span> 就可以获得那次提交的逆提交，如果想要精确到只恢复某个文件，第二个参数可以是文件名。比如 gdcr sha-<span class="hljs-number">1</span> <span class="hljs-built_in">file_name</span> | git <span class="hljs-built_in">apply</span>
输入 gdt 即可用外部 <span class="hljs-built_in">diff</span> 工具查看 <span class="hljs-built_in">diff</span>，它是 git difftool --no-<span class="hljs-built_in">prompt</span> --extcmd <span class="hljs-string">"icdiff --line-numbers --no-bold"</span> <span class="hljs-string">"$@"</span> | less 命令的缩写，这个命令依赖 icdiff 这个工具，可以用 homebrew 安装。
输入 gdts 和 gdtc 可以对应的用外部 <span class="hljs-built_in">diff</span> 查看已暂存和上次提交的变动，这些和 gds 与 gdc 命令基本上是一样的，区别在于使用外部 <span class="hljs-built_in">diff</span> 工具，会更美观一些（当然速度也会更慢），效果如图所示</code></pre><p data-source-line="1669"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDuQ25C7UnLshfkSJYf%252F-LDuQ5F7bGQF6zGNjYa1%252Fimage.png%3Falt%3Dmedia%26token%3D81bc9f25-b527-404c-93c0-9b14cf318d19" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDuQ25C7UnLshfkSJYf%2F-LDuQ5F7bGQF6zGNjYa1%2Fimage.png?alt=media&amp;token=81bc9f25-b527-404c-93c0-9b14cf318d19&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDuQ25C7UnLshfkSJYf%252F-LDuQ5F7bGQF6zGNjYa1%252Fimage.png%3Falt%3Dmedia%26token%3D81bc9f25-b527-404c-93c0-9b14cf318d19"></p>
<h3 data-source-line="1670" id="grep"><a class="markdownIt-Anchor" href="#grep"></a>Grep</h3>
<p data-source-line="1672">这个命令和 grep 的区别在于运行更快，而且可以指定搜索范围（比如是否搜索未跟踪文件，搜索某个特定的 tag等），如果当前目录是 git 目录，可以用 ggrep 来替代 grep</p>
<p data-source-line="1674">ggrep 是 git grep --break --heading -n 命令的缩写，第一个参数表示不同文件的搜索结果间用空格分割，便于阅读。第二个参数非常有用，它不再在每一行输出前面加上文件名，而是在所有属于同一个文件的匹配之前加上一次文件名， 这样输出结果的可读性更高，-n 表示输出行号。</p>
<p data-source-line="1676">以查找 gignore 这个命令的历史为例，先输入 ggrep gignore，得到如图所示的结果，这告诉我们它定义在 zsh-config/git.sh 这个文件的第 25 行</p>
<p data-source-line="1678"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDuQ25C7UnLshfkSJYf%252F-LDuQCk_kFzNqhCDiJTM%252Fimage.png%3Falt%3Dmedia%26token%3Ded81c54b-dedb-478f-b009-be83a082d394" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDuQ25C7UnLshfkSJYf%2F-LDuQCk_kFzNqhCDiJTM%2Fimage.png?alt=media&amp;token=ed81c54b-dedb-478f-b009-be83a082d394&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDuQ25C7UnLshfkSJYf%252F-LDuQCk_kFzNqhCDiJTM%252Fimage.png%3Falt%3Dmedia%26token%3Ded81c54b-dedb-478f-b009-be83a082d394"></p>
<p data-source-line="1680">然后输入 ggp -L 25,25:./zsh-config/git.sh，参数 —L 表示行内查找，即查找这个文件的第 25-25 行的提交记录，得到的结果如图所示：</p>
<p data-source-line="1682"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDuQ25C7UnLshfkSJYf%252F-LDuQDy84oQLp67hbySd%252Fimage.png%3Falt%3Dmedia%26token%3Db8e08818-b880-488e-b96f-250ecabb2c7b" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDuQ25C7UnLshfkSJYf%2F-LDuQDy84oQLp67hbySd%2Fimage.png?alt=media&amp;token=b8e08818-b880-488e-b96f-250ecabb2c7b&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDuQ25C7UnLshfkSJYf%252F-LDuQDy84oQLp67hbySd%252Fimage.png%3Falt%3Dmedia%26token%3Db8e08818-b880-488e-b96f-250ecabb2c7b"></p>
<p data-source-line="1684">提交的 SHA-1 值、日期、提交者等信息就完全显示出来了</p>
<h3 data-source-line="1685" id="提交区间"><a class="markdownIt-Anchor" href="#提交区间"></a>提交区间</h3>
<p data-source-line="1687">git 的提交区间指的是用两个点 A..B 或者三个点 A...B 的语法将 AB 两个提交连接起来，从而表示一系列提交。</p>
<p data-source-line="1689">这是非常容易让人产生疑惑的一个话题，主要是因为它没有固定的含义，需要根据不同的命令来记忆。本文主要结合 diff、log 这两个命令来介绍。</p>
<p data-source-line="1691">首先，假设我们基于初始提交建立了 a 和 b 两个分支，各有一次提交，如图所示。分支 a 的提交是数字，分支 b 的提交是字母。</p>
<p data-source-line="1693"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F30a0910ad63bb7fc8b2cf4dc3049388f.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/30a0910ad63bb7fc8b2cf4dc3049388f.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F30a0910ad63bb7fc8b2cf4dc3049388f.png"></p>
<h3 data-source-line="1695" id="diff-2"><a class="markdownIt-Anchor" href="#diff-2"></a>diff</h3>
<p data-source-line="1697">此时，双点语法 A..B 表示对比这 AB 两个提交的差异：</p>
<pre data-source-line="1699"><code class="hljs">git <span class="hljs-keyword">diff </span><span class="hljs-keyword">branch_a..branch_b
</span>
<span class="hljs-comment"># 直接对比两个 commit</span>
<span class="hljs-comment"># 等价于直接写空格</span>

git <span class="hljs-keyword">diff </span><span class="hljs-keyword">branch_a </span><span class="hljs-keyword">branch_b</span></code></pre><p data-source-line="1706">这个结果还是非常符合常识的，就不多解释了。</p>
<p data-source-line="1708">三点语法 A...B 则表示：AB 两次提交的共同祖先和 B 之间的 diff</p>
<pre data-source-line="1710"><code class="hljs"><span class="hljs-function"><span class="hljs-title">git</span></span> diff branch_a...branch_b</code></pre><p data-source-line="1711"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F07f5ee4c5ca7e54ae9be153cb8d8c084.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/07f5ee4c5ca7e54ae9be153cb8d8c084.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F07f5ee4c5ca7e54ae9be153cb8d8c084.png"></p>
<p data-source-line="1713">两个分支的共同祖先是第一次提交，因此上述命令其实是展示分支 b 和 b 的父提交之间的 diff。如图所示，</p>
<p data-source-line="1715"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F73cc49f25c2852b686f9bc074aff79ec.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/73cc49f25c2852b686f9bc074aff79ec.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F73cc49f25c2852b686f9bc074aff79ec.png"></p>
<p data-source-line="1717">需要注意的是，如果两次提交在同一个分支上，那么双点和三点语法的效果是一致的。</p>
<h3 data-source-line="1718" id="log-2"><a class="markdownIt-Anchor" href="#log-2"></a>log</h3>
<p data-source-line="1720">log 的双点语法 A..B 和 diff 的三点写法具有相同的含义，都表示仅在 B，但不在 A 的那些提交。如图所示：</p>
<p data-source-line="1722"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd2c899e4ac86197ce559756c8d9259ff.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/d2c899e4ac86197ce559756c8d9259ff.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd2c899e4ac86197ce559756c8d9259ff.png"></p>
<p data-source-line="1724">比如：</p>
<pre data-source-line="1726"><code class="hljs"><span class="hljs-function"><span class="hljs-title">ggp</span></span> branch_b..branch_a</code></pre><p data-source-line="1728">这个命令只会输出分支 a 的日志，如图所示：</p>
<p data-source-line="1730"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F479be3f7fd57cf902ab1b804fb6c1d1b.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/479be3f7fd57cf902ab1b804fb6c1d1b.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F479be3f7fd57cf902ab1b804fb6c1d1b.png"></p>
<p data-source-line="1732">三点语法 A...B表示的是那些只属于 A 提交，和只属于 B 提交的那些提交，如图所示：</p>
<p data-source-line="1734"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F9d5e29cb650c1c97157a1bea5ccdd315.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/9d5e29cb650c1c97157a1bea5ccdd315.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F9d5e29cb650c1c97157a1bea5ccdd315.png"></p>
<p data-source-line="1736">例如：</p>
<pre data-source-line="1738"><code class="hljs"><span class="hljs-function"><span class="hljs-title">ggp</span></span> branch_b...branch_a</code></pre><p data-source-line="1740">这个命令将单独得到分支 b 和 分支 a 上的各一次提交：</p>
<p data-source-line="1742"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fad88feae9f344cb0d6ac8ff7ae2717fe.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/ad88feae9f344cb0d6ac8ff7ae2717fe.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fad88feae9f344cb0d6ac8ff7ae2717fe.png"></p>
<p data-source-line="1744">另外需要注意的是，根据我的实践，git show 中的双点、三点表示法和 git log 是一致的，就不另外说明了。</p>
<p data-source-line="1746">最后用一张图来总结：</p>
<p data-source-line="1748"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fa8d0b787c3fdf3f5a7936a05fd619f66.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/a8d0b787c3fdf3f5a7936a05fd619f66.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fa8d0b787c3fdf3f5a7936a05fd619f66.png"></p>
<h2 data-source-line="1751" id="第-53-章-分支与-tag"><a class="markdownIt-Anchor" href="#第-53-章-分支与-tag"></a>第 5.3 章 分支与 Tag</h2>
<h3 data-source-line="1752" id="分支"><a class="markdownIt-Anchor" href="#分支"></a>分支</h3>
<h4 data-source-line="1753" id="分支的本质"><a class="markdownIt-Anchor" href="#分支的本质"></a>分支的本质</h4>
<p data-source-line="1755">分支可以简单的理解为一个指针，指向某个提交。而每个提交都记录了它的父提交，从而形成了一个链表。当某个分支上不断产生提交时，分支指向的提交就会发生改变，不断向后移动，相当于这个链表在不断延长。</p>
<h4 data-source-line="1756" id="查看分支"><a class="markdownIt-Anchor" href="#查看分支"></a>查看分支</h4>
<pre data-source-line="1758"><code class="hljs">输入 gb，它会展示所有本地分支，等价于命令 git <span class="hljs-keyword">branch, </span>输入命令 gbv 可以额外显示每个分支的最后一次提交和这个分支跟踪的远程分支，等价于命令 git <span class="hljs-keyword">branch </span>-vv
输入 gb <span class="hljs-keyword">branch_name </span>表示创建一个分支，指向当前提交，gb <span class="hljs-keyword">branch_name </span>commit 表示新建一个分支并指向某个 commit，注意这两个命令都不会切换分支。
输入 gba，查看本地和远程分支，等价于命令 git <span class="hljs-keyword">branch </span>-a，输入命令 gbr，查看远程分支，等价于命令 git <span class="hljs-keyword">branch </span>--remote</code></pre><h4 data-source-line="1762" id="删除分支"><a class="markdownIt-Anchor" href="#删除分支"></a>删除分支</h4>
<pre data-source-line="1764"><code class="hljs">输入 gbd <span class="hljs-keyword">branch_name </span>删除某个分支，等价于命令 git <span class="hljs-keyword">branch </span>-d
并非所有分支都可以通过 gbd 命令删除，可以通过 git <span class="hljs-keyword">branch </span>--merged 来查看已经合入到某个指针\(默认是 HEAD\)的分支，换句话说是可以通过这个指针回溯到的分支。这个命令也简写为 gbm
<span class="hljs-symbol">gbm</span> 列出的分支都是可以抵达的，因此可用 gbd 删除，而 gbnm 列出的则是不可达的分支，因此不能用 gbd 删除，它是 git <span class="hljs-keyword">branch </span>--no-merged 命令的简写
如果真的要强行删除，可以用 gbD 命令，它是 git <span class="hljs-keyword">branch </span>-D 的简写</code></pre><h4 data-source-line="1769" id="切换分支"><a class="markdownIt-Anchor" href="#切换分支"></a>切换分支</h4>
<pre data-source-line="1771"><code class="hljs">输入 gco branch 可以 checkout 到某个分支上，等价于命令 git checkout，注意如果有未提交的改动，请不要切换分支。
输入 gcb <span class="hljs-keyword">new</span><span class="hljs-type">_branch</span> 可以创建分支 <span class="hljs-keyword">new</span><span class="hljs-type"></span>\_branch 并切换到这个分支上，它是 git checkout -b 命令的缩写，等价于 git branch <span class="hljs-keyword">new</span><span class="hljs-type">_branch</span> 和 git checkout <span class="hljs-keyword">new</span><span class="hljs-type">_branch</span> 这两条命令</code></pre><p data-source-line="1774">有时候我们要从远程仓库检出一个新的分支，比如叫 feature 吧，有几种思路：</p>
<pre data-source-line="1776"><code class="hljs">git branch -t <span class="hljs-built_in">feature</span> <span class="hljs-built_in">origin</span>/<span class="hljs-built_in">feature</span>
git checkout -b <span class="hljs-built_in">feature</span> <span class="hljs-built_in">origin</span>/<span class="hljs-built_in">feature</span>
git checkout --<span class="hljs-built_in">track</span> <span class="hljs-built_in">origin</span>/<span class="hljs-built_in">feature</span></code></pre><p data-source-line="1780">第一种写法不太合适，因为它只会创建分支并且跟踪远程分支，并不会切换。我想一般创建分支的时候都是需要切换的，否则你创建它干嘛呢，可以等到要切换的时候再创建呐。</p>
<p data-source-line="1782">第二种写法稍微高级些，它和第一种写法一致并且可以切换分支，之前的 tips 中介绍过 gcb 后面加单个参数的含义和用法，这里第二个参数表示跟着远程分支。</p>
<p data-source-line="1784">第三中方法最简单，因为它参数少，而且功能和第二种写法一样，我给他起的别名叫 gct，对应 git checkout --track</p>
<p data-source-line="1786">如果想为当前分支设置跟踪的远程分支，输入 gtrack 即可，不需要携带参数，它会自动让当前分支跟踪远程的同名分支</p>
<h4 data-source-line="1787" id="tag"><a class="markdownIt-Anchor" href="#tag"></a>Tag</h4>
<p data-source-line="1789">标签是分支功能的子集，可以理解为不能移动的分支。前文说过，分支始终指向某个链表的开端，是可以移动的。但 Tag 始终指向某个固定的提交，不会移动。</p>
<p data-source-line="1791">使用 gco 同样可以切换到某个分支上。其他常用命令如下：</p>
<pre data-source-line="1793"><code class="hljs">使用命令 <span class="hljs-keyword">gt</span> tag_name 可以打 <span class="hljs-keyword">tag</span>，它是 git <span class="hljs-keyword">tag</span> <span class="hljs-title">命令的缩写。
使用命令 gtd</span> tag_name 可以删除本地 <span class="hljs-keyword">tag</span>，它是 git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> 命令的缩写</code></pre><h2 data-source-line="1797" id="第-54-章-代码修改"><a class="markdownIt-Anchor" href="#第-54-章-代码修改"></a>第 5.4 章 代码修改</h2>
<h3 data-source-line="1798" id="stash"><a class="markdownIt-Anchor" href="#stash"></a>Stash</h3>
<p data-source-line="1800">这个命令用来储藏当前未提交的改动，我配置了两个别名：</p>
<pre data-source-line="1802"><code class="hljs">gst：用来储藏改动，是 git stash -u 的缩写，-u 参数表示未跟踪的文件\(untracked\) 也会被储藏。
gsp ：用来复原储藏，是 git stash pop --index 的缩写，--index 表示会试图还原此前的索引状态。比如原来改动了两个文件 <span class="hljs-selector-tag">a</span> 和 b，其中文件 <span class="hljs-selector-tag">a</span> 已经被添加到暂存区（add）但 <span class="hljs-selector-tag">b</span> 没有。普通的 git stash pop 会把 <span class="hljs-selector-tag">a</span> 和 <span class="hljs-selector-tag">b</span> 都还原为未暂存状态。添加 --index 参数则会将 <span class="hljs-selector-tag">a</span> 还原为暂存状态。</code></pre><h3 data-source-line="1805" id="reset"><a class="markdownIt-Anchor" href="#reset"></a>Reset</h3>
<p data-source-line="1807">很多人可能大概知道 reset 有三种模式，很多文章上来就开始介绍这三种模式的异同，在我看来这不是一种很好的教学方式。对于不是特别了解 Git 模型的读者来说，有必要介绍一些基础知识。</p>
<p data-source-line="1809">首先，在 Git 的思维中，它会管理三块不同的区域，工作区、暂存区和历史区。假设我们 clone
下来一个新的项目，此时三个区域内的文件内容是一模一样的。此时如果输入 git status命令会没有任何输出。注意，这个命令并不会记录改动，而是时刻比较 工作区和暂存区 以及 暂存区和历史区 之间的差异，从而得出待暂存和待提交的文件列表。</p>
<p data-source-line="1812">当我们开始写代码时，文件发生了变动，这其实是更改了工作区中的代码，但暂存区和历史区是一致的，因此此时 git status 会显示有一些文件需要暂存，但不会提示有文件需要提交。使用
git add 命令后，它会把改动的文件和要提交的部分拷贝到暂存区中，此时工作区和暂存区是一致的，但暂存区和历史区的文件不一样，所以不会再显示有文件需要暂存，只会提示有文件要提交。输入 git commit 以后三个区域内的内容又保持一致了，因此 git status 不会再有任何输出。</p>
<p data-source-line="1815">在阅读 reset 的用法前，请务必确保你真的读懂了之前的两段话，否则请读到明白为止。</p>
<p data-source-line="1817">首先，reset 有两种用法，它的第一个参数是提交的 SHA-1，第二个参数如果不写则是整体重置，否则只重置单个文件，我们先介绍整体重置的情况。</p>
<p data-source-line="1819">此时，HEAD 指针一定会移动到指定的那次提交上，也就是说历史区会与指定的那次提交保持一致。如果是用 reset --soft 参数，那么重置就到此为止了。由于只有历史区被重置了，暂存区还没有发生变化，所以这个命令的作用相当于撤销了 commit，并且把他们都放入暂存区。</p>
<p data-source-line="1821">接下来，reset 命令会试图把暂存区也和指定的提交保持一致。因此重置完成后，暂存区和历史区保持一致，但工作区和暂存区会出现大量的不一致，所以 git status 命令会提示我们有很多文件需要暂存(add)。如果是用 reset --mixed 参数或者不加任何参数，重置就会到此为止。可见这个命令相当于撤销了 git add 和 git commit 操作。</p>
<p data-source-line="1823">最后，reset 命令还有一个参数是 --hard，它会试图把工作区也和指定的提交保持一致。这个命令是不安全的，如果工作区内的文件还没有提交，它就会丢失。提交过的文件可以用 git reflog 找回。重置结束后，三个区域内的文件都和指定的提交保持一致，git status 不会有任何输出。</p>
<p data-source-line="1825">总结一下，git reset 在重置版本时会做三件事：</p>
<pre data-source-line="1827"><code class="hljs">让历史区与指定的提交保持一致，如果是 <span class="hljs-comment">--soft参数则到此为止</span>
让暂存区和历史区与指定的提交保持一致，如果不加参数或者是 <span class="hljs-comment">--mixed 参数则到此为止</span>
让工作区、暂存区和历史区都与指定的提交保持一致。如果是 <span class="hljs-comment">--hard 参数就会走到这一步</span></code></pre><p data-source-line="1831"><strong>注意，我们要记的是 reset 命令的本质，而不是它的外在表现。理解了它会做什么，就很容易预测这么做的结果</strong></p>
<p data-source-line="1833">至于 reset 的另一个用法：重置文件，和上述规则类似，只是它不会改变历史区，自然也就不存在 --soft 参数，其他两个参数的用法和规则是完全一致的，只不过是对文件生效。</p>
<p data-source-line="1835">在实际使用中，我配置了这三个命令：</p>
<pre data-source-line="1837"><code class="hljs">grh：让工作区、暂存区和历史区都与指定的提交保持一致，可以理解为撤销所有改动，是命令 git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 的简写</span>
grm：让暂存区和历史区与指定的提交保持一致，可以理解为撤销 git <span class="hljs-keyword">add</span>，是命令 git <span class="hljs-keyword">reset</span>的缩写，通常我会用 grm file_name 来撤销对某个文件的暂存
grs：让历史区与指定的提交保持一致，可以理解为撤销 git <span class="hljs-keyword">commit</span>，是命令 git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft 的缩写</span></code></pre><h3 data-source-line="1841" id="checkout"><a class="markdownIt-Anchor" href="#checkout"></a>Checkout</h3>
<p data-source-line="1843">除了可以在分支和 tag 间进行切换外，如果 checkout 后面加上文件名，可以将尚未暂存的文件重置为初始状态。</p>
<p data-source-line="1845">因此，这个命令也可以理解为仅对工作区生效的 git reset --hard，这是一个不可挽回的操作，请谨慎执行。</p>
<h2 data-source-line="1848" id="第-55-章-代码同步"><a class="markdownIt-Anchor" href="#第-55-章-代码同步"></a>第 5.5 章 代码同步</h2>
<h3 data-source-line="1849" id="fetch"><a class="markdownIt-Anchor" href="#fetch"></a>Fetch</h3>
<p data-source-line="1851">fetch 是最简单的操作，它将远程仓库的代码、 分支和 tag 都下载到本地。有些 GUI 工具会定期自动执行 fetch。</p>
<p data-source-line="1853">注意，如果仅仅是 fetch 代码，并不会改变本地的代码，仅仅是预先下载了远程仓库的变动而已。直到我们进行 rebase、merge、checkout、reset 等操作时，才会改动本地代码。</p>
<h3 data-source-line="1854" id="rebase-or-merge"><a class="markdownIt-Anchor" href="#rebase-or-merge"></a>Rebase or Merge</h3>
<p data-source-line="1856">rebase 和 merge 分别是合并代码的两种操作。</p>
<p data-source-line="1858">rebase 是变基，也就是改变某次提交的父提交。假设当前处于分支 branch_a 并执行：</p>
<pre data-source-line="1860"><code class="hljs"><span class="hljs-attribute">git</span> rebase branch_b</code></pre><p data-source-line="1862">本质上是找到 branch_a 和 branch_b的公共祖先，然后将 branch_a 到这个公共祖先中的每一次提交，依次变基到 branch_b 上。</p>
<p data-source-line="1864"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDqLkI3JdIXRXfIsyvs%252F-LDqPoDIZkWq1uha51TH%252FRebasing.gif%3Falt%3Dmedia%26token%3D3ab4823a-07a0-46aa-bc2a-055ce47a93e6" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDqLkI3JdIXRXfIsyvs%2F-LDqPoDIZkWq1uha51TH%2FRebasing.gif?alt=media&amp;token=3ab4823a-07a0-46aa-bc2a-055ce47a93e6&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDqLkI3JdIXRXfIsyvs%252F-LDqPoDIZkWq1uha51TH%252FRebasing.gif%3Falt%3Dmedia%26token%3D3ab4823a-07a0-46aa-bc2a-055ce47a93e6"></p>
<p data-source-line="1866">同样是上面的情况，使用merge ：</p>
<pre data-source-line="1868"><code class="hljs">git <span class="hljs-keyword">merge</span> branch_a</code></pre><p data-source-line="1870">则会将 branch_a 到公共祖先之间的提交压缩成一次新的提交，附加在 branch_b 的后面。</p>
<p data-source-line="1872">关于选择 merge 还是 rebase，一般没有明确的要求。前者忠实的保留了每次提交的真实情况，但是多人开发时频繁 merge 容易导致时间线爆炸，影响阅读。rebase 的优点在于它创造出更加优雅的提交记录，缺点则是破坏了真实的提交记录。</p>
<p data-source-line="1874">但假设我们有一个主分支 dev，还有一个开发分支 feature ，两者都提交了上百次代码，现在想把开发分支合入主分支，那么大概率应该使用 merge。一方面这样的合并次数很少，不会造成时间线爆炸，反倒是真实的保留了 feature 分支的提交记录，最重要的是如此庞大的两个分支合并一定会带来大量冲突。 merge 会自动把所有提交压缩成一个，只要解决一次冲突就行，但 rebase 的次数将会达到上百次，会出现大量不必要的冲突。</p>
<p data-source-line="1876">举个很简单的例子，假设提交 a 和 b 是两个互逆的操作，那么在 merge 就互相抵消了，但如果使用 rebase，就需要解决两次冲突。</p>
<p data-source-line="1878">但如果只是想从远程仓库获取代码，并且更新本地的代码，此时就更推荐 rebase 了，我配置了快捷键 gsfrs，它的完整定义是：</p>
<pre data-source-line="1880"><code class="hljs"><span class="hljs-built_in">alias</span> gsfrs=<span class="hljs-string">'git stash;git fetch;git rebase;git stash pop;'</span></code></pre><h3 data-source-line="1882" id="交互式-rebase"><a class="markdownIt-Anchor" href="#交互式-rebase"></a>交互式 Rebase</h3>
<p data-source-line="1884">对于已经存在但还没有推送到远程的提交记录，我们可以使用 rebase -i 去编辑他们。假设我们想修改最近三次提交，可以输入 gri head~3，它是完整写法是：</p>
<pre data-source-line="1886"><code class="hljs">git rebase -<span class="hljs-selector-tag">i</span> head~<span class="hljs-number">3</span></code></pre><p data-source-line="1888">这个命令会展示出最近的三次提交，最老的提交在最上面，最新的提交在最下面，这是因为 git 会按照从旧到新的顺序编辑这些提交。展示的格式如下：</p>
<pre data-source-line="1890"><code class="hljs"><span class="hljs-attribute">pick</span> commit_id commit_message</code></pre><p data-source-line="1892">我们可以随意调整这三行的顺序，相当于改变提交的顺序。如果把单词 pick 改成 reword 或 r，就可以修改提交记录。</p>
<p data-source-line="1894">git 还支持以下关键字：</p>
<pre data-source-line="1896"><code class="hljs"><span class="hljs-keyword">edit</span> 或 <span class="hljs-keyword">e</span>：编辑此次提交
<span class="hljs-keyword">drop</span> 或 d：删除此次提交
<span class="hljs-keyword">fix</span> 或 <span class="hljs-keyword">f</span>：将此次提交与上次提交合并</code></pre><h3 data-source-line="1900" id="pull"><a class="markdownIt-Anchor" href="#pull"></a>Pull</h3>
<p data-source-line="1902">pull 可以理解为一个语法糖，因为它等价于 fetch + merge，前文已经说过日常开发时并不推荐使用 merge，只有在偶尔分支合并时才应该使用，因此 pull 也应该慎用。</p>
<h3 data-source-line="1903" id="commit"><a class="markdownIt-Anchor" href="#commit"></a>Commit</h3>
<p data-source-line="1905">前文说过通过交互式 rebase 可以修改历史提交记录，但如果只想修改上一次提交的信息，可以使用更简单的 gca 命令，它的完整写法是：</p>
<pre data-source-line="1907"><code class="hljs">git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span></code></pre><p data-source-line="1909">然后编辑 commit_message 并退出即可。</p>
<p data-source-line="1911">我们都知道提交代码前，需要先将改动的文件暂存，然后再提交。但如果我们想提交所有未暂存的文件，其实还有更快速的方法：gcam，它的完整写法是：</p>
<pre data-source-line="1913"><code class="hljs">git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--all -m</span>
# 实际上等价于
git <span class="hljs-keyword">add</span> . &amp;&amp; git <span class="hljs-keyword">commit</span> -m</code></pre><h2 data-source-line="1918" id="第-56-章-解决冲突"><a class="markdownIt-Anchor" href="#第-56-章-解决冲突"></a>第 5.6 章 解决冲突</h2>
<h3 data-source-line="1919" id="构造冲突"><a class="markdownIt-Anchor" href="#构造冲突"></a>构造冲突</h3>
<p data-source-line="1921">本文主要通过一个简单的 Demo 来演示如何在 Git 中解决冲突，以及相关名词的基本概念。</p>
<p data-source-line="1923">首先我们编辑一个名为 begin 的文件：</p>
<pre data-source-line="1925"><code class="hljs">This <span class="hljs-keyword">is</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">line</span></code></pre><p data-source-line="1927">然后在分支 a 上增加两行，用加号标记出来：</p>
<pre data-source-line="1929"><code class="hljs">This <span class="hljs-keyword">is</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">line</span>
+This <span class="hljs-keyword">is</span> <span class="hljs-number">2</span>nd <span class="hljs-built_in">line</span>
+This <span class="hljs-keyword">is</span> <span class="hljs-number">3</span>rd <span class="hljs-built_in">line</span></code></pre><p data-source-line="1933">再在分支 b 上增加两行，用加号标记出来：</p>
<pre data-source-line="1935"><code class="hljs">This <span class="hljs-keyword">is</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">line</span>
+This <span class="hljs-keyword">is</span> second <span class="hljs-built_in">line</span>
+This <span class="hljs-keyword">is</span> third <span class="hljs-built_in">line</span></code></pre><p data-source-line="1939">当我们想把分支 a 变基（rebase）到分支 b 上时，冲突必然会出现，因为两个分支修改了相同的行，git 不知道怎么处理了。此时有如下输出：</p>
<p data-source-line="1941"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd57ae907097fa2b0c2f1d42fb82a8926.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/d57ae907097fa2b0c2f1d42fb82a8926.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd57ae907097fa2b0c2f1d42fb82a8926.png"></p>
<p data-source-line="1943">可以看到文件被标记为了 UU。U 的意思表示 updated but unmerged，两个 U 则是说明两个分支都做了修改，但还没有合并。出现 UU 基本上都意味着发生了冲突。</p>
<h3 data-source-line="1944" id="放弃合并"><a class="markdownIt-Anchor" href="#放弃合并"></a>放弃合并</h3>
<p data-source-line="1946">如果对解决方式没有信心，可以暂时先放弃合并，输入 git rebase --abort 即可。如果当初选择的是 merge 两个分支，那么将是 git merge --abort。</p>
<p data-source-line="1948">这个命令能回退到合并分支前，但它无法在正确处理工作目录中的变动。也就是说，在开始合并之前，务必确保自己的工作目录是干净的。</p>
<p data-source-line="1950">不过在相当多的场合，Git 会自动做出提醒。比如当你的工作目录有改动时，直接就无法 rebase：</p>
<p data-source-line="1952"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F86758aa7f1d645274abbae2ac524fcb0.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/86758aa7f1d645274abbae2ac524fcb0.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F86758aa7f1d645274abbae2ac524fcb0.png"></p>
<p data-source-line="1954">如果 merge 会影响到工作目录的改动，Git 也会禁止你 merge，比如我随便修改 begin 的最后一行，再执行 merge 操作会得到如下错误：</p>
<p data-source-line="1956"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fbdd3ebb05b3e413ef7f632ac8c861241.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/bdd3ebb05b3e413ef7f632ac8c861241.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fbdd3ebb05b3e413ef7f632ac8c861241.png"></p>
<p data-source-line="1958">所以请牢记第一点： 在 rebase 或者 merge 之前，务必确保你的工作目录是干净的</p>
<h3 data-source-line="1959" id="冲突描述"><a class="markdownIt-Anchor" href="#冲突描述"></a>冲突描述</h3>
<p data-source-line="1961">我们来看一下冲突的文件长什么样，注意我们是在分支 a 上 rebase 到分支 b：</p>
<p data-source-line="1963"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fea1d3e48442130b0340c96dfcc47f2c0.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/ea1d3e48442130b0340c96dfcc47f2c0.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fea1d3e48442130b0340c96dfcc47f2c0.png"></p>
<p data-source-line="1965">可以看到两个提交之间用 ===== 来分割，上面的部分有 &lt;&lt;&lt;&lt; 这个标记，后面跟着一串 SHA1 值，它其实就是分支 b 指向的那次提交。</p>
<p data-source-line="1967">下面的部分写得很明确，是分支 a 指向的那次提交内容。</p>
<p data-source-line="1969">如果我们在分支 b 上使用 git merga branch_a，得到的效果将会是：</p>
<p data-source-line="1971"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F03fc21bfc2e0b625bd49242e7c53ffa0.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/03fc21bfc2e0b625bd49242e7c53ffa0.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F03fc21bfc2e0b625bd49242e7c53ffa0.png"></p>
<p data-source-line="1973">可见，除了对分支 b 的描述不太一样以外，冲突的内容是一样的。都是上面是 b 分支的改动，下面是 a 分支的改动。</p>
<p data-source-line="1975">于是得出第二个结论：<strong>冲突被多个等号分割为两部分，上面是当前的改动，而下面是将要合入的改动</strong>。</p>
<h3 data-source-line="1976" id="冲突文件的原理"><a class="markdownIt-Anchor" href="#冲突文件的原理"></a>冲突文件的原理</h3>
<p data-source-line="1978">运行命令 git ls-files -u，其中 -u 参数用来展示还没有合并的改动：</p>
<p data-source-line="1980"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fb815cc4bac62e8b638204e994cb3a011.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/b815cc4bac62e8b638204e994cb3a011.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fb815cc4bac62e8b638204e994cb3a011.png"></p>
<p data-source-line="1982">可见当前存在 3 份 begin 文件，我们可以这样查看第一个文件：</p>
<pre data-source-line="1984"><code class="hljs"><span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">show</span> <span class="hljs-selector-pseudo">:1</span><span class="hljs-selector-pseudo">:begin</span></code></pre><p data-source-line="1986"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fa471e8b3fa60bc808a59a033624f6a67.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/a471e8b3fa60bc808a59a033624f6a67.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fa471e8b3fa60bc808a59a033624f6a67.png"></p>
<p data-source-line="1988">第二个文件：</p>
<pre data-source-line="1990"><code class="hljs"><span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">show</span> <span class="hljs-selector-pseudo">:2</span><span class="hljs-selector-pseudo">:begin</span></code></pre><p data-source-line="1992"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F3d8b537f38b243ea953758cfae2b9074.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/3d8b537f38b243ea953758cfae2b9074.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F3d8b537f38b243ea953758cfae2b9074.png"></p>
<p data-source-line="1994">这个文件又被称为 ours，如果以这个文件的改动为准，将会得到等号上面的那部分结果。可以用 git diff --ours 来验证。下图表示当前冲突相对于 ours 的变化（多了下面的那部分）。</p>
<p data-source-line="1996"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fa5617ec71573eb0235fffaf3d2fdb793.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/a5617ec71573eb0235fffaf3d2fdb793.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fa5617ec71573eb0235fffaf3d2fdb793.png"></p>
<p data-source-line="1998">第三个文件：</p>
<pre data-source-line="2000"><code class="hljs"><span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">show</span> <span class="hljs-selector-pseudo">:3</span><span class="hljs-selector-pseudo">:begin</span></code></pre><p data-source-line="2003"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fe3e6c3c3b70155467634fd82eff87e43.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/e3e6c3c3b70155467634fd82eff87e43.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fe3e6c3c3b70155467634fd82eff87e43.png"></p>
<p data-source-line="2005">这个文件又被称为 theirs，如果以这个文件的改动为准，将会得到等号下面的那部分结果，可以用 git diff --theirs 来验证。下图表示当前冲突相对于 theirs 的变化（多了上面的那部分）。</p>
<p data-source-line="2007"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd59e08420414a686aa9d53a9ac913c79.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/d59e08420414a686aa9d53a9ac913c79.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd59e08420414a686aa9d53a9ac913c79.png"></p>
<p data-source-line="2009">于是得出第三个结论：<strong>“我们的”指的是已有的改动，也就是等号上面部分的改动，“他们的”则是将要合入的改动，也就是等号下面部分的改动。</strong></p>
<p data-source-line="2011">比如将在分支 b 上执行 merge a 或者在分支 a 上执行 rebase b，此时分支 a 的改动被叫做 ours，而分支 b 的改动则被称为 theirs。</p>
<p data-source-line="2013">我个人建议这样记忆**：已有的分支是原住民，也就是“我们的”，将要合入的代码是入侵者，也就是 “他们的”。**</p>
<h3 data-source-line="2014" id="解决冲突"><a class="markdownIt-Anchor" href="#解决冲突"></a>解决冲突</h3>
<p data-source-line="2016">最简单的方式就是只是用某一方的改动来解决冲突，比如我认为分支 a 的改动是无效的，分支 b 的改动才是合理的，也就以 “我们的(ours)” 改动为准，忽略将要合入的代码，可以执行命令：</p>
<pre data-source-line="2018"><code class="hljs">git checkout --ours begin
git <span class="hljs-keyword">add</span><span class="bash"> begin
</span>git commit
<span class="hljs-comment"># 注意不用加 -m 选项，git 会默认生成一个 merge 的 message</span></code></pre><p data-source-line="2024"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F75082ac94229bc97d3258fd8e7ce422b.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/75082ac94229bc97d3258fd8e7ce422b.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F75082ac94229bc97d3258fd8e7ce422b.png"></p>
<p data-source-line="2026">对应到之前的 diff 输出中来，如果你只想保留等号上面的部分，可以用 --ours 参数，否则使用 --theirs 参数。</p>
<h3 data-source-line="2027" id="撤销合并"><a class="markdownIt-Anchor" href="#撤销合并"></a>撤销合并</h3>
<p data-source-line="2029">先讨论 merge 的情况，此时分之关系如图所示：</p>
<p data-source-line="2031">如果代码还没有推送到远程仓库，只要 reset --hard 到上一次提交即可：</p>
<pre data-source-line="2033"><code class="hljs">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD~</span></code></pre><p data-source-line="2035">此时效果如图所示：</p>
<p data-source-line="2037"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fa902fa66a7349d7dc5de955d5123f11f.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/a902fa66a7349d7dc5de955d5123f11f.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fa902fa66a7349d7dc5de955d5123f11f.png"></p>
<p data-source-line="2039">如果已经推送到远程仓库，这样 reset 就不行了，此时可以用 revert 命令。我将在后续的文章中做详细的介绍。</p>
<h2 data-source-line="2043" id="第-57-章-git-核心原理"><a class="markdownIt-Anchor" href="#第-57-章-git-核心原理"></a>第 5.7 章 Git 核心原理</h2>
<p data-source-line="2045">假设我们有两个分支，a 和 b，它们的提交都有一个相同的父提交（master 指向的那次提交）。如图所示：</p>
<p data-source-line="2047"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fee182be2c2bb3990544575a3a6e7dcfb.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/ee182be2c2bb3990544575a3a6e7dcfb.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fee182be2c2bb3990544575a3a6e7dcfb.png"></p>
<p data-source-line="2049">现在我们在分支 b 上，然后 rabase 到分支 a 上。如图所示：</p>
<p data-source-line="2051"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F47e1df3203b276353d17e5102ed3d640.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/47e1df3203b276353d17e5102ed3d640.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F47e1df3203b276353d17e5102ed3d640.png"></p>
<p data-source-line="2053">平时开发中经常遇到这种情况，假设分支 a 和 b 是两个独立的 feature 分支，但是不小心被我们错误的 rebase 了。现在相当于两个 feature 分支中原本独立的业务被揉起来了，当然是我们不想看到的结果，那么如何撤销呢？</p>
<p data-source-line="2055">一种方案是利用 reflog 命令。</p>
<h3 data-source-line="2056" id="利用-reflog-撤销变基"><a class="markdownIt-Anchor" href="#利用-reflog-撤销变基"></a>利用 reflog 撤销变基</h3>
<p data-source-line="2058">我们先不考虑原理，直接上解决方案，首先输入 git reflog，你会看到如下图所示的日志：</p>
<p data-source-line="2060"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F657ea37b9ffa116f5d1615b021cbf2e8.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/657ea37b9ffa116f5d1615b021cbf2e8.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F657ea37b9ffa116f5d1615b021cbf2e8.png"></p>
<p data-source-line="2062">最后的输出其实是最早的操作，我们逐条分析下：</p>
<pre data-source-line="2064"><code class="hljs">HEAD@{<span class="hljs-number">8</span>}: 这里我们创建了初始的提交
HEAD@{<span class="hljs-number">7</span>}：检出了分支 <span class="hljs-selector-tag">a</span>
HEAD@{<span class="hljs-number">6</span>}：在分支 <span class="hljs-selector-tag">a</span> 上做了一次提交，注意 master 分支没有变动
HEAD@{<span class="hljs-number">5</span>}：从分支 <span class="hljs-selector-tag">a</span> 回到分支 master，相当于向后退了一次
HEAD@{<span class="hljs-number">4</span>}：检出了分支 <span class="hljs-selector-tag">b</span>
HEAD@{<span class="hljs-number">3</span>}：在分支 <span class="hljs-selector-tag">b</span> 上做了一次提交，注意 master 分支没有变动
HEAD@{<span class="hljs-number">2</span>}：这一步开始变基到分支 a，首先切换到分支 <span class="hljs-selector-tag">a</span> 上
HEAD@{<span class="hljs-number">1</span>}：把分支 <span class="hljs-selector-tag">b</span> 对应的那次提交变基到分支 <span class="hljs-selector-tag">a</span> 上
HEAD@{<span class="hljs-number">0</span>}：变基结束，因为是在 <span class="hljs-selector-tag">b</span> 上发起的变基，所以最后还切回分支 b</code></pre><p data-source-line="2074">如果我们想撤销此次 rebase，只要输入以下命令就可以了：</p>
<pre data-source-line="2076"><code class="hljs">git <span class="hljs-keyword">reset</span> --hard HEAD@{3}</code></pre><p data-source-line="2078">此时再看，已经“恢复”到 rebase 前的状态了。的是不是感觉很神奇呢，先别着急，后面会介绍这么做的原理。</p>
<h3 data-source-line="2079" id="git-工作原理简介-sectiongit"><a class="markdownIt-Anchor" href="#git-工作原理简介-sectiongit"></a>git 工作原理简介 {#sectiongit}</h3>
<p data-source-line="2081">为了搞懂 git 是如何工作的，以及这些命令背后的原理，我想有必要对 git 的模型有基础的了解。</p>
<p data-source-line="2083">首先，每一个 git 目录都有一个名为 .git 的隐藏目录，关于 git 的一切都存储于这个目录里面（全局配置除外）。这个目录里面有一些子目录和文件，文件其实不重要，都是一些配置信息，后面会介绍其中的 HEAD 文件。子目录有以下几个：</p>
<pre data-source-line="2085"><code class="hljs">info：这个目录不重要，里面有一个 exclude 文件和 <span class="hljs-selector-class">.gitignore</span> 文件的作用相似，区别是这个文件不会被纳入版本控制，所以可以做一些个人配置。
hooks：这个目录很容易理解， 主要用来放一些 git 钩子，在指定任务触发前后做一些自定义的配置，这是另外一个单独的话题，本文不会具体介绍。
objects：用于存放所有 git 中的对象，下面单独介绍。
logs：用于记录各个分支的移动情况，下面单独介绍。
refs：用于记录所有的引用，下面单独介绍。</code></pre><p data-source-line="2091">本文主要会介绍后面三个文件夹的作用。</p>
<h3 data-source-line="2092" id="git-对象"><a class="markdownIt-Anchor" href="#git-对象"></a>git 对象</h3>
<p data-source-line="2094">git 是面向对象的！
git 是面向对象的！
git 是面向对象的！</p>
<p data-source-line="2098">没错，git 是面向对象的，而且很多东西都是对象。我举个简单的例子，来帮助大家理解这个概念。假设我们在一个空仓库里，编辑了 2 个文件，然后提交。此时都会有那些对象呢？</p>
<p data-source-line="2100">首先会有两个数据对象，每个文件都对应一个数据对象。当文件被修改时，即使是新增了一个字母，也会生成一个新的数据对象。</p>
<p data-source-line="2102">其次，会有一个树对象用来维护一系列的数据对象，叫树对象的原因是它持有的不仅可以是数据对象，还可以是另一个树对象。比如某次提交了两个文件和一个文件夹，那么树对象里面就有三个对象，两个是数据对象，文件夹则用另一个树对象表示。这样递归下去就可以表示任意层次的文件了。</p>
<p data-source-line="2104">最后则是提交对象，每个提交对象都有一个树对象，用来表示某一次提交所涉及的文件。除此以外，每一个提交还有自己的父提交，指向上一次提交的对象。当然，提交对象还会包含提交时间、提交者姓名、邮箱等辅助信息，就不多说了。</p>
<p data-source-line="2106">假设我们只有一个分支，以上知识点就足够解释 git 的提交历史是如何计算的了。它并不存储完整的提交历史，而是通过父提交的对象不断向前查找，得出完整的历史。</p>
<p data-source-line="2108">注意开头那张图片，分支 b 指向的提交是 9cbb015，不妨来看下它是何方神圣：</p>
<pre data-source-line="2110"><code class="hljs">git <span class="hljs-keyword">cat</span>-<span class="hljs-keyword">file</span> -t 9cbb015
git <span class="hljs-keyword">cat</span>-<span class="hljs-keyword">file</span> -p 9cbb015</code></pre><p data-source-line="2113">这里我们使用 cat-file 命令，其中 -t 参数打印对象的类型，-p 参数会智能识别类型，并打印其中的内容。输出结果如图所示：</p>
<p data-source-line="2115"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd6d696a50b7858b7155e6d61a8121bb6.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/d6d696a50b7858b7155e6d61a8121bb6.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd6d696a50b7858b7155e6d61a8121bb6.png"></p>
<p data-source-line="2117">可见 9cbb015 是一个提交对象，里面包含了树对象、父提交对象和各种配置信息。我们可以再打印树对象看看：</p>
<p data-source-line="2119"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd416d3f25ebe98b1fd2ffa91e9c204ce.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/d416d3f25ebe98b1fd2ffa91e9c204ce.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fd416d3f25ebe98b1fd2ffa91e9c204ce.png"></p>
<p data-source-line="2121">这表示本次提交只修改了 begin 这个文件，并且输出了 begin 这个文件对于的数据对象。</p>
<h3 data-source-line="2122" id="git-引用"><a class="markdownIt-Anchor" href="#git-引用"></a>git 引用</h3>
<p data-source-line="2124">既然 git 是面向对象的，那么有没有指针呢？还真是有的，分支和标签都是指向提交对象的指针。这一点可以验证：</p>
<pre data-source-line="2126"><code class="hljs">cat .git<span class="hljs-regexp">/refs/</span>heads<span class="hljs-regexp">/a</span></code></pre><p data-source-line="2128">所有的本地分支都存储在 git/refs/heads 目录下，每一个分支对应一个文件，文件的内容如图所示：</p>
<p data-source-line="2130">可见，4a3a88d 刚好是本文第一张图中分支 a 所指向的提交。</p>
<p data-source-line="2132">我们已经搞明白了 git 分支的秘密，现在有了所有分支的记录，又有了每次提交的父提交对象，就能够得出像 SourceTree 或者文章开头第一张图那样的提交状态了。</p>
<p data-source-line="2134">至于标签，它其实也是一种引用，可以理解为不能移动的分支。只能永远指向某个固定的提交。</p>
<p data-source-line="2136">最后一个比较特殊的引用是 HEAD，它可以理解为指针的指针，为了证明这一点，我们看看 .git/HEAD 文件：</p>
<p data-source-line="2138">它的内容记录了当前指向哪个分支，refs/heads/b 其实是一个文件，这个文件的内容是分支 b 指向的那个提交对象。理解这一点非常重要，否则你会无法理解 checkout 和 reset的区别。</p>
<p data-source-line="2140">这两个命令都会改变 HEAD 的指向，区别是 checkout 不改变 HEAD 指向的分支的指向，而 reset 会。举个例子， 在分支 b 上执行以下两个命令都会让 HEAD 指向 4a3a88d 这次提交（分支 a 指向的提交）：</p>
<pre data-source-line="2142"><code class="hljs">git checkout <span class="hljs-keyword">a</span>
git reset <span class="hljs-comment">--hard a</span></code></pre><p data-source-line="2145">但 checkout 仅改变 HEAD 的指向，不会改变分支 b 的指向。而 reset 不仅会改变 HEAD 的指向，还因为 HEAD 指向分支 b，就把 b 也指向 4a3a88d 这次提交。</p>
<h3 data-source-line="2146" id="git-日志"><a class="markdownIt-Anchor" href="#git-日志"></a>git 日志</h3>
<p data-source-line="2148">在 .git/logs 目录中，有一个文件夹和一个 HEAD 文件，每当 HEAD 引用改变了指向的位置，就会在 .git/logs/HEAD 中添加了一个记录。而 .git/logs/refs/heads 这个目录中则有多个文件，每个文件对应一个分支，记录了这个分支 的指向位置发生改变的情况。</p>
<p data-source-line="2150">当我们执行 git reflog 的时候，其实就是读取了 .git/logs/HEAD 这个文件。</p>
<p data-source-line="2152"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fecde8541da6dbf0e35b472eddc15ec92.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/ecde8541da6dbf0e35b472eddc15ec92.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2Fecde8541da6dbf0e35b472eddc15ec92.png"></p>
<h3 data-source-line="2154" id="撤销-rebase-的原理"><a class="markdownIt-Anchor" href="#撤销-rebase-的原理"></a>撤销 rebase 的原理</h3>
<p data-source-line="2156">首先我们要排除一个误区，那就是 git 会维护每次提交的提交对象、树对象和数据对象，但并不会维护每次提交时，各个分支的指向。在介绍分支的那一节中我们已经看到，分支仅仅是一个保留了提交对象的文件而已，并不记录历史信息。即使在上一节中，我们知道分支的变化信息会被记录下来，但也不会和某个提交对象绑定。</p>
<p data-source-line="2158">也就是说，git 中并不存在某次提交时的分支快照</p>
<p data-source-line="2160">那么我们是如何通过 reset 来撤销 rebase 的呢，这里还要澄清另一个事实。前文曾经说过，某个时刻下你通过 SourceTree 或者 git log 看到的分支状态，其实是由所有分支的列表、每个分支所指向的提交，和每个提交的父提交共同绘制出来的。</p>
<p data-source-line="2162">首先 git/refs/heads 下的文件告诉我们有多少分支，每个文件的内容告诉我们这个分支指向那个提交，有了这个提交不断向前追溯就绘制出了这个分支的提交历史。所有分子的提交历史也就组成了我们看到的状态。</p>
<p data-source-line="2164">但我们要明确：不是所有提交对象都能看到的，举个例子如果我们把某个分支向前移一次提交，那个分支的提交线就会少一个节点，如果没有别的提交线包含这个节点，这个节点就看不到了。</p>
<p data-source-line="2166">所以在 rebase 完成后，我们以为看到了下面这样的提交线：</p>
<pre data-source-line="2168"><code class="hljs"><span class="hljs-string">df0f2c5(master)</span> <span class="hljs-meta">---</span> <span class="hljs-number">4</span><span class="hljs-string">a3a88d(a)</span> <span class="hljs-meta">---</span> <span class="hljs-number">9</span><span class="hljs-string">cbb015(b)</span></code></pre><p data-source-line="2170">实际上是这样的：</p>
<pre data-source-line="2172"><code class="hljs"><span class="hljs-string">df0f2c5(master)</span> <span class="hljs-meta">---</span> <span class="hljs-number">4</span><span class="hljs-string">a3a88d(a)</span> <span class="hljs-meta">---</span> <span class="hljs-number">9</span><span class="hljs-string">d0618e(b)</span>
   <span class="hljs-string">|
9cbb015</span></code></pre><p data-source-line="2176">master 分支上依然有分叉，原来 9cbb015 这次提交依然存在，只不过没有分支的提交线包含它，所以无法看到而已。但是通过 reflog，我们可以找回 HEAD 头的每一次移动，所以能看到这次提交。</p>
<p data-source-line="2178">当我们执行这个命令时：</p>
<pre data-source-line="2180"><code class="hljs">git <span class="hljs-keyword">reset</span> --hard HEAD@{3}</code></pre><p data-source-line="2182">再看一次 reflog 的输出：</p>
<p data-source-line="2184"><img data-src="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F657ea37b9ffa116f5d1615b021cbf2e8.png" alt="image" src="https://diycode.b0.upaiyun.com/photo/2018/657ea37b9ffa116f5d1615b021cbf2e8.png?ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fdiycode.b0.upaiyun.com%2Fphoto%2F2018%2F657ea37b9ffa116f5d1615b021cbf2e8.png"></p>
<p data-source-line="2186">HEAD@{3} 其实是它左侧 9cbb015 这次提交的缩写，所以上述命令等价于：</p>
<pre data-source-line="2188"><code class="hljs">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 9cbb015</span></code></pre><p data-source-line="2190">前文说过，reset 不仅会移动 HEAD，还会移动 HEAD 所指向的分支，所以这个命令的执行结果就是让 HEAD 和分支 b 同时指向 9cbb015 这个提交，看起来像是撤销了 rebase。</p>
<p data-source-line="2192">但别忘了，分支 a 的上面还是有一次提交的，9d0618e 这次提交仅仅是没有分支指向它，所以不显示而已。但它真实的存在着，<strong>严格意义上来说，我们并没有真正的撤销此次 rebase</strong>。</p>
<h1 data-source-line="2196" id="第-6-章-终极武器-zsh"><a class="markdownIt-Anchor" href="#第-6-章-终极武器-zsh"></a>第 6 章 终极武器 Zsh</h1>
<p data-source-line="2198">Shell 是一个非常庞大的话题，它的学习路线和普通的编程语言不一致，使用场景在很多人看了也不多。但其实 Shell 是非常强大的胶水语言，能把其它各个模块和系统很好的串联起来，同时由于 shell 非常底层，更加接近操作系统，所以非常用来和系统的软硬件生态打交道。</p>
<p data-source-line="2200">与单纯的研究 shell 语法，和系统、运维开发不同的是，我更多的是希望降低 shell 的学习门槛，坚持实用主义，把那些能够提高日常开发效率的知识介绍给读者。在掌握这些基本原理后，读者就可以根据自己的实际情况进行定制了。本章主要分为三个阶段：</p>
<p data-source-line="2202">首先会介绍最简单，但是最容易被忽视的，shell 脚本的基本概念和模型。如果不了解 shell 脚本是怎么被执行的，虽然不影响使用，但在理解更深一层的概念时就会遇到困难。</p>
<p data-source-line="2204">接下来是 shell 的基本语法，因为 shell 的写法比较多，同一个功能有多种方式完成，对新人不太友好。所以这里会把所有基本的语法都整理出来，然后就只剩下拼接组合的工作了。</p>
<p data-source-line="2206">最后则是最精彩的部分，利用这些 shell 知识和脚本，让自己的电脑更加强大，简单，易用。</p>
<p data-source-line="2208">shell 的学习是持之以恒的过程，希望读完本章后，读者能掌握基本的概念，在后续的使用过程中不断发现痛点，解决痛点，提高自己的能力。</p>
<h2 data-source-line="2212" id="第-61-章-shell-基本模型与运行原理"><a class="markdownIt-Anchor" href="#第-61-章-shell-基本模型与运行原理"></a>第 6.1 章 Shell 基本模型与运行原理</h2>
<p data-source-line="2214">除了在命令行中直接输入命令，我们还可以把多个命令汇总在一起，放在脚本中，便于后期一起执行。本节主要介绍如何执行 Shell 脚本。这个问题看起来很简单， 但如果不把其中原理想清楚，会导致后期理解上存在偏差，容易踩坑。</p>
<p data-source-line="2216">假设当前目录下有一个 test.sh文件，内容如下：</p>
<pre data-source-line="2218"><code class="hljs"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/Downloads</span></code></pre><p data-source-line="2220">一共有三类方式执行它：</p>
<h3 data-source-line="2221" id="调用解释器执行"><a class="markdownIt-Anchor" href="#调用解释器执行"></a>调用解释器执行</h3>
<p data-source-line="2223">顾名思义，就是把脚本的路径传入解释器中去执行：</p>
<pre data-source-line="2225"><code class="hljs"><span class="hljs-keyword">sh</span> <span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span>
# 或者
bash <span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span></code></pre><p data-source-line="2229">这两者略有区别，我没有整理过完整的差异，但至少对于 echo 命令来说，以下命令在两种解释器下得到的结果是不一样的：</p>
<pre data-source-line="2231"><code class="hljs"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">"hello\nworld"</span></code></pre><p data-source-line="2233">bash 会正确的将 \n 解释为换行符，sh 则不能。个人建议统一使用 bash 即可</p>
<p data-source-line="2235">利用解释器执行 Shell 脚本，实际上是在当前的 Shell 环境中启动了一个子进程去执行。</p>
<h3 data-source-line="2236" id="直接输入文件名运行"><a class="markdownIt-Anchor" href="#直接输入文件名运行"></a>直接输入文件名运行</h3>
<p data-source-line="2238">下面这行命令同样可以用来执行脚本：</p>
<pre data-source-line="2240"><code class="hljs">./<span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span></code></pre><p data-source-line="2242">此时要求脚本文件必须是可执行的，否则将会报错：</p>
<pre data-source-line="2244"><code class="hljs"><span class="hljs-string">zsh:</span> permission <span class="hljs-string">denied:</span> ./test.sh</code></pre><p data-source-line="2246">解决方法是变更文件的权限：chmod +x <a href="http://test.sh" target="_blank">test.sh</a> 然后再执行就可以了。这种运行方式也是新建一个子 Shell 去执行脚本。</p>
<p data-source-line="2248">有的读者可能会问，系统怎么知道这是 Shell 脚本而不是其他语言呢？实际上并不是通过文件名后缀来区分的，可以举个例子：</p>
<pre data-source-line="2250"><code class="hljs"><span class="hljs-meta">#! /usr/bin/python</span>

print <span class="hljs-string">"11"</span></code></pre><p data-source-line="2254">这里用 Python 语法写了一个脚本，但是后缀名保存为 sh，如果我们直输入名称去执行，一样可以得到正确的结果：</p>
<pre data-source-line="2256"><code class="hljs"><span class="hljs-string">./py.sh</span>
<span class="hljs-comment"># 输出 11</span></code></pre><p data-source-line="2259">这里的 #! 被称为 shebang，用来指定使用什么解释器去执行脚本。因此，规则可以简单概括如下：</p>
<pre data-source-line="2261"><code class="hljs">如果直接写明了解释器，比如 <span class="hljs-keyword">sh </span>xxx.<span class="hljs-keyword">sh，会以显式指定的解释器为准，shebang </span>不生效。
如果直接写可执行文件的名字，则以 <span class="hljs-keyword">shebang </span>指定的解释器为准。
如果没有指定 <span class="hljs-keyword">shebang，默认是 </span><span class="hljs-keyword">bash，不会参考文件名的后缀。</span></code></pre><h3 data-source-line="2265" id="在当前-shell-运行"><a class="markdownIt-Anchor" href="#在当前-shell-运行"></a>在当前 Shell 运行</h3>
<p data-source-line="2267">与前两种方式不同的是，我们还可以在当前的 Shell 中执行脚本：</p>
<pre data-source-line="2269"><code class="hljs">. ./<span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span>
# 或者
source ./<span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span></code></pre><p data-source-line="2273">这种做法的好处在于，由于不涉及到 Shell 进程的切换，所有变量和函数的定义都是相通的。比如我在 <a href="http://util.sh" target="_blank">util.sh</a> 里面定义了函数：</p>
<pre data-source-line="2275"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span> {</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello, world"</span>
}</code></pre><p data-source-line="2279">使用方可以通过 source 命令来获取调用函数的能力：</p>
<pre data-source-line="2281"><code class="hljs">source util<span class="hljs-selector-class">.sh</span>
sayHello</code></pre><p data-source-line="2284">通过 . 和 srouce 来调用脚本基本上是一致的，区别在于 source 的兼容性更好，因此更加推荐。</p>
<h2 data-source-line="2288" id="第-62-章-shell-变量与基础语法"><a class="markdownIt-Anchor" href="#第-62-章-shell-变量与基础语法"></a>第 6.2 章 Shell 变量与基础语法</h2>
<h3 data-source-line="2289" id="shell-变量"><a class="markdownIt-Anchor" href="#shell-变量"></a>Shell 变量</h3>
<h4 data-source-line="2290" id="定义变量"><a class="markdownIt-Anchor" href="#定义变量"></a>定义变量</h4>
<p data-source-line="2292">定义变量时，千万不要在等号的两边加空格，否则会报错。正确的做法是：</p>
<pre data-source-line="2294"><code class="hljs"><span class="hljs-attribute">a</span>=1
echo <span class="hljs-variable">$a</span></code></pre><h4 data-source-line="2297" id="引用变量"><a class="markdownIt-Anchor" href="#引用变量"></a>引用变量</h4>
<p data-source-line="2299">正如上面代码所示，用 $ 加上变量名就可以引用变量，有时候我们还会看到另一种写法：</p>
<pre data-source-line="2301"><code class="hljs">a=1
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span>
<span class="hljs-comment"># 下面这种写法也是一样的，而且更推荐</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">${a}</span></code></pre><p data-source-line="2306">一般来说，用大括号把变量名括起来是多此一举，两者作用相同。但如果我们要做字符串拼接，可以这样写：</p>
<pre data-source-line="2308"><code class="hljs">a=hello
<span class="hljs-built_in">echo</span> <span class="hljs-variable">${a}</span>wrold  <span class="hljs-comment"># 输出 helloworld</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$awrold</span>    <span class="hljs-comment"># 变量 awrold 并不存在</span></code></pre><p data-source-line="2312">在 bash/zsh 的语法中，不需要使用专门的字符串拼接函数，只要把两个变量写在一起即可。</p>
<h3 data-source-line="2313" id="引号"><a class="markdownIt-Anchor" href="#引号"></a>引号</h3>
<p data-source-line="2315">bash/zsh 中有单引号和双引号之分，区别在于单引号中的内容完全是字面量，甚至单引号中都无法使用转义字符再打印出单引号。</p>
<p data-source-line="2317">双引号中，如果遇到变量，将会自动转换为变量的值。</p>
<pre data-source-line="2319"><code class="hljs"><span class="hljs-built_in">echo</span> <span class="hljs-string">"\"\""</span>    <span class="hljs-comment"># 输出 ""</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">'\'</span>\<span class="hljs-string">''</span>    <span class="hljs-comment"># 没有输出，因为单引号内部都是字面量</span>

a=1
<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span>"</span>      <span class="hljs-comment"># 输出 1</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">'$a'</span>      <span class="hljs-comment"># 输出 $a，因为单引号不支持变量的展开</span></code></pre><p data-source-line="2326">**注意！！！**在 bash 中，如果变量是一个字符串，而且字符串中含有空格，用双引号括起来的字符串将会被解析为一个独立的单词，直接用 $ 则会被 bash 解析为多个参数。</p>
<p data-source-line="2328">假设当前目录下有个名叫 a b 的文件夹：</p>
<pre data-source-line="2330"><code class="hljs">p=<span class="hljs-string">"a b"</span>
<span class="hljs-built_in">cd</span> <span class="hljs-variable">$p</span>    <span class="hljs-comment"># bash: cd: a: No such file or directory</span>
<span class="hljs-comment"># 这是因为上述命令等价于 cd a b</span>
<span class="hljs-comment"># 字符串 "a b" 的值被拆开传到 cd 命令中，但是 cd 只接收一个参数，导致路径错误</span>
<span class="hljs-comment"># 正确的做法如下</span>
<span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-variable">$p</span>"</span>
<span class="hljs-comment"># 等价于 cd "a b"，路径正确</span></code></pre><p data-source-line="2338"><strong>再次强调</strong>，这个问题只在 bash 中存在，如果我们平时在终端中使用 zsh，但是脚本用 bash 执行，就会遇到这个问题。</p>
<pre data-source-line="2340"><code class="hljs"><span class="hljs-comment">*nix 系统下任何文件夹、文件名严禁留空格，严禁带中文，利人利己！</span></code></pre><h3 data-source-line="2342" id="变量作用域"><a class="markdownIt-Anchor" href="#变量作用域"></a>变量作用域</h3>
<p data-source-line="2344">默认情况下，变量的作用域是当前的 Shell，即使变量定义在函数中也是如此：</p>
<pre data-source-line="2346"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">t</span><span class="hljs-params">()</span> </span>{
    temp=<span class="hljs-number">111</span>
}

<span class="hljs-keyword">echo</span> $temp   <span class="hljs-comment"># 没有输出，变量 temp 未定义</span>
t            <span class="hljs-comment"># 调用函数，函数内部会定义变量</span>
<span class="hljs-keyword">echo</span> $temp   <span class="hljs-comment"># 输出 111</span></code></pre><p data-source-line="2354">因此函数内部的变量要加上 local 关键字才不会污染全局作用域：</p>
<pre data-source-line="2356"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">t</span><span class="hljs-params">()</span> </span>{
    local temp=<span class="hljs-number">111</span>
}

t            <span class="hljs-comment"># 调用函数</span>
<span class="hljs-keyword">echo</span> $temp   <span class="hljs-comment"># 没有输出</span></code></pre><h3 data-source-line="2363" id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a>环境变量</h3>
<p data-source-line="2365">bash/zsh 中的变量分为普通变量和环境变量两种，区别就在于，当我们从当前的 shell 中打开一个新的 subshell 时，环境变量会被 subshell 继承，普通变量则不会。</p>
<pre data-source-line="2367"><code class="hljs">a=1        <span class="hljs-comment"># 定义一个普通变量 a</span>
bash       <span class="hljs-comment"># 打开一个新的 </span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span>    <span class="hljs-comment"># 没有输出，因为 subshell 只会继承父 shell 的环境变量</span></code></pre><p data-source-line="2371">我们可以验证下变量 a 确实是普通变量，而不是环境变量：</p>
<pre data-source-line="2373"><code class="hljs"><span class="hljs-comment"># 单独运行 set 命令可以打印出所有普通变量</span>
set | <span class="hljs-keyword">grep</span> <span class="hljs-string">'a='</span> <span class="hljs-comment"># 能看到变量 a 的定义</span>

<span class="hljs-comment"># 单独运行 env 命令可以打印出所有的环境变量</span>
env | <span class="hljs-keyword">grep</span> <span class="hljs-string">'a='</span> <span class="hljs-comment"># 没有输出，说明变量 a 不是环境变量</span></code></pre><p data-source-line="2379">因此，如果想让某个变量的作用域延伸到 subshell 中，就需要把它定义为环境变量。有两种写法都可以做到：</p>
<pre data-source-line="2381"><code class="hljs"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">a</span>=1
 declare -x <span class="hljs-attribute">a</span>=1</code></pre><p data-source-line="2384">除了在定义时导出为环境变量，也可以把已经定义过的普通变量导出为环境变量：</p>
<pre data-source-line="2386"><code class="hljs"><span class="hljs-built_in">export</span> a
<span class="hljs-built_in">declare</span> -x a</code></pre><h3 data-source-line="2389" id="默认全局变量"><a class="markdownIt-Anchor" href="#默认全局变量"></a>默认全局变量</h3>
<h4 data-source-line="2390" id="pwd"><a class="markdownIt-Anchor" href="#pwd"></a>PWD</h4>
<p data-source-line="2392">记录当前所在的目录，通过 echo $PWD 查看</p>
<h4 data-source-line="2393" id="oldpwd"><a class="markdownIt-Anchor" href="#oldpwd"></a>OLDPWD</h4>
<p data-source-line="2395">表示上一次所在的目录，输入减号 - 可以快速跳转到上一次所在的目录</p>
<h3 data-source-line="2396" id="特殊变量"><a class="markdownIt-Anchor" href="#特殊变量"></a>特殊变量</h3>
<p data-source-line="2398">bash/zsh 中还有一些约定好的只读变量，它们的值在脚本的运行过程中动态确定，常见的有：</p>
<pre data-source-line="2400"><code class="hljs"><span class="hljs-meta">$</span><span class="bash">0：表示脚本名字，可能是相对路径，当我们执行 bash a/b/c/d.sh 是，<span class="hljs-variable">$0</span> 的值是 a/b/c/d.sh</span>
<span class="hljs-meta">$</span><span class="bash">1、<span class="hljs-variable">$2</span>、……、<span class="hljs-variable">$10</span>：用来表示参数，<span class="hljs-variable">$1</span> 表示第一个参数，以此类推</span>
<span class="hljs-meta">$</span><span class="bash"><span class="hljs-comment">#：表示参数个数</span></span>
<span class="hljs-meta">$</span><span class="bash">?：表示上一个命令的执行结果，0 表示正常结束，非 0 表示出现错误</span>

第 2、3 条规则在函数内部同样适用。</code></pre><h3 data-source-line="2407" id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a>基础语法</h3>
<h4 data-source-line="2408" id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a>条件判断</h4>
<p data-source-line="2410">shell 的判断有两种写法，分别是 [ 和 [[，举个例子，下面两种写法都是正确的：</p>
<pre data-source-line="2412"><code class="hljs">abc=<span class="hljs-string">"1"</span>
<span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$abc</span> = <span class="hljs-string">"1"</span> ]]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"equal"</span>
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 或者</span>
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$abc</span> = <span class="hljs-string">"1"</span> ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"equal"</span>
<span class="hljs-keyword">fi</span></code></pre><p data-source-line="2422">虽然两者看起来很类似，但 [ 很早就有了，它的本质是调用内置的 test 指令，而 [[ 的诞生则相对晚的多，它是 bash/zsh 的语法。</p>
<p data-source-line="2424">在实际开发中，两者的细节差异较大，对初学者非常不友好，我的建议是统一使用 [[。</p>
<p data-source-line="2426">shell 中的判断可以分为数字比较、字符串比较和文件判断等几大类。</p>
<h4 data-source-line="2427" id="数字判断"><a class="markdownIt-Anchor" href="#数字判断"></a>数字判断</h4>
<p data-source-line="2429">判断两个数字相等有三种写法：单等号、双等号或 -eq 关键字：</p>
<pre data-source-line="2431"><code class="hljs"><span class="hljs-string">[[ $abc = 1 ]]</span> &amp;&amp; echo <span class="hljs-string">"yes"</span> || echo <span class="hljs-string">"not"</span>
<span class="hljs-string">[[ $abc == 1 ]]</span> &amp;&amp; echo <span class="hljs-string">"yes"</span> || echo <span class="hljs-string">"not"</span>
# 或者 
<span class="hljs-string">[[ $abc -eq 1 ]]</span> &amp;&amp; echo <span class="hljs-string">"yes"</span> || echo <span class="hljs-string">"not"</span>
# 输出结果都是 yes</code></pre><p data-source-line="2437">不等号可以用 != 或 -ne 表示，大于号可以用 &gt; 或者 -gt 来表示，小于号用 &lt; 或者 -lt 表示。这几个英文单词不必记忆。</p>
<p data-source-line="2439">但 shell 不支持 “大于等于”、“小于等于”这些判断，前者用 -ge 表示，后者用 -le 表示。</p>
<h4 data-source-line="2440" id="字符串判断"><a class="markdownIt-Anchor" href="#字符串判断"></a>字符串判断</h4>
<p data-source-line="2442">字符串的判等和数字一致，不同的是可以判断字符串是否为空：</p>
<pre data-source-line="2444"><code class="hljs">str=<span class="hljs-string">""</span> 
# 未定义和长度为零的字符串都算空字符串
<span class="hljs-string">[[ -z $str ]]</span> &amp;&amp; echo <span class="hljs-string">"yes"</span> || echo <span class="hljs-string">"not"</span> # 输出 yes
<span class="hljs-string">[[ -n $str ]]</span> &amp;&amp; echo <span class="hljs-string">"yes"</span> || echo <span class="hljs-string">"not"</span> # 输出 <span class="hljs-keyword">not</span></code></pre><p data-source-line="2449">字符串还支持模式匹配：</p>
<pre data-source-line="2451"><code class="hljs">str=<span class="hljs-string">"hello"</span>
<span class="hljs-string">[[ $str == he* ]]</span> &amp;&amp; echo <span class="hljs-string">"yes"</span> || echo <span class="hljs-string">"not"</span>
# 模式匹配，以 he 开头的单词都能匹配，hello 满足要求，所以输出 yes</code></pre><h4 data-source-line="2455" id="文件判断"><a class="markdownIt-Anchor" href="#文件判断"></a>文件判断</h4>
<p data-source-line="2457">文件判断有以下几种：</p>
<pre data-source-line="2459"><code class="hljs"><span class="hljs-keyword">if</span> <span class="hljs-string">[[ -e file ]]</span>判断是否存在，不限制类型
<span class="hljs-keyword">if</span> <span class="hljs-string">[[ -f file ]]</span>判断文件是否存在，必须是普通类型的文件，不能是文件夹
<span class="hljs-keyword">if</span> <span class="hljs-string">[[ -d file ]]</span>判断文件夹是否存在，必须是文件夹，不能是文件</code></pre><h4 data-source-line="2463" id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a>逻辑运算符</h4>
<p data-source-line="2465">其它语言的几种逻辑运算符可以正常使用：</p>
<pre data-source-line="2467"><code class="hljs"><span class="hljs-string">[[ ! $str == h*lo || 1 = 1 ]]</span> &amp;&amp; echo <span class="hljs-string">"yes"</span> || echo <span class="hljs-string">"not"</span>
# 第一个判断取反，结果为 <span class="hljs-literal">false</span>，但第二个判断为 <span class="hljs-literal">true</span>，所以最终效果是输出 yes

<span class="hljs-string">[[ $str == h*lo &amp;&amp; 1 = 2 ]]</span> &amp;&amp; echo <span class="hljs-string">"yes"</span> || echo <span class="hljs-string">"not"</span>
# 第二个判断为 <span class="hljs-literal">false</span>，所以输出 <span class="hljs-keyword">not</span></code></pre><h4 data-source-line="2473" id="if-语句"><a class="markdownIt-Anchor" href="#if-语句"></a>if 语句</h4>
<p data-source-line="2475">完成的 if 语句如下：</p>
<pre data-source-line="2477"><code class="hljs"><span class="hljs-keyword">if</span> <span class="hljs-string">[[ expression_1 ]]</span>; <span class="hljs-keyword">then</span>
   echo <span class="hljs-string">"condition 1"</span>
elif <span class="hljs-string">[[ expression_2 ]]</span>; <span class="hljs-keyword">then</span>
   echo <span class="hljs-string">"condition 2"</span>
<span class="hljs-keyword">else</span>
   echo <span class="hljs-string">"condition else"</span>
fi</code></pre><p data-source-line="2485">其中 elif 和 else 语句都是可省略的，因此最简单的 if 语句是：</p>
<pre data-source-line="2487"><code class="hljs"><span class="hljs-keyword">if</span> <span class="hljs-string">[[ expression_1 ]]</span>; <span class="hljs-keyword">then</span>
   echo <span class="hljs-string">"condition 1"</span>
fi</code></pre><h4 data-source-line="2491" id="循环"><a class="markdownIt-Anchor" href="#循环"></a>循环</h4>
<p data-source-line="2493">for 循环的语法和 if 比较类似：</p>
<pre data-source-line="2495"><code class="hljs"><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> `ls`; <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$f</span>
<span class="hljs-keyword">done</span></code></pre><h2 data-source-line="2500" id="第-63-章-命令串联"><a class="markdownIt-Anchor" href="#第-63-章-命令串联"></a>第 6.3 章 命令串联</h2>
<h3 data-source-line="2501" id="管道"><a class="markdownIt-Anchor" href="#管道"></a>管道</h3>
<p data-source-line="2503">管道是 shell 中最常用的概念之一，它允许不同脚本、命令之间互相传递数据，举一个最常见的例子：</p>
<pre data-source-line="2505"><code class="hljs"><span class="hljs-keyword">ls</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">'a'</span></code></pre><p data-source-line="2507">默认情况下，命令 ls 会把当前目录下的文件输出到屏幕上，但如果通过管道符号 |，它就会把输出结果传递给下一个命令。</p>
<p data-source-line="2509">命令 grep 恰好支持从管道中读取数据，因此上面这行脚本的含义实际上是在<strong>当前目录内寻找名称含有字母 a 的文件</strong>。</p>
<p data-source-line="2511">我们可以自己模拟一下：</p>
<pre data-source-line="2513"><code class="hljs"><span class="hljs-keyword">function</span> before {
    <span class="hljs-built_in">echo</span> <span class="hljs-string">'output'</span>
}

<span class="hljs-keyword">function</span> after {
    <span class="hljs-built_in">read</span> <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Read from pipiline: "</span><span class="hljs-variable">${in}</span>
}

before | after
<span class="hljs-comment"># 输出结果为：</span>
<span class="hljs-comment"># Read from pipiline: output</span></code></pre><h3 data-source-line="2526" id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a>重定向</h3>
<p data-source-line="2528">说到管道，就不得提提它的孪生兄弟：重定向，最简单的使用场景就是把原本输出到屏幕的内容，重定向到文件中。</p>
<p data-source-line="2530">当然，这只是重定向最简单的用途，如果不了解背后的运行原理，就会影响到后续的使用。</p>
<p data-source-line="2532">首先，*nix 系统中有三种特殊的文件描述符，其中 0 表示标准输入，它一般指的是我们的键盘，1 表示标准输出，2 表示错误输出，它们一般都表示屏幕。所以 Shell 可以理解为一个盒子，它从 0（标准输入，也就是键盘）读取命令，没有错误的话就输出到 1（标准输出），命令执行错误的话输出到 2（错误输出），最终都会在屏幕上显示出来。</p>
<p data-source-line="2534">举一个例子，请看下面这行代码：</p>
<pre data-source-line="2536"><code class="hljs">ls exist<span class="hljs-selector-class">.sh</span> not_exist<span class="hljs-selector-class">.sh</span> <span class="hljs-number">1</span>&gt;success <span class="hljs-number">2</span>&gt;fail</code></pre><p data-source-line="2538">这行代码的意思首先是要展示两个文件，假设一个文件存在，另一个文件不存在（从名字就能看出来了），这样会产生一行标准输出和一行错误输出。1&gt;success 的意思是把标准输出重定向到 success 这个文件，类似的，2 &gt; fail 表示把错误信息输出到 fail 这个文件。</p>
<p data-source-line="2540">类似的语法还可以写成：</p>
<pre data-source-line="2542"><code class="hljs">ls exist<span class="hljs-selector-class">.sh</span> not_exist<span class="hljs-selector-class">.sh</span> &gt;success <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span></code></pre><p data-source-line="2544">这是因为如果 &gt; 前面不加数字，默认是标准输出。而 2&gt;&amp;1 则表示让错误输出使用和标准输出相同的重定向方式。因此这个命令等价于 ls <a href="http://exist.sh" target="_blank">exist.sh</a> not_exist.sh 1&gt;success 2&gt;success。</p>
<p data-source-line="2546">从严格意义上讲，使用 2&gt;&amp;1 的效率更高一些，因为它会复用标准输出的管道。</p>
<h3 data-source-line="2547" id="过滤输出"><a class="markdownIt-Anchor" href="#过滤输出"></a>过滤输出</h3>
<p data-source-line="2549">有了上述背景的积累，我们来看一个实际的问题。有时候在 Shell 脚本中我们只希望用到一个命令的功能， 但不希望它产生任何输出，此时可以使用如下命令：</p>
<pre data-source-line="2551"><code class="hljs">command &gt; /dev/<span class="hljs-literal">null</span> <span class="hljs-number">2</span>&gt;<span class="hljs-meta">&amp;1</span></code></pre><p data-source-line="2553">这行命令表示把标准输出和错误输出都重定向到 /dev/null 文件，只是一个特定的文件，可以理解为\黑洞\。因为任何内容都可以写入这个文件，但对这个文件的读取永远会返回 EOF，也就是输入的任何内容都会被抛弃掉。</p>
<p data-source-line="2555">上述命令还可以简写为 command &amp;&gt;/dev/null，没有什么理由和解释，只不过是 &gt; /dev/null 2&gt;&amp;1 缩略写法。</p>
<p data-source-line="2557">除了使用 &gt; /dev/null 这种写法，还可以使用 &gt;&amp;-，它不表示重定向，而是表示直接关闭某种输出。自然屏幕上也就没有任何内容了。</p>
<p data-source-line="2559">更多类似的技巧请参考这篇文章：Difference between 2&gt;&amp;-, 2&gt;/dev/null, |&amp;, &amp;&gt;/dev/null and &gt;/dev/null 2&gt;&amp;1
输入重定向</p>
<p data-source-line="2562">如果要想拷贝某个文件中的内容到剪贴板，笨的人打开文件按下 Command + A 和 Command + C，聪明一些的人会输入下面这个命令：</p>
<pre data-source-line="2564"><code class="hljs"><span class="hljs-keyword">cat</span> <span class="hljs-keyword">file</span> | pbcopy</code></pre><p data-source-line="2566">这种写法其实还可以再提高一下效率，因为它会读取文件，然后把原本输出到标准输出（屏幕）的内容通过管道转到 pbcopy 这个命令上。</p>
<p data-source-line="2568">更高效、更直接的写法如下：</p>
<pre data-source-line="2570"><code class="hljs">pbcopy &lt; <span class="hljs-built_in">file</span></code></pre><p data-source-line="2572">这样可以减少一次 IO 操作</p>
<h3 data-source-line="2573" id="函数返回值"><a class="markdownIt-Anchor" href="#函数返回值"></a>函数返回值</h3>
<p data-source-line="2575">在函数的结尾可以使用 return 关键字，然而需要注意的是，调用函数后的返回结果，并不是 return 的内容，而是 echo 的内容。至于 return 的内容，则可以通过 $? 这个特殊变量来读取。</p>
<pre data-source-line="2577"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">'output'</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
}

a=`foo`
<span class="hljs-keyword">echo</span> $?        <span class="hljs-comment"># 输出 1</span>
<span class="hljs-keyword">echo</span> $a        <span class="hljs-comment"># 输出 output</span></code></pre><p data-source-line="2586">在 if 语句中，除了可以进行普通的判断外，还可以直接根据命令的执行结果进行判断。此时读取的依然是 return 的结果。</p>
<p data-source-line="2588">前文中提过，正常执行的命令返回值是 0，对应到 if 语句中则是 true 分支：</p>
<pre data-source-line="2590"><code class="hljs"><span class="hljs-keyword">function</span> foo {
    <span class="hljs-built_in">return</span> 1
}

<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> ; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"1"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"0"</span>
<span class="hljs-keyword">fi</span>

<span class="hljs-comment"># 因为函数返回 1，表示执行失败，所以最终输出 0</span></code></pre><p data-source-line="2602">前面曾经介绍过如何判断当前目录下是否存在某个文件，放到 if 中就可以写为：</p>
<pre data-source-line="2604"><code class="hljs"><span class="hljs-keyword">if</span> `ls | grep -q <span class="hljs-string">'a'</span>` ; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"yes"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"no"</span>
<span class="hljs-keyword">fi</span>

这里虽然介绍的是函数返回值，但对整个脚本同样适用</code></pre><h2 data-source-line="2614" id="第-64-章-shell-错误处理"><a class="markdownIt-Anchor" href="#第-64-章-shell-错误处理"></a>第 6.4 章 Shell 错误处理</h2>
<p data-source-line="2616">本文前面部分内容摘录自阮一峰老师的：<a href="http://www.ruanyifeng.com/blog/2017/11/bash-set.html" target="_blank">Bash 脚本 set 命令教程</a>，主要是文章写得太好了。</p>
<h3 data-source-line="2617" id="开启错误处理"><a class="markdownIt-Anchor" href="#开启错误处理"></a>开启错误处理</h3>
<p data-source-line="2619">使用 shell 中的错误处理有助于我们发现错误，更好的调试代码。</p>
<h3 data-source-line="2620" id="检测未定义变量"><a class="markdownIt-Anchor" href="#检测未定义变量"></a>检测未定义变量</h3>
<p data-source-line="2622">首先，set -u 可以在遇到未定义变量时抛出错误，而不是忽略它。比如：</p>
<pre data-source-line="2624"><code class="hljs"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$bar</span></code></pre><p data-source-line="2626">这里的变量 bar 没有定义，shell 的默认方案是忽略掉它。这就可能带来隐藏的问题，所以通过 set -u 选项来强制报错：</p>
<pre data-source-line="2628"><code class="hljs"><span class="hljs-built_in">set</span> -u
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$bar</span></code></pre><p data-source-line="2631">此时会得到报错 ./test.sh: line 2: bar: unbound variable</p>
<h3 data-source-line="2632" id="报错时退出"><a class="markdownIt-Anchor" href="#报错时退出"></a>报错时退出</h3>
<p data-source-line="2634">如果某个命令执行错了，可能会导致后续一系列命令执行出错。既不利于调试，也会导致很多意想不到的结果，所以可以用 set -e 选项来强制报错时退出执行脚本。</p>
<pre data-source-line="2636"><code class="hljs"><span class="hljs-builtin-name">set</span> -e
bbbb
ssss</code></pre><p data-source-line="2640">如果不加上 set -e 会得到两行报错，因为 bbbb 和 ssss 都是不存在的指令。而加上以后，这里只会有一个报错就立刻 exit 了。</p>
<p data-source-line="2642">需要注意的是，如果我们用管道的写法，得到的返回值是最后一个命令的返回值，如果中间的命令出错，是不能被 set -e 捕获的，比如：</p>
<pre data-source-line="2644"><code class="hljs"><span class="hljs-keyword">set</span> -e

bs |<span class="hljs-comment"> ls</span>
echo <span class="hljs-comment">'reach here'</span></code></pre><p data-source-line="2649">得到的输出结果将是：</p>
<pre data-source-line="2651"><code class="hljs">aaa.<span class="hljs-keyword">sh</span>: <span class="hljs-keyword">line</span> 3: <span class="hljs-keyword">bs</span>: command not found
<span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span>
reach here</code></pre><p data-source-line="2655">可见 bs 这个指令虽然不存在，但程序还是没有退出，而是执行到了结尾。因此 set -e 通常需要配合 set -o pipfail 来使用，这样管道中的任何一个指令出错，都会导致程序退出。</p>
<h3 data-source-line="2656" id="调试执行"><a class="markdownIt-Anchor" href="#调试执行"></a>调试执行</h3>
<p data-source-line="2658">如果想知道每一行都执行了什么代码，可以用 set -x 选项，<strong>通常我们在 Jenkins 等工具里可以这么用，方便追查问题</strong>。比如：</p>
<pre data-source-line="2660"><code class="hljs"><span class="hljs-keyword">set</span> -x
<span class="hljs-keyword">ls</span></code></pre><p data-source-line="2663">我们会得到：</p>
<pre data-source-line="2665"><code class="hljs">+ <span class="hljs-keyword">ls</span>
<span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span></code></pre><p data-source-line="2668">以加号开头的行就是文件的原始内容了。</p>
<h3 data-source-line="2669" id="exit-钩子"><a class="markdownIt-Anchor" href="#exit-钩子"></a>exit 钩子</h3>
<p data-source-line="2671">总结一下第一段的内容，我们在任何 shell 脚本的开头都应该加上这行标记：</p>
<pre data-source-line="2673"><code class="hljs"><span class="hljs-keyword">set</span> -euo <span class="hljs-comment">pipefail</span></code></pre><p data-source-line="2675">表示遇到错误指令或未定义的变量时立刻退出。当然，如果需要调试，可以改成 set -euxo pipefail。</p>
<p data-source-line="2677">我们知道退出是靠 exit 命令来实现的，也就是说上述错误最终都会调用到 exit 命令，有没有办法捕获这个退出呢？</p>
<p data-source-line="2679">最简单做法当然是封装 exit，比如：</p>
<pre data-source-line="2681"><code class="hljs"><span class="hljs-keyword">function</span> bs_exit() {
    echo <span class="hljs-string">"exit"</span> &amp;&amp; <span class="hljs-keyword">exit</span> <span class="hljs-variable">$1</span>
}</code></pre><p data-source-line="2685">但如果项目中已有大量的 exit，就需要我们手动替换。虽然成本能接受，但如果可以用 AOP 的方式来 hook exit 命令，肯定是最理想的。</p>
<p data-source-line="2687">这也是<strong>本文的重点</strong>，经过查阅资料，我们可以这样写：</p>
<pre data-source-line="2689"><code class="hljs"><span class="hljs-keyword">function</span> finish {
  err=$?
  <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$err</span> == 1 ]]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">'1'</span>
  <span class="hljs-keyword">fi</span>
}

<span class="hljs-built_in">trap</span> finish EXIT</code></pre><p data-source-line="2698">这里的 trap 是一个内置命令，用来捕捉发送给程序的信号。它接受两个参数，第一个是处理信号的方式，第二个则是信号名。</p>
<p data-source-line="2700">比如当我们使用 exit 命令来退出脚本时，实际上是发送了 EXIT 信号，于是会被捕获，并调用 finish 函数。函数内部可以拿到 exit 后面的状态，因此可以区分用户是通过 exit 1 还是 exit 2 来退出的，方便执行对应的操作。</p>
<p data-source-line="2702"><strong>这种写法的另一个好处在于它是全局的</strong>，比如当我的 shell 脚本存在嵌套调用关系时，只要在入口处定义一次就好，它可以自动捕获 subshell 的退出状态。如果用之前 bs_exit 这种封装，就需要在所有脚本里面都把这个函数 source 进来，成本也更高。</p>
<h3 data-source-line="2703" id="代码调试"><a class="markdownIt-Anchor" href="#代码调试"></a>代码调试</h3>
<p data-source-line="2705">如果只想检查脚本的语法但不执行，可以用 sh -n 命令。如果你的脚本是一个有破坏性或者很耗时的操作，可以用这个技巧来调试语法。比如：</p>
<pre data-source-line="2707"><code class="hljs">bash -<span class="hljs-keyword">n</span> <span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span></code></pre><p data-source-line="2709">此外，我们还可以增强 set -x 指令的效果，上文说过被执行的指令前面会有 + 的前缀，它其实是是通过一个叫做 PS4 的环境变量来控制的。我们可以修改这个变量：</p>
<pre data-source-line="2711"><code class="hljs"><span class="hljs-attribute">export</span> PS4=<span class="hljs-string">'+{<span class="hljs-variable">$LINENO</span>:<span class="hljs-variable">${FUNCNAME[0]}</span>} '</span></code></pre><p data-source-line="2713">这里会显示代码所在行数（LINENO）和当前函数名（FUNCNAME[0]），输出效果如下：</p>
<pre data-source-line="2715"><code class="hljs">+{<span class="hljs-number">11</span>:} trap <span class="hljs-keyword">finish</span> EXIT
+{<span class="hljs-number">13</span>:} fff
./test.<span class="hljs-keyword">sh</span>: <span class="hljs-built_in">line</span> <span class="hljs-number">13</span>: fff: <span class="hljs-keyword">command</span> not found
+{<span class="hljs-number">13</span>:} <span class="hljs-keyword">finish</span>
+{<span class="hljs-number">2</span>:<span class="hljs-keyword">finish</span>} err=<span class="hljs-number">127</span>
+{<span class="hljs-number">3</span>:<span class="hljs-keyword">finish</span>} [[ <span class="hljs-number">127</span> == <span class="hljs-number">1</span> ]]
+{<span class="hljs-number">6</span>:<span class="hljs-keyword">finish</span>} <span class="hljs-keyword">echo</span> <span class="hljs-number">127</span></code></pre><p data-source-line="2723">这个 PS4 变量的修改还是很有用的，因此可以放到 .zshrc 里面去。</p>
<h2 data-source-line="2727" id="第-65-章-必会系统命令"><a class="markdownIt-Anchor" href="#第-65-章-必会系统命令"></a>第 6.5 章 必会系统命令</h2>
<h3 data-source-line="2728" id="grep-2"><a class="markdownIt-Anchor" href="#grep-2"></a>grep</h3>
<p data-source-line="2730">grep 命令很容易学习，它主要有两种使用方式，一种是单独使用，比如搜索某个文件中的内容：</p>
<pre data-source-line="2732"><code class="hljs"><span class="hljs-keyword">grep</span> <span class="hljs-string">'content'</span> <span class="hljs-keyword">file</span>.txt</code></pre><p data-source-line="2734">或者从标准输入中搜索内容：</p>
<pre data-source-line="2736"><code class="hljs"><span class="hljs-keyword">echo</span> <span class="hljs-string">'something'</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">'some'</span></code></pre><p data-source-line="2738">要想掌握好 grep，重点在于了解它的各种参数。下面是一些常用的参数，如果不记得，后续可以用 man grep 命令来查阅。</p>
<p data-source-line="2740">grep 在搜索时，默认是大小写敏感的，但如果要搜索 mysql，它可能写做 mysql 也可能写做 MySQL，这就可能存在搜索不到的问题，此时可以用 -i 参数：</p>
<pre data-source-line="2742"><code class="hljs"><span class="hljs-keyword">echo</span> <span class="hljs-string">'MySQL'</span> | <span class="hljs-keyword">grep</span> -i <span class="hljs-string">'mysql'</span></code></pre><p data-source-line="2744">如果使用 -n 参数可以打印匹配行的行号，使用 -H 参数可以打印匹配文件的文件名。</p>
<p data-source-line="2746">默认情况下，如果某个二进制文件中含有搜索的关键词，会显示 Binary file ... matches，使用 -I 选项可以忽略二进制文件，使用 -a选项可以把二进制文件当做文本文件来处理，从而输出匹配的部分。</p>
<p data-source-line="2748">默认情况下 grep 会展示匹配的那一行，如果想查看上下文，可以使用 -A、-B 和 -C 这三个参数：</p>
<pre data-source-line="2750"><code class="hljs">-A <span class="hljs-number">3</span>：展示匹配行以及后面的 <span class="hljs-number">3</span> 行
-B <span class="hljs-number">3</span>：展示匹配行以及前面的 <span class="hljs-number">3</span> 行
-C <span class="hljs-number">3</span>：展示匹配行以及前后的 <span class="hljs-number">3</span> 行，等价于 -A <span class="hljs-number">3</span> -B <span class="hljs-number">3</span></code></pre><p data-source-line="2754">另外一些常用的选项包括 -v，表示只显示那些不匹配的行，-o 表示只显示匹配的部分，-q 表示不输出内容，通常与 if 连用。</p>
<h3 data-source-line="2755" id="xargs"><a class="markdownIt-Anchor" href="#xargs"></a>xargs</h3>
<p data-source-line="2757">在前面的章节中我们介绍过，可以通过管道将多个命令串联起来，前提是管道后面的命令要支持从标准输入中读取数据，比如前文的 grep 命令。</p>
<p data-source-line="2759">然而有些命令并不支持从标准输入中读取，比如这样写是无效的：</p>
<pre data-source-line="2761"><code class="hljs">echo 'file_name' <span class="hljs-string">| rm</span></code></pre><p data-source-line="2763">此时我们可以借助 xargs 命令：</p>
<pre data-source-line="2765"><code class="hljs">echo <span class="hljs-string">"a"</span> <span class="hljs-string">| xargs rm</span></code></pre><p data-source-line="2767">这条命令的原理是，xargs 会把换行符、空格、制表符、EOF等符号做为分隔符，把输入的内容切分为一个数组，并把数组中每一个元素作为参数，放到后面的命令中执行，用伪代码来写就是：</p>
<pre data-source-line="2769"><code class="hljs"><span class="hljs-keyword">for</span> <span class="hljs-built_in">arg</span> <span class="hljs-keyword">in</span> read_input; <span class="hljs-keyword">do</span>
    rm <span class="hljs-built_in">arg</span>
done</code></pre><p data-source-line="2773">很常见的一个坑就是，如果文件名带有空格，比如 hello world 就会被 xargs 截断为两个参数，显然不符合预期。不过一般对内容或者文件进行过滤时，我们都会使用 grep 或 find，这两个命令都有办法配合 xargs。</p>
<pre data-source-line="2775"><code class="hljs"><span class="hljs-keyword">ls</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">'a'</span> | <span class="hljs-keyword">tr</span> <span class="hljs-string">"\n"</span> <span class="hljs-string">"\0"</span> | xargs -<span class="hljs-number">0</span> rm</code></pre><p data-source-line="2777">用 grep 的话会繁琐一些，需要用 tr 命令把换行符转换成特殊字符 \0，再利用 xargs 的 -0 参数，根据文档所述，这个参数会把分隔符指定为 -0，从而避免了文件名中含有空格的影响。</p>
<p data-source-line="2779">用 find 也是类似的原理：</p>
<pre data-source-line="2781"><code class="hljs"><span class="hljs-builtin-name">find</span> . -print0 | xargs -0 rm</code></pre><p data-source-line="2783">只不过它自带了 -print0选项，写法更简单。</p>
<h3 data-source-line="2784" id="sed"><a class="markdownIt-Anchor" href="#sed"></a>sed</h3>
<p data-source-line="2786">sed 诞生于 1977 年，已经 41 岁了，这么一位叔叔级别的命令至今还活跃在各种 Shell 脚本中，由此可见它是多么重要。</p>
<p data-source-line="2788">Mac 自带的时 BSD 版本的 sed，因为功能较弱，我不推荐使用，建议使用 gsed，如无特殊说明，下文的介绍都是针对 gsed的。</p>
<pre data-source-line="2790"><code class="hljs"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>coreutils
which gsed
<span class="hljs-comment"># /usr/local/bin/gsed</span></code></pre><p data-source-line="2794">sed 和 grep 的用法类似，都是 sed pattern file 或者 echo 'xx' | sed pattern，也就是说第二个参数可以是文件，也可以从标准输入流中读取。</p>
<p data-source-line="2796">最标准的用法是进行文本替换（也可以用 tr 命令实现）：</p>
<pre data-source-line="2798"><code class="hljs">echo <span class="hljs-string">"a b\nc d"</span>
<span class="hljs-meta"># a b</span>
<span class="hljs-meta"># c d</span>
echo <span class="hljs-string">"a b\nc d"</span> | gsed <span class="hljs-string">'s/a/aa/g'</span>
<span class="hljs-meta"># aa b</span>
<span class="hljs-meta"># c d</span></code></pre><p data-source-line="2805">有时候我们可能不止使用一次 sed，此时可以用 -e 参数把多个命令串联起来：</p>
<pre data-source-line="2807"><code class="hljs">echo <span class="hljs-string">"a b\nc d"</span> | gsed -e <span class="hljs-symbol">'s</span>/a/aa/g' -e <span class="hljs-symbol">'s</span>/b/bb/g'</code></pre><p data-source-line="2809">在 gsed 中，还可以使用 Shell 里定义的变量：</p>
<pre data-source-line="2811"><code class="hljs"><span class="hljs-attribute">old</span>=a
<span class="hljs-attribute">new</span>=aa
echo <span class="hljs-string">"a b\nc d"</span> | gsed <span class="hljs-string">"s/<span class="hljs-variable">$old</span>/<span class="hljs-variable">$new</span>/g"</span></code></pre><p data-source-line="2815">我推荐用 gsed 是因为它有一个 -i 选项，可以对文件进行原地修改：</p>
<pre data-source-line="2817"><code class="hljs">gsed -<span class="hljs-selector-tag">i</span> <span class="hljs-string">'s/a/aa/g'</span> file</code></pre><p data-source-line="2819">sed 最核心的部分在于这里的 s/a/aa/g，它由若干个斜杠组成（其实也不一定要用斜杠，只要保持一致就行）。这里的 s 表示替换，a 表示待匹配的内容，支持正则，aa 表示替换后的内容，g 表示全部替换，更多的用法有：</p>
<table data-source-line="2823">
<thead>
<tr>
<th>$0</th>
<th>当前记录（这个变量中存放着整个行的内容）</th>
</tr>
</thead>
<tbody>
<tr>
<td>$1~$n</td>
<td>当前记录的第n个字段，字段间由FS分隔</td>
</tr>
<tr>
<td>FS</td>
<td>输入字段分隔符 默认是空格或Tab</td>
</tr>
<tr>
<td>NF</td>
<td>当前记录中的字段个数，就是有多少列</td>
</tr>
<tr>
<td>NR</td>
<td>已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中</td>
</tr>
<tr>
<td>FNR</td>
<td>当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td>
</tr>
<tr>
<td>RS</td>
<td>输入的记录分隔符， 默认为换行符</td>
</tr>
</tbody>
</table>
<p data-source-line="2833">这些用法虽然看起来复杂，但是和 vim 一样，每个部分就几种写法，然后自行排列组合即可。</p>
<p data-source-line="2835">gsed 在默认情况下，会把输入的每一行都输出一遍，它有一个常用的选项是 -n，表示不输出任何一行。通常与 p 命令合用，这个命令可以打印匹配的行，类似于 grep 的效果。</p>
<h3 data-source-line="2836" id="awk"><a class="markdownIt-Anchor" href="#awk"></a>awk</h3>
<p data-source-line="2838">awk 是和 sed 同时代的命令，并称为文本处理两大神器。个人认为 sed 的强大之处在于文本匹配后的处理，而 awk 则更适合文本的结构化处理。</p>
<p data-source-line="2840">这里以获取 ip 地址的命令来介绍下:</p>
<pre data-source-line="2842"><code class="hljs"><span class="hljs-attribute">ifconfig</span> | sed -n -e <span class="hljs-string">'/127.0.0.1/d'</span> -e <span class="hljs-string">'/inet /p'</span> | awk <span class="hljs-string">'{print <span class="hljs-variable">$2</span>}'</span></code></pre><p data-source-line="2844">这里 awk 的用法其实很简单，就是打印第二列。awk 的核心在于内建的变量：
$0 	当前记录（这个变量中存放着整个行的内容）
$1~$n 	当前记录的第n个字段，字段间由FS分隔
FS 	输入字段分隔符 默认是空格或Tab
NF 	当前记录中的字段个数，就是有多少列
NR 	已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。
FNR 	当前记录数，与NR不同的是，这个值会是各个文件自己的行号
RS 	输入的记录分隔符， 默认为换行符</p>
<p data-source-line="2853">awk 一个很常见的用法是 -f 参数，可以指定输入字段的分隔符：</p>
<pre data-source-line="2855"><code class="hljs"><span class="hljs-attribute">echo</span> <span class="hljs-string">"a;b;c"</span> | awk -F<span class="hljs-string">';'</span> <span class="hljs-string">'{print <span class="hljs-variable">$2</span>}'</span></code></pre><p data-source-line="2857">其实理论上来说，awk 比 sed 还要强大，因为它是一个图灵完备的语言，支持 for 循环等等编程思想。建议感兴趣的读者阅读 AWK 简明教程 了解更多 awk 的使用技巧</p>
<h2 data-source-line="2860" id="第-66-章-高效终端使用指南"><a class="markdownIt-Anchor" href="#第-66-章-高效终端使用指南"></a>第 6.6 章 高效终端使用指南</h2>
<h3 data-source-line="2861" id="别名-alias"><a class="markdownIt-Anchor" href="#别名-alias"></a>别名 alias</h3>
<h3 data-source-line="2862" id="基本用法"><a class="markdownIt-Anchor" href="#基本用法"></a>基本用法</h3>
<p data-source-line="2864">对于特别长的命令，可以使用 alias 来简化它，比如前文介绍的：</p>
<pre data-source-line="2866"><code class="hljs">alias gg=<span class="hljs-string">"git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ci) %C(bold blue) &lt;%an&gt;%Creset' --abbrev-commit"</span></code></pre><p data-source-line="2868">如果存在同名的别名、函数、内置命令等，调用优先级是：</p>
<p data-source-line="2870">别名 &gt; 单数 &gt; 内置命令 &gt; $PATH 路径下的可执行文件。</p>
<p data-source-line="2872">一般我们只用 alias 来简化固定的长命令，由于别名不支持参数，所以复杂的处理流程建议通过定义函数来解决。</p>
<h3 data-source-line="2873" id="高级别名"><a class="markdownIt-Anchor" href="#高级别名"></a>高级别名</h3>
<p data-source-line="2875">除了普通的 alias，我们还可以创建 后缀 alias 和 全局 alias。创建后缀 alias 的写法是：</p>
<pre data-source-line="2877"><code class="hljs"><span class="hljs-built_in">alias</span> -s txt=<span class="hljs-string">'less -r'</span></code></pre><p data-source-line="2879">它表示对于任意命令 xxx.txt，都会被重写为 less -r xxx.txt，也就是原来的命令作为别名的后缀出现。上面这个 alias 的作用是当我们要输出某个 txt 的文件内容时，只要输入 xxx.txt 就可以了，无需更多的命令。</p>
<p data-source-line="2881">全局 alias 就更强大了，它会对整个命令进行匹配和替换，举个栗子：</p>
<pre data-source-line="2883"><code class="hljs"><span class="hljs-built_in">alias</span> -g L=<span class="hljs-string">'| less'</span></code></pre><p data-source-line="2885">以前如果想用 less 去查看一个文件需要写成 cat xxx | less，由于有了全局别名，现在只要写成 cat xxx L 即可。</p>
<p data-source-line="2887">如果输入命令 alias xxx L -r 它会被替换成 alias xxx | less -r。</p>
<p data-source-line="2889">相信读者已经能理解后缀 alias 和全局 alias 的用法，但请慎用，尤其是全局 alias，类似于 C 语言的宏定义，滥用可能会带来一些危险，建议先看看大神是怎么用的，这里面提供了很多 alias，如果不是必要，我建议尽量避免自行添加。</p>
<h3 data-source-line="2890" id="查看定义"><a class="markdownIt-Anchor" href="#查看定义"></a>查看定义</h3>
<p data-source-line="2892">如果只是想查看别名或者函数的定义，可以使用 which 命令：</p>
<p data-source-line="2894"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDvRA5Ebr5stdHyjcg5%252F-LDvS2riEvKqo0ttq7X8%252Fimage.png%3Falt%3Dmedia%26token%3D1967e8bc-b3bf-4f87-8ee2-04cffc700afa" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDvRA5Ebr5stdHyjcg5%2F-LDvS2riEvKqo0ttq7X8%2Fimage.png?alt=media&amp;token=1967e8bc-b3bf-4f87-8ee2-04cffc700afa&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDvRA5Ebr5stdHyjcg5%252F-LDvS2riEvKqo0ttq7X8%252Fimage.png%3Falt%3Dmedia%26token%3D1967e8bc-b3bf-4f87-8ee2-04cffc700afa"></p>
<p data-source-line="2896">但如果拿到别人的配置脚本，想自行定制。显然只知道定义是不够的，还得知道这个 alias 或者函数是在哪个文件里被定义的，这样才好去修改，此时建议使用我配置的 bswhich 命令：</p>
<p data-source-line="2898"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDvRA5Ebr5stdHyjcg5%252F-LDvSLF_jI4-lgim8hqi%252Fimage.png%3Falt%3Dmedia%26token%3Dd21a8296-0e82-4714-83b5-3021952d93b2" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LDvRA5Ebr5stdHyjcg5%2F-LDvSLF_jI4-lgim8hqi%2Fimage.png?alt=media&amp;token=d21a8296-0e82-4714-83b5-3021952d93b2&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LDvRA5Ebr5stdHyjcg5%252F-LDvSLF_jI4-lgim8hqi%252Fimage.png%3Falt%3Dmedia%26token%3Dd21a8296-0e82-4714-83b5-3021952d93b2"></p>
<p data-source-line="2900">这是因为查找 alias 定义位置和函数定义位置的方法还不一样，完整的写法是：</p>
<pre data-source-line="2902"><code class="hljs"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">bswhich</span></span>() {
    <span class="hljs-keyword">if</span> `<span class="hljs-built_in">type</span> <span class="hljs-variable">$1</span> | grep -q <span class="hljs-string">'is a shell function'</span>`; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">type</span> <span class="hljs-variable">$1</span>
        <span class="hljs-built_in">which</span> <span class="hljs-variable">$1</span>
    <span class="hljs-keyword">elif</span> `<span class="hljs-built_in">type</span> <span class="hljs-variable">$1</span> | grep -q <span class="hljs-string">'is an alias'</span>`; <span class="hljs-keyword">then</span>
        PS4=<span class="hljs-string">'+%x:%I&gt;'</span> zsh -i -x -c <span class="hljs-string">''</span> |&amp; grep <span class="hljs-string">'&gt;alias '</span> | grep <span class="hljs-string">"<span class="hljs-variable">${1}</span>="</span>
    <span class="hljs-keyword">fi</span>
}</code></pre><h3 data-source-line="2911" id="autojump"><a class="markdownIt-Anchor" href="#autojump"></a>Autojump</h3>
<p data-source-line="2913">如果不想每次都输入 cd 再输入 ls，那么 autojump 是必装的神器：</p>
<pre data-source-line="2915"><code class="hljs"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>autojump</code></pre><p data-source-line="2917">它会记住每一次 cd 的路径，并且保存在数据中，以后我们可以直接输入 j + 关键字，从而避免频繁的 cd。</p>
<h3 data-source-line="2918" id="终端命令自动补全"><a class="markdownIt-Anchor" href="#终端命令自动补全"></a>终端命令自动补全</h3>
<p data-source-line="2920">输入快捷键 Ctrl + E 可以根据当前提示快速补全，快捷键 ; 可以补全并执行</p>
<p data-source-line="2922"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LFqx_C30T9hjpcDNEka%252F-LFqxbTJ4C7M3xOtgvgk%252Fzsh-autocompletion.gif%3Falt%3Dmedia%26token%3D052771b2-1cec-481f-997f-fc096042b1fc" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LFqx_C30T9hjpcDNEka%2F-LFqxbTJ4C7M3xOtgvgk%2Fzsh-autocompletion.gif?alt=media&amp;token=052771b2-1cec-481f-997f-fc096042b1fc&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LFqx_C30T9hjpcDNEka%252F-LFqxbTJ4C7M3xOtgvgk%252Fzsh-autocompletion.gif%3Falt%3Dmedia%26token%3D052771b2-1cec-481f-997f-fc096042b1fc"></p>
<h3 data-source-line="2924" id="终端-finder-模拟器r"><a class="markdownIt-Anchor" href="#终端-finder-模拟器r"></a>终端 Finder 模拟器：r</h3>
<p data-source-line="2926">系统的 Finder 其实并没那么好用，最大的问题在于没法和 Shell 有效的交互，比如复制移动文件、在当前文件夹位置打开终端都很不方便。</p>
<p data-source-line="2928">作为程序员，我推荐使用 Ranger 来浏览文件目录，它是一个使用 Vim 键位映射的文件管理工具。</p>
<p data-source-line="2930">使用快捷键 r 来打开 ranger，它的完整定义是：alias r='source ranger'，这样做的好处在于当 Ranger 中目录发生变化时，可以改变外部 Shell 的路径。</p>
<p data-source-line="2932">在 Ranger 中，使用 j/k 来上下移动光标，h/l 来进行目录的前进和后退。</p>
<p data-source-line="2934">常用的操作有：</p>
<pre data-source-line="2936"><code class="hljs">zh：切换是否显示系统隐藏文件，按一次打开，再按一次关闭
x：安全删除文件（放入垃圾箱中而不是 rm）
yy：复制，dd：剪贴，pp：粘贴，空格键多选文件
gh：进入用户目录（$HOME）
yn：复制文件名，yd 复制文件夹名，yp 复制完整路径名
:j：和 autojump 一样，输入要跳转的地方
Ctrl + f：利用 fzf 搜索文件
f：当前目录内过滤文件名
du：查看当前目录内各文件夹大小
oo：在 Finder 中打开，op 或回车键：使用系统默认的程序打开，oc：使用 VSCode 打开（如果已经有 VSCode 进程，为了加快速度，则使用已存在的）
m：添加书签，um：选择要删除的书签，```：展示书签</code></pre><h3 data-source-line="2948" id="fzf模糊搜索神器"><a class="markdownIt-Anchor" href="#fzf模糊搜索神器"></a>fzf：模糊搜索神器</h3>
<p data-source-line="2950">fzf 是一个模糊搜索神器，^t 是特定语义下的补全快捷键，^i 是默认快捷键，很少用到：</p>
<pre data-source-line="2952"><code class="hljs">输入 <span class="hljs-keyword">kill</span> 然后按下 <span class="hljs-symbol">^t</span> 键，就会打开 fzf 补全界面，通过输入进程名来获取到 PID
类似的还有输入 ssh、export、unset、unlias 等命令
按下 alt + c 可以列出当前目录下的文件夹，并快速进入
按下 <span class="hljs-symbol">^g</span>，会自动补全 autojump 的路径列表
按下 <span class="hljs-symbol">^r</span> 进入命令历史模式，此时也会自动打开 fzf 补全界面，自动补全命令
注意此时的补全并不会自动执行，只会把命令粘贴到命令行中，如果想要按下回车后自动执行，可以用快捷键 <span class="hljs-symbol">^x</span><span class="hljs-symbol">^r</span> 来触发</code></pre><p data-source-line="2959">fzf 甚至还支持为自定义的命令添加补全，具体做法可以参考：<a href="https://github.com/junegunn/fzf/wiki/Examples-%28completion%29" target="_blank">Examples (completion)</a></p>
<h2 data-source-line="2962" id="第-67-章-常用命令推荐"><a class="markdownIt-Anchor" href="#第-67-章-常用命令推荐"></a>第 6.7 章 常用命令推荐</h2>
<h3 data-source-line="2963" id="bsfn查找文件名"><a class="markdownIt-Anchor" href="#bsfn查找文件名"></a>bsfn：查找文件名</h3>
<p data-source-line="2965">如果你想查找文件夹内的某个文件，可以使用 find 命令，但默认的 find 命令并不支持表达，所以我在 personalized.sh文件中封装了 bsfn 函数，它接受一个参数，可以精确匹配，也可以写正则表达式：</p>
<p data-source-line="2967"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LEJnvVdfIzSBIp0ZNxL%252F-LEJouv_pkL-M1tveGvc%252Fimage.png%3Falt%3Dmedia%26token%3D00c0b68b-de2e-4d6c-962f-c41394feb57e" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LEJnvVdfIzSBIp0ZNxL%2F-LEJouv_pkL-M1tveGvc%2Fimage.png?alt=media&amp;token=00c0b68b-de2e-4d6c-962f-c41394feb57e&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LEJnvVdfIzSBIp0ZNxL%252F-LEJouv_pkL-M1tveGvc%252Fimage.png%3Falt%3Dmedia%26token%3D00c0b68b-de2e-4d6c-962f-c41394feb57e"></p>
<p data-source-line="2969">比如这里我们搜索所有以 BBA 开头，中间字符不限，以 Plugin 结尾的文件。</p>
<h3 data-source-line="2970" id="bsgrep查找内容"><a class="markdownIt-Anchor" href="#bsgrep查找内容"></a>bsgrep：查找内容</h3>
<p data-source-line="2972">简单的装了 grep，如果不加路径，则表示在当前目录下递归搜索。</p>
<h3 data-source-line="2973" id="bsfilename-获取文件名"><a class="markdownIt-Anchor" href="#bsfilename-获取文件名"></a>bsfilename： 获取文件名</h3>
<p data-source-line="2975">这个命令可以从完整的文件路径中获取不带后缀的文件名，比如</p>
<pre data-source-line="2977"><code class="hljs">bsfilename ~/Desktop/test.py
<span class="hljs-meta">#</span><span class="bash"> 输出结果: <span class="hljs-built_in">test</span></span></code></pre><h3 data-source-line="2980" id="bsof-检查系统端口占用"><a class="markdownIt-Anchor" href="#bsof-检查系统端口占用"></a>bsof： 检查系统端口占用</h3>
<p data-source-line="2982">可以通过系统的 lsof -i:port 来检查哪个程序占用了 port 端口，但有时候我们不想记参数，或者想查找某个程序占用了哪些端口，此时可以使用 bsof。</p>
<p data-source-line="2984">比如查看 redis 进程占用了哪些端口，可以输入 bsof redis，查看哪些进程占用了 80 端口可以输入 bsof :80，如下图所示：</p>
<h3 data-source-line="2986" id="bszip-压缩文件"><a class="markdownIt-Anchor" href="#bszip-压缩文件"></a>bszip： 压缩文件</h3>
<p data-source-line="2988">这个命令可以快速压缩文件，用法 bszip path_to_file，它会读取要压缩的文件(夹)名，然后在当前目录生成同名的 zip 文件</p>
<h3 data-source-line="2989" id="bswhich查看定义"><a class="markdownIt-Anchor" href="#bswhich查看定义"></a>bswhich：查看定义</h3>
<p data-source-line="2991">如果拿到别人的配置脚本，想自行定制。显然只知道定义是不够的，还得知道这个 alias 或者函数是在哪个文件里被定义的，这样才好去修改，此时建议使用我配置的 bswhich 命令：</p>
<pre data-source-line="2993"><code class="hljs">bswhich<span class="hljs-built_in"> ip
</span>bswhich gg</code></pre><h3 data-source-line="2996" id="bssize查看文件和文件夹大小"><a class="markdownIt-Anchor" href="#bssize查看文件和文件夹大小"></a>bssize：查看文件和文件夹大小</h3>
<p data-source-line="2998">bssize 后面的参数可以是文件名，表示查看这个文件的大小。也可以是文件夹名，表示查看文件夹大小和文件夹内各子目录的大小。</p>
<p data-source-line="3000">bssize . 表示查看当前目录大小和子目录大小，bssize / 表示查看系统磁盘的使用情况。具体效果如图所示</p>
<p data-source-line="3002"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LEJnvVdfIzSBIp0ZNxL%252F-LEJoov74K9glfxppxAM%252Fimage.png%3Falt%3Dmedia%26token%3D9c890007-1ce9-49b0-ab29-daea79335c86" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LEJnvVdfIzSBIp0ZNxL%2F-LEJoov74K9glfxppxAM%2Fimage.png?alt=media&amp;token=9c890007-1ce9-49b0-ab29-daea79335c86&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LEJnvVdfIzSBIp0ZNxL%252F-LEJoov74K9glfxppxAM%252Fimage.png%3Falt%3Dmedia%26token%3D9c890007-1ce9-49b0-ab29-daea79335c86"></p>
<h3 data-source-line="3004" id="c使用-vscode-编辑"><a class="markdownIt-Anchor" href="#c使用-vscode-编辑"></a>c：使用 VSCode 编辑</h3>
<p data-source-line="3006">首先需要集成 VSCode 的命令行工具，步骤可以参考这个链接</p>
<p data-source-line="3008">这个命令有三种用法：</p>
<pre data-source-line="3010"><code class="hljs">如果不加任何参数，会使用 VSCode 打开当前文件夹
如果参数所代表的文件或文件夹存在，会用 VSCode 打开指定的文件夹
如果参数代表的文件不存在，会用 autojump 打开指定路径并使用 VSCode 编辑</code></pre><h3 data-source-line="3014" id="ow快速打开-xcode-工程"><a class="markdownIt-Anchor" href="#ow快速打开-xcode-工程"></a>ow：快速打开 xcode 工程</h3>
<p data-source-line="3016">自动查找当前目录下的 xcworkspace 和 xcodeproj 文件并打开， 也可以指定路径。</p>
<h3 data-source-line="3017" id="proxy展示和切换系统代理"><a class="markdownIt-Anchor" href="#proxy展示和切换系统代理"></a>proxy：展示和切换系统代理</h3>
<p data-source-line="3019">如果想使用 Charles 抓包，则输入 p on 即可将系统的 HTTP 和 HTTPS 代理设置为 127.0.0.1:8888</p>
<p data-source-line="3021">如果想使用 Shadowsocks 科学上网，则输入 p g 即可将系统的 socks 代理设置为 localhost:14179，需要自行修改端口号</p>
<p data-source-line="3023">如果不想使用代理，输入 p off 可以禁用所有代理，恢复默认设置。</p>
<p data-source-line="3025">输入 p s 可以查看当前的系统代理：</p>
<p data-source-line="3027"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LEJnvVdfIzSBIp0ZNxL%252F-LEJos4gZu6XspyOAbST%252Fimage.png%3Falt%3Dmedia%26token%3Da6565c85-54e2-4356-9784-13452cc15fb9" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LEJnvVdfIzSBIp0ZNxL%2F-LEJos4gZu6XspyOAbST%2Fimage.png?alt=media&amp;token=a6565c85-54e2-4356-9784-13452cc15fb9&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LEJnvVdfIzSBIp0ZNxL%252F-LEJos4gZu6XspyOAbST%252Fimage.png%3Falt%3Dmedia%26token%3Da6565c85-54e2-4356-9784-13452cc15fb9"></p>
<p data-source-line="3029">ppjson：终端 json 格式化</p>
<p data-source-line="3031">用法：</p>
<pre data-source-line="3033"><code class="hljs">echo '{<span class="hljs-string">"hello"</span>: <span class="hljs-string">"world"</span>}' | <span class="hljs-type">ppjson</span></code></pre><p data-source-line="3035">效果：</p>
<p data-source-line="3037"><img data-src="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LEJnvVdfIzSBIp0ZNxL%252F-LEJoxqwT5lJrQdKY5b5%252Fimage.png%3Falt%3Dmedia%26token%3D2c61b5d3-d9b7-4663-b45b-aac9ab06264b" alt="image" src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LBLo0eP1FW2IkggnToa%2F-LEJnvVdfIzSBIp0ZNxL%2F-LEJoxqwT5lJrQdKY5b5%2Fimage.png?alt=media&amp;token=2c61b5d3-d9b7-4663-b45b-aac9ab06264b&amp;ynotemdtimestamp=1536291187205" data-processed="https%3A%2F%2Fblobscdn.gitbook.com%2Fv0%2Fb%2Fgitbook-28427.appspot.com%2Fo%2Fassets%252F-LBLo0eP1FW2IkggnToa%252F-LEJnvVdfIzSBIp0ZNxL%252F-LEJoxqwT5lJrQdKY5b5%252Fimage.png%3Falt%3Dmedia%26token%3D2c61b5d3-d9b7-4663-b45b-aac9ab06264b"></p>
<h3 data-source-line="3039" id="encode64-和-urltool"><a class="markdownIt-Anchor" href="#encode64-和-urltool"></a>encode64 和 urltool</h3>
<p data-source-line="3041">这几个小命令可以快速实现一些编码和解码工作：</p>
<pre data-source-line="3043"><code class="hljs">e<span class="hljs-symbol">ncode64</span> 你好
<span class="hljs-attr"># 5</span>L<span class="hljs-number">2</span><span class="hljs-name">g5</span>aW<span class="hljs-number">9</span>

decode<span class="hljs-number">64</span> <span class="hljs-number">5</span>L<span class="hljs-number">2</span><span class="hljs-name">g5</span>aW<span class="hljs-number">9</span>
<span class="hljs-attr"># 你好%

urlencode https://baidu.com
# https%3</span>A<span class="hljs-meta">%</span><span class="hljs-number">2</span>F<span class="hljs-meta">%</span><span class="hljs-number">2</span>Fbaidu.com

urldecode https<span class="hljs-meta">%</span><span class="hljs-number">3</span>A<span class="hljs-meta">%</span><span class="hljs-number">2</span>F<span class="hljs-meta">%</span><span class="hljs-number">2</span>Fbaidu.com
<span class="hljs-attr"># https://baidu.com</span></code></pre><h3 data-source-line="3055" id="全局别名"><a class="markdownIt-Anchor" href="#全局别名"></a>全局别名</h3>
<pre data-source-line="3057"><code class="hljs">如果只想看某个输出的前 <span class="hljs-number">3</span> 行，可以用 cat xxx H <span class="hljs-number">3</span>，这是因为 H 被全局重命名为 | head -n
如果是看输出的后 <span class="hljs-number">3</span> 行，可以用 cat xxx T <span class="hljs-number">3</span>，其中 T 被全局重命名为 | tail -n
如果是看输出的指定行数，比如第 <span class="hljs-number">1</span>、<span class="hljs-number">3</span>、<span class="hljs-number">7</span> 行，可以用 cat xxx R <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span>, 其中 R 被全局重命名为 | row
如果要看某个输出的某几列，比如倒数第一列，可以用 cat xxx C <span class="hljs-number">-1</span>，其中 C 被全局重命名为 | column
如果要在 less 中查看某个超长的输出，可以用 cat xxx L，其中 L 被全局重命名为 | L
如果要忽略某条命令的报错，可以用 command NE，其中 NE 被全局重命名为 <span class="hljs-number">2</span>&gt; /dev/null
如果要某个命令完全不输出内容，可以用 command NUL，其中 NUL被全局重命名为 &gt; /dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span></code></pre><h3 data-source-line="3065" id="文本处理"><a class="markdownIt-Anchor" href="#文本处理"></a>文本处理</h3>
<p data-source-line="3067">使用 column 获取指定的列，或使用 row 获取指定的行：</p>
<pre data-source-line="3069"><code class="hljs"><span class="hljs-built_in">echo</span> <span class="hljs-string">"a b c"</span> | column 1 3
<span class="hljs-comment"># a c</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"a\nb\nc\n"</span> | row 1 3
<span class="hljs-comment"># a</span>
<span class="hljs-comment"># c</span></code></pre><p data-source-line="3075">使用 ncolumn 过滤指定的列，或使用 nrow 过滤指定的行：</p>
<pre data-source-line="3077"><code class="hljs"><span class="hljs-built_in">echo</span> <span class="hljs-string">"a b c"</span> | ncolumn 2
<span class="hljs-comment"># a c</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"a\nb\nc\n"</span> | nrow 2
<span class="hljs-comment"># a</span>
<span class="hljs-comment"># c</span></code></pre><p data-source-line="3083">使用 average 对列求平均，使用 add 对列求和：</p>
<pre data-source-line="3085"><code class="hljs">echo <span class="hljs-string">"1<span class="hljs-subst">\n</span>3<span class="hljs-subst">\n</span>5"</span> | average
# <span class="hljs-number">5</span>
echo <span class="hljs-string">"1<span class="hljs-subst">\n</span>3<span class="hljs-subst">\n</span>5"</span> | add
# <span class="hljs-number">9</span></code></pre></div></article><body></body></html>